{"version":3,"file":"index-CLjuxHjr.js","sources":["../../src/scanner/ast-scanner.ts"],"sourcesContent":["/**\n * AST scanner for parsing @smrt() decorated classes\n * Uses TypeScript Compiler API to extract metadata\n */\n\nimport * as ts from 'typescript';\nimport type {\n  FieldDefinition,\n  MethodDefinition,\n  ScanOptions,\n  ScanResult,\n  SmartObjectDefinition,\n} from './types';\n\nexport class ASTScanner {\n  private program: ts.Program;\n  private options: ScanOptions;\n\n  constructor(filePaths: string[], options: ScanOptions = {}) {\n    this.options = {\n      includePrivateMethods: false,\n      includeStaticMethods: true,\n      followImports: false,\n      baseClasses: ['SmrtObject', 'SmrtClass', 'SmrtCollection'],\n      ...options,\n    };\n\n    // Create TypeScript program\n    this.program = ts.createProgram(filePaths, {\n      target: ts.ScriptTarget.ES2022,\n      module: ts.ModuleKind.ESNext,\n      allowJs: true,\n      declaration: true,\n      esModuleInterop: true,\n      skipLibCheck: true,\n      strict: true,\n    });\n  }\n\n  /**\n   * Scan files for SMRT object definitions\n   */\n  scanFiles(): ScanResult[] {\n    const results: ScanResult[] = [];\n\n    for (const sourceFile of this.program.getSourceFiles()) {\n      if (sourceFile.isDeclarationFile) continue;\n\n      const result = this.scanFile(sourceFile);\n      if (result.objects.length > 0 || result.errors.length > 0) {\n        results.push(result);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Scan a single source file\n   */\n  private scanFile(sourceFile: ts.SourceFile): ScanResult {\n    const result: ScanResult = {\n      filePath: sourceFile.fileName,\n      objects: [],\n      errors: [],\n    };\n\n    try {\n      ts.forEachChild(sourceFile, (node) => {\n        if (ts.isClassDeclaration(node)) {\n          try {\n            const objectDef = this.parseClassDeclaration(node, sourceFile);\n            if (objectDef) {\n              result.objects.push(objectDef);\n            }\n          } catch (classError) {\n            result.errors.push({\n              message:\n                classError instanceof Error\n                  ? `Error parsing class: ${classError.message}\\nStack: ${classError.stack}`\n                  : 'Unknown class parsing error',\n              line: 0,\n              column: 0,\n            });\n          }\n        }\n      });\n    } catch (error) {\n      result.errors.push({\n        message:\n          error instanceof Error ? error.message : 'Unknown parsing error',\n        line: 0,\n        column: 0,\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Parse a class declaration for SMRT metadata\n   */\n  private parseClassDeclaration(\n    node: ts.ClassDeclaration,\n    sourceFile: ts.SourceFile,\n  ): SmartObjectDefinition | null {\n    const className = node.name?.text;\n    if (!className) return null;\n\n    // Skip base classes themselves (they shouldn't be in the manifest)\n    if (this.options.baseClasses?.includes(className)) return null;\n\n    // Check if class extends a SMRT base class (primary requirement)\n    if (!this.extendsBaseClass(node)) return null;\n\n    // Look for @smrt() decorator (optional - only needed for custom config)\n    const smrtDecorator = this.findSmrtDecorator(node);\n\n    // Extract decorator configuration (use defaults if no decorator)\n    const decoratorConfig = smrtDecorator\n      ? this.parseDecoratorConfig(smrtDecorator)\n      : {}; // Default empty config when no decorator present\n\n    // Generate collection name (pluralized)\n    const collection = this.pluralize(className.toLowerCase());\n\n    const objectDef: SmartObjectDefinition = {\n      name: className.toLowerCase(),\n      className,\n      collection,\n      filePath: sourceFile.fileName,\n      fields: {},\n      methods: {},\n      decoratorConfig,\n    };\n\n    // Parse class members\n    for (const member of node.members) {\n      if (ts.isPropertyDeclaration(member)) {\n        const field = this.parsePropertyDeclaration(member, sourceFile);\n        if (field) {\n          const fieldName = this.getPropertyName(member);\n          if (fieldName) {\n            objectDef.fields[fieldName] = field;\n          }\n        }\n      } else if (ts.isMethodDeclaration(member)) {\n        const method = this.parseMethodDeclaration(member, sourceFile);\n        if (method) {\n          objectDef.methods[method.name] = method;\n        }\n      }\n    }\n\n    return objectDef;\n  }\n\n  /**\n   * Find @smrt() decorator on class\n   */\n  private findSmrtDecorator(node: ts.ClassDeclaration): ts.Decorator | null {\n    if (!node.modifiers) return null;\n\n    for (const modifier of node.modifiers) {\n      if (ts.isDecorator(modifier)) {\n        const expression = modifier.expression;\n\n        // Handle @smrt() or @smrt\n        if (ts.isCallExpression(expression)) {\n          if (\n            ts.isIdentifier(expression.expression) &&\n            expression.expression.text === 'smrt'\n          ) {\n            return modifier;\n          }\n        } else if (ts.isIdentifier(expression) && expression.text === 'smrt') {\n          return modifier;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if class extends a SMRT base class\n   */\n  private extendsBaseClass(node: ts.ClassDeclaration): boolean {\n    if (!node.heritageClauses) return false;\n\n    for (const clause of node.heritageClauses) {\n      if (clause.token === ts.SyntaxKind.ExtendsKeyword) {\n        for (const type of clause.types) {\n          // Handle both simple identifiers and complex expressions\n          let baseClassName: string | undefined;\n\n          if (ts.isIdentifier(type.expression)) {\n            baseClassName = type.expression.text;\n          } else if (ts.isPropertyAccessExpression(type.expression)) {\n            // Handle cases like 'SmrtBase.SubClass'\n            baseClassName = type.expression.name?.text;\n          } else if (type.expression) {\n            // Try to extract text from any expression\n            const expressionText = type.expression.getText?.();\n            baseClassName = expressionText?.split('.').pop()?.trim();\n          }\n\n          if (baseClassName && this.options.baseClasses?.includes(baseClassName)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse decorator configuration from @smrt(config)\n   * Uses safe AST parsing instead of eval()\n   */\n  private parseDecoratorConfig(decorator: ts.Decorator): any {\n    const defaultConfig = { api: {}, mcp: {}, cli: false };\n\n    if (!ts.isCallExpression(decorator.expression)) {\n      return defaultConfig;\n    }\n\n    const args = decorator.expression.arguments;\n    if (args.length === 0) return defaultConfig;\n\n    const configArg = args[0];\n    if (!ts.isObjectLiteralExpression(configArg)) {\n      return defaultConfig;\n    }\n\n    try {\n      // Safe AST-based parsing\n      return this.parseObjectLiteralExpression(configArg);\n    } catch (error) {\n      console.warn('[ast-scanner] Error parsing decorator config:', error);\n      return defaultConfig;\n    }\n  }\n\n  /**\n   * Safely parse an object literal expression from AST\n   * Replaces eval() with proper AST traversal\n   */\n  private parseObjectLiteralExpression(node: ts.ObjectLiteralExpression): any {\n    const result: any = {};\n\n    for (const property of node.properties) {\n      if (ts.isPropertyAssignment(property)) {\n        const key = this.getPropertyKey(property.name);\n        if (key) {\n          result[key] = this.parseExpressionValue(property.initializer);\n        }\n      } else if (ts.isShorthandPropertyAssignment(property)) {\n        const key = property.name.text;\n        result[key] = true; // Shorthand properties default to true\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get property key from property name\n   */\n  private getPropertyKey(name: ts.PropertyName): string | null {\n    if (ts.isIdentifier(name)) {\n      return name.text;\n    }\n    if (ts.isStringLiteral(name) || ts.isNumericLiteral(name)) {\n      return name.text;\n    }\n    return null;\n  }\n\n  /**\n   * Parse expression value safely\n   */\n  private parseExpressionValue(expr: ts.Expression): any {\n    // Handle literals\n    if (ts.isStringLiteral(expr)) {\n      return expr.text;\n    }\n    if (ts.isNumericLiteral(expr)) {\n      return Number(expr.text);\n    }\n    if (expr.kind === ts.SyntaxKind.TrueKeyword) {\n      return true;\n    }\n    if (expr.kind === ts.SyntaxKind.FalseKeyword) {\n      return false;\n    }\n    if (expr.kind === ts.SyntaxKind.NullKeyword) {\n      return null;\n    }\n\n    // Handle arrays\n    if (ts.isArrayLiteralExpression(expr)) {\n      return expr.elements\n        .map((element) =>\n          ts.isExpression(element)\n            ? this.parseExpressionValue(element)\n            : undefined,\n        )\n        .filter((val) => val !== undefined);\n    }\n\n    // Handle nested objects\n    if (ts.isObjectLiteralExpression(expr)) {\n      return this.parseObjectLiteralExpression(expr);\n    }\n\n    // For complex expressions, return a safe fallback\n    return expr.getText().trim();\n  }\n\n  /**\n   * Parse property declaration to field definition\n   */\n  private parsePropertyDeclaration(\n    node: ts.PropertyDeclaration,\n    sourceFile: ts.SourceFile,\n  ): FieldDefinition | null {\n    // Skip static properties for now\n    if (node.modifiers?.some((m) => m.kind === ts.SyntaxKind.StaticKeyword)) {\n      return null;\n    }\n\n    // Determine field type from initializer or type annotation\n    const fieldType = this.inferFieldType(node, sourceFile);\n    // Required if no question token and no undefined/null type\n    const isRequired =\n      !node.questionToken && !this.hasOptionalType(node, sourceFile);\n\n    const field: FieldDefinition = {\n      type: fieldType,\n      required: isRequired,\n    };\n\n    // Extract default value from initializer\n    if (node.initializer) {\n      field.default = this.extractDefaultValue(node.initializer);\n    }\n\n    return field;\n  }\n\n  /**\n   * Parse method declaration to method definition\n   */\n  private parseMethodDeclaration(\n    node: ts.MethodDeclaration,\n    sourceFile: ts.SourceFile,\n  ): MethodDefinition | null {\n    const methodName = this.getPropertyName(node);\n    if (!methodName) return null;\n\n    // Check visibility modifiers\n    const isStatic =\n      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.StaticKeyword) ??\n      false;\n    const isPrivate =\n      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.PrivateKeyword) ??\n      false;\n    const isPublic = !isPrivate;\n\n    // Skip based on options\n    if (!this.options.includeStaticMethods && isStatic) return null;\n    if (!this.options.includePrivateMethods && isPrivate) return null;\n\n    // Parse parameters\n    const parameters = node.parameters.map((param) => ({\n      name: param.name.getText(sourceFile),\n      type: param.type?.getText(sourceFile) ?? 'any',\n      optional: !!param.questionToken,\n      default: param.initializer\n        ? this.extractDefaultValue(param.initializer)\n        : undefined,\n    }));\n\n    const method: MethodDefinition = {\n      name: methodName,\n      async:\n        node.modifiers?.some((m) => m.kind === ts.SyntaxKind.AsyncKeyword) ??\n        false,\n      parameters,\n      returnType: node.type?.getText(sourceFile) ?? 'void',\n      isStatic,\n      isPublic,\n    };\n\n    return method;\n  }\n\n  /**\n   * Get property/method name as string\n   */\n  private getPropertyName(\n    node: ts.PropertyDeclaration | ts.MethodDeclaration,\n  ): string | null {\n    if (ts.isIdentifier(node.name)) {\n      return node.name.text;\n    }\n    if (ts.isStringLiteral(node.name)) {\n      return node.name.text;\n    }\n    return null;\n  }\n\n  /**\n   * Infer field type from TypeScript AST with enhanced type preservation\n   */\n  private inferFieldType(\n    node: ts.PropertyDeclaration,\n    sourceFile: ts.SourceFile,\n  ): FieldDefinition['type'] {\n    // Check type annotation first with enhanced detection\n    if (node.type) {\n      return this.analyzeTypeNode(node.type, sourceFile);\n    }\n\n    // Infer from initializer with enhanced detection\n    if (node.initializer) {\n      return this.inferTypeFromInitializer(node.initializer);\n    }\n\n    return 'text'; // Default fallback\n  }\n\n  /**\n   * Analyze TypeScript type node for enhanced type inference\n   */\n  private analyzeTypeNode(\n    typeNode: ts.TypeNode,\n    sourceFile: ts.SourceFile,\n  ): FieldDefinition['type'] {\n    const typeText = typeNode.getText(sourceFile).toLowerCase();\n\n    // Handle primitive types\n    if (typeText === 'string') return 'text';\n    if (typeText === 'number') return 'decimal';\n    if (typeText === 'boolean') return 'boolean';\n    if (typeText === 'date') return 'datetime';\n\n    // Handle union types with null/undefined\n    if (ts.isUnionTypeNode(typeNode)) {\n      // Find the main type (non-null/undefined)\n      const mainType = typeNode.types.find(\n        (t) =>\n          t.kind !== ts.SyntaxKind.UndefinedKeyword &&\n          t.kind !== ts.SyntaxKind.NullKeyword,\n      );\n      if (mainType) {\n        return this.analyzeTypeNode(mainType, sourceFile);\n      }\n    }\n\n    // Handle array types\n    if (ts.isArrayTypeNode(typeNode)) {\n      return 'json'; // Arrays stored as JSON\n    }\n\n    // Handle Record/object types\n    if (ts.isTypeLiteralNode(typeNode) || typeText.startsWith('record<')) {\n      return 'json';\n    }\n\n    // Handle specific type references\n    if (ts.isTypeReferenceNode(typeNode)) {\n      const typeName = typeNode.typeName.getText().toLowerCase();\n\n      // Built-in types\n      if (typeName === 'date') return 'datetime';\n      if (typeName === 'array') return 'json';\n      if (typeName === 'record') return 'json';\n      if (typeName === 'object') return 'json';\n\n      // String literal types become text\n      if (typeName.includes('string')) return 'text';\n      if (typeName.includes('number')) return 'decimal';\n      if (typeName.includes('boolean')) return 'boolean';\n    }\n\n    // Handle string literal types and template literals\n    if (ts.isLiteralTypeNode(typeNode)) {\n      if (ts.isStringLiteral(typeNode.literal)) {\n        return 'text';\n      }\n      if (ts.isNumericLiteral(typeNode.literal)) {\n        return 'decimal';\n      }\n    }\n\n    // Complex type patterns\n    if (typeText.includes('[]') || typeText.includes('array')) return 'json';\n    if (typeText.includes('record<') || typeText.includes('object'))\n      return 'json';\n    if (typeText.includes('string')) return 'text';\n    if (typeText.includes('number') || typeText.includes('decimal'))\n      return 'decimal';\n    if (typeText.includes('boolean')) return 'boolean';\n    if (typeText.includes('date')) return 'datetime';\n\n    // Default for complex types\n    return 'json';\n  }\n\n  /**\n   * Infer type from initializer expression\n   */\n  private inferTypeFromInitializer(\n    initializer: ts.Expression,\n  ): FieldDefinition['type'] {\n    if (ts.isStringLiteral(initializer)) return 'text';\n    if (ts.isNumericLiteral(initializer)) return 'decimal';\n    if (\n      initializer.kind === ts.SyntaxKind.TrueKeyword ||\n      initializer.kind === ts.SyntaxKind.FalseKeyword\n    ) {\n      return 'boolean';\n    }\n    if (ts.isArrayLiteralExpression(initializer)) return 'json';\n    if (ts.isObjectLiteralExpression(initializer)) return 'json';\n    if (ts.isNewExpression(initializer)) {\n      const expression = initializer.expression;\n      if (ts.isIdentifier(expression)) {\n        const typeName = expression.text.toLowerCase();\n        if (typeName === 'date') return 'datetime';\n        if (typeName === 'array') return 'json';\n      }\n    }\n\n    return 'text'; // Default fallback\n  }\n\n  /**\n   * Extract default value from initializer\n   */\n  private extractDefaultValue(node: ts.Expression): any {\n    if (ts.isStringLiteral(node)) return node.text;\n    if (ts.isNumericLiteral(node)) return Number(node.text);\n    if (node.kind === ts.SyntaxKind.TrueKeyword) return true;\n    if (node.kind === ts.SyntaxKind.FalseKeyword) return false;\n    if (node.kind === ts.SyntaxKind.NullKeyword) return null;\n    if (ts.isArrayLiteralExpression(node)) return [];\n    if (ts.isObjectLiteralExpression(node)) return {};\n\n    return undefined;\n  }\n\n  /**\n   * Check if type annotation includes undefined or optional types\n   */\n  private hasOptionalType(\n    node: ts.PropertyDeclaration,\n    sourceFile: ts.SourceFile,\n  ): boolean {\n    if (!node.type) return false;\n\n    const typeText = node.type.getText(sourceFile).toLowerCase();\n    return typeText.includes('undefined') || typeText.includes('?');\n  }\n\n  /**\n   * Simple pluralization (can be enhanced)\n   */\n  private pluralize(word: string): string {\n    if (word.endsWith('y')) {\n      return `${word.slice(0, -1)}ies`;\n    }\n    if (word.endsWith('s') || word.endsWith('sh') || word.endsWith('ch')) {\n      return `${word}es`;\n    }\n    return `${word}s`;\n  }\n}\n\n/**\n * Convenience function to scan files\n */\nexport function scanFiles(\n  filePaths: string[],\n  options?: ScanOptions,\n): ScanResult[] {\n  const scanner = new ASTScanner(filePaths, options);\n  return scanner.scanFiles();\n}\n\n/**\n * Scan a single file\n */\nexport function scanFile(filePath: string, options?: ScanOptions): ScanResult {\n  const scanner = new ASTScanner([filePath], options);\n  const results = scanner.scanFiles();\n  return results[0] || { filePath, objects: [], errors: [] };\n}\n"],"names":[],"mappings":"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"}