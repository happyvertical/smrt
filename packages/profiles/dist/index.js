var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _ProfileType_decorators, _init, _a, _Profile_decorators, _init2, _b, _ProfileMetadata_decorators, _init3, _c, _ProfileMetafield_decorators, _init4, _d, _ProfileRelationship_decorators, _init5, _e, _ProfileRelationshipTerm_decorators, _init6, _f, _ProfileRelationshipType_decorators, _init7, _g;
import { SmrtObject, text, smrt, foreignKey, oneToMany, SmrtCollection, json, datetime, boolean } from "@smrt/core";
_ProfileType_decorators = [smrt({
  api: { include: ["list", "get", "create", "update"] },
  mcp: { include: ["list", "get"] },
  cli: true
})];
class ProfileType extends (_a = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  // slug is inherited from SmrtObject (auto-generated from name)
  name = text({ required: true });
  description = text();
  constructor(options = {}) {
    super(options);
  }
  /**
   * Convenience method for slug-based lookup
   *
   * @param slug - The slug to search for
   * @returns ProfileType instance or null if not found
   */
  static async getBySlug(_slug) {
    return null;
  }
}
_init = __decoratorStart(_a);
ProfileType = __decorateElement(_init, 0, "ProfileType", _ProfileType_decorators, ProfileType);
__runInitializers(_init, 1, ProfileType);
_Profile_decorators = [smrt({
  api: { include: ["list", "get", "create", "update", "delete"] },
  mcp: { include: ["list", "get", "create", "update"] },
  cli: true
})];
class Profile extends (_b = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  typeId = foreignKey("ProfileType", { required: true });
  // References ProfileType.id
  email = text({ unique: true });
  // Optional email address
  name = text({ required: true });
  // Display name
  description = text();
  // Short bio or description
  // Relationships (not stored as columns)
  metadata = oneToMany("ProfileMetadata");
  relationshipsFrom = oneToMany("ProfileRelationship");
  relationshipsTo = oneToMany("ProfileRelationship");
  constructor(options = {}) {
    super(options);
  }
  /**
   * Get the profile type slug for this profile
   *
   * @returns The slug of the profile type
   */
  async getTypeSlug() {
    const type = await this.loadRelated("typeId");
    return type?.slug || "";
  }
  /**
   * Set the profile type by slug
   *
   * @param slug - The slug of the profile type
   * @throws Error if profile type not found
   */
  async setTypeBySlug(slug) {
    const type = await ProfileType.getBySlug(slug);
    if (!type) throw new Error(`Profile type '${slug}' not found`);
    this.typeId.value = type.id;
  }
  /**
   * Add metadata to this profile
   *
   * @param metafieldSlug - The slug of the metafield
   * @param value - The value to set
   */
  async addMetadata(metafieldSlug, value) {
    const { ProfileMetafieldCollection: ProfileMetafieldCollection2 } = await Promise.resolve().then(() => ProfileMetafieldCollection$1);
    const { ProfileMetadataCollection: ProfileMetadataCollection2 } = await Promise.resolve().then(() => ProfileMetadataCollection$1);
    const metafieldCollection = await ProfileMetafieldCollection2.create(
      this.options
    );
    const metafield = await metafieldCollection.getBySlug(metafieldSlug);
    if (!metafield) {
      throw new Error(`Metafield '${metafieldSlug}' not found`);
    }
    await metafield.validateValue(value);
    const metadataCollection = await ProfileMetadataCollection2.create(
      this.options
    );
    const existing = await metadataCollection.list({
      where: { profileId: this.id, metafieldId: metafield.id },
      limit: 1
    });
    if (existing.length > 0) {
      const metadata = existing[0];
      metadata.value = String(value);
      await metadata.save();
    } else {
      const metadata = await metadataCollection.create({
        profileId: this.id,
        metafieldId: metafield.id,
        value: String(value)
      });
      await metadata.save();
    }
  }
  /**
   * Get all metadata for this profile as key-value object
   *
   * @returns Object with metafield slugs as keys
   */
  async getMetadata() {
    const { ProfileMetadataCollection: ProfileMetadataCollection2 } = await Promise.resolve().then(() => ProfileMetadataCollection$1);
    const metadataCollection = await ProfileMetadataCollection2.create(
      this.options
    );
    return await metadataCollection.getMetadataObject(this.id);
  }
  /**
   * Update multiple metadata values
   *
   * @param metadata - Object with metafield slugs as keys and values
   */
  async updateMetadata(metadata) {
    for (const [metafieldSlug, value] of Object.entries(metadata)) {
      await this.addMetadata(metafieldSlug, value);
    }
  }
  /**
   * Remove metadata by metafield slug
   *
   * @param metafieldSlug - The slug of the metafield to remove
   */
  async removeMetadata(metafieldSlug) {
    const { ProfileMetafieldCollection: ProfileMetafieldCollection2 } = await Promise.resolve().then(() => ProfileMetafieldCollection$1);
    const { ProfileMetadataCollection: ProfileMetadataCollection2 } = await Promise.resolve().then(() => ProfileMetadataCollection$1);
    const metafieldCollection = await ProfileMetafieldCollection2.create(
      this.options
    );
    const metafield = await metafieldCollection.getBySlug(metafieldSlug);
    if (!metafield) {
      throw new Error(`Metafield '${metafieldSlug}' not found`);
    }
    const metadataCollection = await ProfileMetadataCollection2.create(
      this.options
    );
    const existing = await metadataCollection.list({
      where: { profileId: this.id, metafieldId: metafield.id },
      limit: 1
    });
    if (existing.length > 0) {
      await existing[0].delete();
    }
  }
  /**
   * Add a relationship to another profile
   *
   * @param toProfile - The target profile
   * @param relationshipSlug - The type of relationship
   * @param contextProfile - Optional context profile for tertiary relationships
   */
  async addRelationship(toProfile, relationshipSlug, contextProfile) {
    const { ProfileRelationshipTypeCollection: ProfileRelationshipTypeCollection2 } = await Promise.resolve().then(() => ProfileRelationshipTypeCollection$1);
    const { ProfileRelationshipCollection: ProfileRelationshipCollection2 } = await Promise.resolve().then(() => ProfileRelationshipCollection$1);
    const { ProfileRelationshipType: ProfileRelationshipType2 } = await Promise.resolve().then(() => ProfileRelationshipType$1);
    const relationshipTypeCollection = await ProfileRelationshipTypeCollection2.create(this.options);
    const relationshipType = await relationshipTypeCollection.getBySlug(relationshipSlug);
    if (!relationshipType) {
      throw new Error(`Relationship type '${relationshipSlug}' not found`);
    }
    const relationshipCollection = await ProfileRelationshipCollection2.create(
      this.options
    );
    const exists = await relationshipCollection.exists(
      this.id,
      toProfile.id,
      relationshipType.id
    );
    if (!exists) {
      const relationship = await relationshipCollection.create({
        fromProfileId: this.id,
        toProfileId: toProfile.id,
        typeId: relationshipType.id,
        contextProfileId: contextProfile?.id
      });
      await relationship.save();
    }
    if (relationshipType.reciprocal) {
      const handler = ProfileRelationshipType2.getReciprocalHandler(relationshipSlug);
      if (handler) {
        await handler(this, toProfile, contextProfile);
      }
    }
  }
  /**
   * Get all relationships for this profile
   *
   * @param options - Filter options (typeSlug, direction)
   * @returns Array of ProfileRelationship instances
   */
  async getRelationships(options) {
    const { ProfileRelationshipCollection: ProfileRelationshipCollection2 } = await Promise.resolve().then(() => ProfileRelationshipCollection$1);
    const { ProfileRelationshipTypeCollection: ProfileRelationshipTypeCollection2 } = await Promise.resolve().then(() => ProfileRelationshipTypeCollection$1);
    const relationshipCollection = await ProfileRelationshipCollection2.create(
      this.options
    );
    const direction = options?.direction || "all";
    let typeId;
    if (options?.typeSlug) {
      const relationshipTypeCollection = await ProfileRelationshipTypeCollection2.create(this.options);
      const relationshipType = await relationshipTypeCollection.getBySlug(
        options.typeSlug
      );
      typeId = relationshipType?.id;
    }
    if (direction === "from") {
      return await relationshipCollection.getFromProfile(this.id, typeId);
    } else if (direction === "to") {
      return await relationshipCollection.getToProfile(this.id, typeId);
    } else {
      return await relationshipCollection.getForProfile(this.id, typeId);
    }
  }
  /**
   * Get related profiles
   *
   * @param relationshipSlug - Optional filter by relationship type slug
   * @returns Array of related Profile instances
   */
  async getRelatedProfiles(relationshipSlug) {
    const { ProfileCollection: ProfileCollection2 } = await Promise.resolve().then(() => ProfileCollection$1);
    const relationships = await this.getRelationships({
      typeSlug: relationshipSlug,
      direction: "all"
    });
    const profileCollection = await ProfileCollection2.create(this.options);
    const relatedProfiles = [];
    const seenIds = /* @__PURE__ */ new Set();
    for (const relationship of relationships) {
      const fromId = String(relationship.fromProfileId);
      const toId = String(relationship.toProfileId);
      const thisId = String(this.id);
      const otherId = fromId === thisId ? toId : fromId;
      if (!seenIds.has(otherId)) {
        seenIds.add(otherId);
        const profile = await profileCollection.get({ id: otherId });
        if (profile) {
          relatedProfiles.push(profile);
        }
      }
    }
    return relatedProfiles;
  }
  /**
   * Remove a relationship to another profile
   *
   * @param toProfile - The target profile
   * @param relationshipSlug - The type of relationship to remove
   */
  async removeRelationship(toProfile, relationshipSlug) {
    const { ProfileRelationshipTypeCollection: ProfileRelationshipTypeCollection2 } = await Promise.resolve().then(() => ProfileRelationshipTypeCollection$1);
    const { ProfileRelationshipCollection: ProfileRelationshipCollection2 } = await Promise.resolve().then(() => ProfileRelationshipCollection$1);
    const relationshipTypeCollection = await ProfileRelationshipTypeCollection2.create(this.options);
    const relationshipType = await relationshipTypeCollection.getBySlug(relationshipSlug);
    if (!relationshipType) {
      throw new Error(`Relationship type '${relationshipSlug}' not found`);
    }
    const relationshipCollection = await ProfileRelationshipCollection2.create(
      this.options
    );
    const relationships = await relationshipCollection.list({
      where: {
        fromProfileId: this.id,
        toProfileId: toProfile.id,
        typeId: relationshipType.id
      }
    });
    for (const relationship of relationships) {
      await relationship.delete();
    }
    if (relationshipType.reciprocal) {
      const inverseRelationships = await relationshipCollection.list({
        where: {
          fromProfileId: toProfile.id,
          toProfileId: this.id,
          typeId: relationshipType.id
        }
      });
      for (const relationship of inverseRelationships) {
        await relationship.delete();
      }
    }
  }
  /**
   * AI-powered: Generate a professional bio for this profile
   *
   * @returns Generated bio text
   */
  async generateBio() {
    return await this.do("Write a short, professional bio for this person.");
  }
  /**
   * AI-powered: Check if profile matches criteria
   *
   * @param criteria - Criteria to match against
   * @returns True if matches criteria
   */
  async matches(criteria) {
    return await this.is(criteria);
  }
  /**
   * Find profiles by metadata key-value pair
   *
   * @param metafieldSlug - The metafield slug to search
   * @param value - The value to match
   * @returns Array of matching profiles
   */
  static async findByMetadata(_metafieldSlug, _value) {
    return [];
  }
  /**
   * Find profiles by type slug
   *
   * @param typeSlug - The profile type slug
   * @returns Array of matching profiles
   */
  static async findByType(_typeSlug) {
    return [];
  }
  /**
   * Find related profiles for a given profile
   *
   * @param profileId - The profile UUID
   * @param relationshipSlug - Optional filter by relationship type
   * @returns Array of related profiles
   */
  static async findRelated(_profileId, _relationshipSlug) {
    return [];
  }
  /**
   * Search profiles by email
   *
   * @param email - The email to search for
   * @returns Profile or null if not found
   */
  static async searchByEmail(_email) {
    return null;
  }
}
_init2 = __decoratorStart(_b);
Profile = __decorateElement(_init2, 0, "Profile", _Profile_decorators, Profile);
__runInitializers(_init2, 1, Profile);
class ProfileCollection extends SmrtCollection {
  static _itemClass = Profile;
  /**
   * Find profiles by type slug
   *
   * @param typeSlug - The profile type slug to filter by
   * @returns Array of matching profiles
   */
  async findByType(typeSlug) {
    const allProfiles = await this.list({});
    const filtered = [];
    for (const profile of allProfiles) {
      const slug = await profile.getTypeSlug();
      if (slug === typeSlug) {
        filtered.push(profile);
      }
    }
    return filtered;
  }
  /**
   * Batch get metadata for multiple profiles
   *
   * @param profileIds - Array of profile UUIDs
   * @returns Map of profile ID to metadata object
   */
  async batchGetMetadata(profileIds) {
    const result = /* @__PURE__ */ new Map();
    for (const profileId of profileIds) {
      const profile = await this.get({ id: profileId });
      if (profile) {
        const metadata = await profile.getMetadata();
        result.set(profileId, metadata);
      }
    }
    return result;
  }
  /**
   * Batch update metadata for multiple profiles
   *
   * @param updates - Array of { profileId, data } objects
   */
  async batchUpdateMetadata(updates) {
    for (const update of updates) {
      const profile = await this.get({ id: update.profileId });
      if (profile) {
        await profile.updateMetadata(update.data);
      }
    }
  }
  /**
   * Find related profiles for a given profile
   *
   * @param profileId - The profile UUID
   * @param relationshipSlug - Optional filter by relationship type
   * @returns Array of related profiles
   */
  async findRelated(profileId, relationshipSlug) {
    const profile = await this.get({ id: profileId });
    if (!profile) return [];
    return await profile.getRelatedProfiles(relationshipSlug);
  }
  /**
   * Get the relationship network for a profile up to a maximum depth
   *
   * @param profileId - The starting profile UUID
   * @param options - Configuration options
   * @returns Map of profile ID to depth level
   */
  async getRelationshipNetwork(profileId, options = {}) {
    const maxDepth = options.maxDepth || 2;
    const network = /* @__PURE__ */ new Map();
    const visited = /* @__PURE__ */ new Set();
    const queue = [
      { id: profileId, depth: 0 }
    ];
    while (queue.length > 0) {
      const current = queue.shift();
      if (visited.has(current.id) || current.depth > maxDepth) {
        continue;
      }
      visited.add(current.id);
      network.set(current.id, current.depth);
      if (current.depth < maxDepth) {
        const related = await this.findRelated(current.id);
        for (const profile of related) {
          if (!visited.has(profile.id)) {
            queue.push({ id: profile.id, depth: current.depth + 1 });
          }
        }
      }
    }
    return network;
  }
}
const ProfileCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProfileCollection
}, Symbol.toStringTag, { value: "Module" }));
_ProfileMetadata_decorators = [smrt({
  api: { include: ["list", "get", "create", "update", "delete"] },
  mcp: { include: ["list", "get"] },
  cli: true
})];
class ProfileMetadata extends (_c = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  profileId = foreignKey("Profile", { required: true });
  // References Profile.id
  metafieldId = foreignKey("ProfileMetafield", { required: true });
  // References ProfileMetafield.id
  value = text({ required: true });
  // The metadata value (stored as text)
  constructor(options = {}) {
    super(options);
  }
  /**
   * Validate this metadata value against the metafield's validation schema
   *
   * @returns True if valid, throws error if invalid
   */
  async validate() {
    const metafield = await this.loadRelated("metafieldId");
    if (!metafield) {
      throw new Error("Metafield not found");
    }
    return await metafield.validateValue(this.value);
  }
  /**
   * Get the metafield slug for this metadata
   *
   * @returns The slug of the metafield
   */
  async getMetafieldSlug() {
    const metafield = await this.loadRelated("metafieldId");
    return metafield?.slug || "";
  }
}
_init3 = __decoratorStart(_c);
ProfileMetadata = __decorateElement(_init3, 0, "ProfileMetadata", _ProfileMetadata_decorators, ProfileMetadata);
__runInitializers(_init3, 1, ProfileMetadata);
class ProfileMetadataCollection extends SmrtCollection {
  static _itemClass = ProfileMetadata;
  /**
   * Get all metadata for a profile
   *
   * @param profileId - The profile UUID
   * @returns Array of ProfileMetadata instances
   */
  async getByProfile(profileId) {
    return await this.list({ where: { profileId } });
  }
  /**
   * Get metadata as key-value object for a profile
   *
   * @param profileId - The profile UUID
   * @returns Object with metafield slugs as keys
   */
  async getMetadataObject(profileId) {
    const metadata = await this.getByProfile(profileId);
    const result = {};
    for (const item of metadata) {
      const slug = await item.getMetafieldSlug();
      if (slug) {
        result[slug] = item.value;
      }
    }
    return result;
  }
  /**
   * Find all profiles with a specific metadata key-value pair
   *
   * @param metafieldId - The metafield UUID
   * @param value - The value to match
   * @returns Array of profile UUIDs
   */
  async findProfilesByMetadata(metafieldId, value) {
    const matches = await this.list({
      where: { metafieldId, value: String(value) }
    });
    return matches.map((m) => m.profileId);
  }
}
const ProfileMetadataCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProfileMetadataCollection
}, Symbol.toStringTag, { value: "Module" }));
const customValidators = /* @__PURE__ */ new Map();
_ProfileMetafield_decorators = [smrt({
  api: { include: ["list", "get", "create", "update"] },
  mcp: { include: ["list", "get"] },
  cli: true
})];
let _ProfileMetafield = class _ProfileMetafield extends (_d = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  // slug is inherited from SmrtObject (auto-generated from name)
  name = text({ required: true });
  description = text();
  validation = json();
  // Validation schema as JSON
  constructor(options = {}) {
    super(options);
  }
  /**
   * Convenience method for slug-based lookup
   *
   * @param slug - The slug to search for
   * @returns ProfileMetafield instance or null if not found
   */
  static async getBySlug(_slug) {
    return null;
  }
  /**
   * Register a custom validator function
   *
   * @param name - Name of the validator (used in validation.custom field)
   * @param validator - The validator function
   */
  static registerValidator(name, validator) {
    customValidators.set(name, validator);
  }
  /**
   * Get a registered custom validator
   *
   * @param name - Name of the validator
   * @returns The validator function or undefined
   */
  static getValidator(name) {
    return customValidators.get(name);
  }
  /**
   * Validate a value against this metafield's validation schema
   *
   * @param value - The value to validate
   * @returns True if valid, throws ValidationError if invalid
   */
  async validateValue(value) {
    if (!this.validation) return true;
    const schema = this.validation;
    if (schema.type) {
      const actualType = typeof value;
      const expectedType = schema.type;
      if (expectedType === "number" && actualType !== "number") {
        throw new Error(
          schema.message || `Expected ${expectedType}, got ${actualType}`
        );
      }
      if (expectedType === "string" && actualType !== "string") {
        throw new Error(
          schema.message || `Expected ${expectedType}, got ${actualType}`
        );
      }
      if (expectedType === "boolean" && actualType !== "boolean") {
        throw new Error(
          schema.message || `Expected ${expectedType}, got ${actualType}`
        );
      }
    }
    if (schema.pattern && typeof value === "string") {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        throw new Error(schema.message || "Pattern validation failed");
      }
    }
    if (schema.minLength && typeof value === "string") {
      if (value.length < schema.minLength) {
        throw new Error(
          schema.message || `Minimum length is ${schema.minLength}, got ${value.length}`
        );
      }
    }
    if (schema.maxLength && typeof value === "string") {
      if (value.length > schema.maxLength) {
        throw new Error(
          schema.message || `Maximum length is ${schema.maxLength}, got ${value.length}`
        );
      }
    }
    if (schema.min !== void 0 && typeof value === "number") {
      if (value < schema.min) {
        throw new Error(
          schema.message || `Value must be at least ${schema.min}`
        );
      }
    }
    if (schema.max !== void 0 && typeof value === "number") {
      if (value > schema.max) {
        throw new Error(
          schema.message || `Value must be at most ${schema.max}`
        );
      }
    }
    if (schema.custom) {
      const validator = _ProfileMetafield.getValidator(schema.custom);
      if (!validator) {
        throw new Error(`Custom validator '${schema.custom}' not registered`);
      }
      const result = await validator(value);
      if (!result) {
        throw new Error(schema.message || "Custom validation failed");
      }
    }
    return true;
  }
};
_init4 = __decoratorStart(_d);
_ProfileMetafield = __decorateElement(_init4, 0, "ProfileMetafield", _ProfileMetafield_decorators, _ProfileMetafield);
__runInitializers(_init4, 1, _ProfileMetafield);
let ProfileMetafield = _ProfileMetafield;
class ProfileMetafieldCollection extends SmrtCollection {
  static _itemClass = ProfileMetafield;
  /**
   * Get metafield by slug
   *
   * @param slug - The slug to search for
   * @returns ProfileMetafield instance or null
   */
  async getBySlug(slug) {
    return await this.get({ slug });
  }
  /**
   * Get or create a metafield by slug
   *
   * @param slug - The slug to search for
   * @param defaults - Default values if creating
   * @returns ProfileMetafield instance
   */
  async getOrCreateBySlug(slug, defaults) {
    const existing = await this.getBySlug(slug);
    if (existing) return existing;
    const metafield = await this.create({ slug, ...defaults });
    await metafield.save();
    return metafield;
  }
}
const ProfileMetafieldCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProfileMetafieldCollection
}, Symbol.toStringTag, { value: "Module" }));
_ProfileRelationship_decorators = [smrt({
  api: { include: ["list", "get", "create", "delete"] },
  mcp: { include: ["list", "get"] },
  cli: true
})];
class ProfileRelationship extends (_e = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  fromProfileId = foreignKey("Profile", { required: true });
  // Origin profile
  toProfileId = foreignKey("Profile", { required: true });
  // Target profile
  typeId = foreignKey("ProfileRelationshipType", { required: true });
  // Relationship type
  contextProfileId = foreignKey("Profile");
  // Optional tertiary context
  // Relationships
  terms = oneToMany("ProfileRelationshipTerm");
  constructor(options = {}) {
    super(options);
  }
  /**
   * Get the relationship type slug
   *
   * @returns The slug of the relationship type
   */
  async getTypeSlug() {
    const type = await this.loadRelated("typeId");
    return type?.slug || "";
  }
  /**
   * Add a term (time period) to this relationship
   *
   * @param startedAt - Start date of the term
   * @param endedAt - Optional end date of the term
   */
  async addTerm(startedAt, endedAt) {
    const { ProfileRelationshipTermCollection: ProfileRelationshipTermCollection2 } = await Promise.resolve().then(() => ProfileRelationshipTermCollection$1);
    const termCollection = await ProfileRelationshipTermCollection2.create(
      this.options
    );
    const term = await termCollection.create({
      relationshipId: this.id,
      startedAt,
      endedAt
    });
    await term.save();
  }
  /**
   * End the current active term
   *
   * @param endedAt - End date for the term
   */
  async endCurrentTerm(endedAt) {
    const activeTerm = await this.getActiveTerm();
    if (activeTerm) {
      await activeTerm.end(endedAt);
    }
  }
  /**
   * Get all terms for this relationship
   *
   * @returns Array of ProfileRelationshipTerm instances
   */
  async getTerms() {
    const { ProfileRelationshipTermCollection: ProfileRelationshipTermCollection2 } = await Promise.resolve().then(() => ProfileRelationshipTermCollection$1);
    const termCollection = await ProfileRelationshipTermCollection2.create(
      this.options
    );
    return await termCollection.getByRelationship(this.id);
  }
  /**
   * Get the active term (no end date)
   *
   * @returns Current term or null if none active
   */
  async getActiveTerm() {
    const { ProfileRelationshipTermCollection: ProfileRelationshipTermCollection2 } = await Promise.resolve().then(() => ProfileRelationshipTermCollection$1);
    const termCollection = await ProfileRelationshipTermCollection2.create(
      this.options
    );
    return await termCollection.getActiveTerm(this.id);
  }
}
_init5 = __decoratorStart(_e);
ProfileRelationship = __decorateElement(_init5, 0, "ProfileRelationship", _ProfileRelationship_decorators, ProfileRelationship);
__runInitializers(_init5, 1, ProfileRelationship);
class ProfileRelationshipCollection extends SmrtCollection {
  static _itemClass = ProfileRelationship;
  /**
   * Get all relationships from a profile
   *
   * @param fromProfileId - The origin profile UUID
   * @param typeId - Optional filter by relationship type UUID
   * @returns Array of ProfileRelationship instances
   */
  async getFromProfile(fromProfileId, typeId) {
    const where = { fromProfileId };
    if (typeId) where.typeId = typeId;
    return await this.list({ where });
  }
  /**
   * Get all relationships to a profile
   *
   * @param toProfileId - The target profile UUID
   * @param typeId - Optional filter by relationship type UUID
   * @returns Array of ProfileRelationship instances
   */
  async getToProfile(toProfileId, typeId) {
    const where = { toProfileId };
    if (typeId) where.typeId = typeId;
    return await this.list({ where });
  }
  /**
   * Get all relationships for a profile (both directions)
   *
   * @param profileId - The profile UUID
   * @param typeId - Optional filter by relationship type UUID
   * @returns Array of ProfileRelationship instances
   */
  async getForProfile(profileId, typeId) {
    const fromRelationships = await this.getFromProfile(profileId, typeId);
    const toRelationships = await this.getToProfile(profileId, typeId);
    return [...fromRelationships, ...toRelationships];
  }
  /**
   * Check if a relationship exists between two profiles
   *
   * @param fromProfileId - The origin profile UUID
   * @param toProfileId - The target profile UUID
   * @param typeId - The relationship type UUID
   * @returns True if relationship exists
   */
  async exists(fromProfileId, toProfileId, typeId) {
    const matches = await this.list({
      where: { fromProfileId, toProfileId, typeId },
      limit: 1
    });
    return matches.length > 0;
  }
}
const ProfileRelationshipCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProfileRelationshipCollection
}, Symbol.toStringTag, { value: "Module" }));
_ProfileRelationshipTerm_decorators = [smrt({
  api: { include: ["list", "get", "create", "update", "delete"] },
  mcp: { include: ["list", "get"] },
  cli: true
})];
class ProfileRelationshipTerm extends (_f = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  relationshipId = foreignKey("ProfileRelationship", { required: true });
  // References ProfileRelationship.id
  startedAt = datetime({ required: true });
  // Start date of the term
  endedAt = datetime();
  // Optional end date
  constructor(options = {}) {
    super(options);
  }
  /**
   * Check if this term is currently active
   *
   * @returns True if active (no end date or end date in future)
   */
  isActive() {
    if (!this.endedAt) return true;
    const endDate = this.endedAt instanceof Date ? this.endedAt : new Date(String(this.endedAt));
    return endDate > /* @__PURE__ */ new Date();
  }
  /**
   * End this term
   *
   * @param endedAt - End date for the term (defaults to now)
   */
  async end(endedAt = /* @__PURE__ */ new Date()) {
    this.endedAt.value = endedAt;
    await this.save();
  }
  /**
   * Get the duration of this term in days
   *
   * @returns Duration in days
   */
  getDurationDays() {
    const endValue = this.endedAt ? this.endedAt instanceof Date ? this.endedAt : new Date(String(this.endedAt)) : /* @__PURE__ */ new Date();
    const startValue = this.startedAt instanceof Date ? this.startedAt : new Date(String(this.startedAt));
    const diffMs = endValue.getTime() - startValue.getTime();
    return Math.floor(diffMs / (1e3 * 60 * 60 * 24));
  }
}
_init6 = __decoratorStart(_f);
ProfileRelationshipTerm = __decorateElement(_init6, 0, "ProfileRelationshipTerm", _ProfileRelationshipTerm_decorators, ProfileRelationshipTerm);
__runInitializers(_init6, 1, ProfileRelationshipTerm);
class ProfileRelationshipTermCollection extends SmrtCollection {
  static _itemClass = ProfileRelationshipTerm;
  /**
   * Get all terms for a relationship
   *
   * @param relationshipId - The relationship UUID
   * @returns Array of ProfileRelationshipTerm instances
   */
  async getByRelationship(relationshipId) {
    return await this.list({
      where: { relationshipId },
      orderBy: ["startedAt DESC"]
    });
  }
  /**
   * Get the active term for a relationship (no end date or future end date)
   *
   * @param relationshipId - The relationship UUID
   * @returns Active term or null
   */
  async getActiveTerm(relationshipId) {
    const terms = await this.getByRelationship(relationshipId);
    for (const term of terms) {
      if (term.isActive()) {
        return term;
      }
    }
    return null;
  }
  /**
   * Get all historical (ended) terms for a relationship
   *
   * @param relationshipId - The relationship UUID
   * @returns Array of ended ProfileRelationshipTerm instances
   */
  async getHistoricalTerms(relationshipId) {
    const terms = await this.getByRelationship(relationshipId);
    return terms.filter((term) => !term.isActive());
  }
}
const ProfileRelationshipTermCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProfileRelationshipTermCollection
}, Symbol.toStringTag, { value: "Module" }));
const reciprocalHandlers = /* @__PURE__ */ new Map();
const DEFAULT_HANDLERS = {
  // Symmetric relationships (same type in both directions)
  friend: async (from, to, context) => {
    await to.addRelationship(from, "friend", context);
  },
  spouse: async (from, to) => {
    await to.addRelationship(from, "spouse");
  },
  partner: async (from, to, context) => {
    await to.addRelationship(from, "partner", context);
  },
  colleague: async (from, to, context) => {
    await to.addRelationship(from, "colleague", context);
  },
  sibling: async (from, to) => {
    await to.addRelationship(from, "sibling");
  }
};
for (const [slug, handler] of Object.entries(DEFAULT_HANDLERS)) {
  reciprocalHandlers.set(slug, handler);
}
_ProfileRelationshipType_decorators = [smrt({
  api: { include: ["list", "get", "create", "update"] },
  mcp: { include: ["list", "get"] },
  cli: true
})];
let _ProfileRelationshipType = class _ProfileRelationshipType extends (_g = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  // slug is inherited from SmrtObject (auto-generated from name)
  name = text({ required: true });
  reciprocal = boolean({ default: true });
  // True for two-way relationships
  constructor(options = {}) {
    super(options);
  }
  /**
   * Convenience method for slug-based lookup
   *
   * @param slug - The slug to search for
   * @returns ProfileRelationshipType instance or null if not found
   */
  static async getBySlug(_slug) {
    return null;
  }
  /**
   * Register a custom reciprocal handler for a relationship type
   *
   * @param slug - The relationship type slug
   * @param handler - The handler function to execute when creating reciprocal relationship
   */
  static registerReciprocalHandler(slug, handler) {
    reciprocalHandlers.set(slug, handler);
  }
  /**
   * Get the reciprocal handler for a relationship type
   *
   * @param slug - The relationship type slug
   * @returns The handler function or undefined
   */
  static getReciprocalHandler(slug) {
    return reciprocalHandlers.get(slug);
  }
  /**
   * Check if a relationship type is reciprocal
   *
   * @param slug - The relationship type slug
   * @returns True if reciprocal, false otherwise
   */
  static async isReciprocal(slug) {
    const type = await _ProfileRelationshipType.getBySlug(slug);
    return type?.reciprocal ? Boolean(type.reciprocal) : false;
  }
};
_init7 = __decoratorStart(_g);
_ProfileRelationshipType = __decorateElement(_init7, 0, "ProfileRelationshipType", _ProfileRelationshipType_decorators, _ProfileRelationshipType);
__runInitializers(_init7, 1, _ProfileRelationshipType);
let ProfileRelationshipType = _ProfileRelationshipType;
const ProfileRelationshipType$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProfileRelationshipType
}, Symbol.toStringTag, { value: "Module" }));
class ProfileRelationshipTypeCollection extends SmrtCollection {
  static _itemClass = ProfileRelationshipType;
  /**
   * Get relationship type by slug
   *
   * @param slug - The slug to search for
   * @returns ProfileRelationshipType instance or null
   */
  async getBySlug(slug) {
    return await this.get({ slug });
  }
  /**
   * Get or create a relationship type by slug
   *
   * @param slug - The slug to search for
   * @param defaults - Default values if creating
   * @returns ProfileRelationshipType instance
   */
  async getOrCreateBySlug(slug, defaults) {
    const existing = await this.getBySlug(slug);
    if (existing) return existing;
    const relationshipType = await this.create({ slug, ...defaults });
    await relationshipType.save();
    return relationshipType;
  }
  /**
   * Get all reciprocal relationship types
   *
   * @returns Array of reciprocal ProfileRelationshipType instances
   */
  async getReciprocal() {
    return await this.list({ where: { reciprocal: true } });
  }
  /**
   * Get all directional (non-reciprocal) relationship types
   *
   * @returns Array of directional ProfileRelationshipType instances
   */
  async getDirectional() {
    return await this.list({ where: { reciprocal: false } });
  }
}
const ProfileRelationshipTypeCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ProfileRelationshipTypeCollection
}, Symbol.toStringTag, { value: "Module" }));
class ProfileTypeCollection extends SmrtCollection {
  static _itemClass = ProfileType;
  /**
   * Get profile type by slug
   *
   * @param slug - The slug to search for
   * @returns ProfileType instance or null
   */
  async getBySlug(slug) {
    return await this.get({ slug });
  }
  /**
   * Get or create a profile type by slug
   *
   * @param slug - The slug to search for
   * @param defaults - Default values if creating
   * @returns ProfileType instance
   */
  async getOrCreateBySlug(slug, defaults) {
    const existing = await this.getBySlug(slug);
    if (existing) return existing;
    const profileType = await this.create({ slug, ...defaults });
    await profileType.save();
    return profileType;
  }
}
export {
  Profile,
  ProfileCollection,
  ProfileMetadata,
  ProfileMetadataCollection,
  ProfileMetafield,
  ProfileMetafieldCollection,
  ProfileRelationship,
  ProfileRelationshipCollection,
  ProfileRelationshipTerm,
  ProfileRelationshipTermCollection,
  ProfileRelationshipType,
  ProfileRelationshipTypeCollection,
  ProfileType,
  ProfileTypeCollection
};
//# sourceMappingURL=index.js.map
