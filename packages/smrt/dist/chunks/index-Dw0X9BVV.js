import * as fs from "node:fs";
import * as path from "node:path";
async function generateDeclarations(options) {
  const {
    manifest: manifestInput,
    outDir,
    includeVirtualModules = true,
    includeObjectTypes = true,
    projectRoot = process.cwd()
  } = options;
  const manifest = typeof manifestInput === "string" ? JSON.parse(fs.readFileSync(manifestInput, "utf-8")) : manifestInput;
  const fullOutDir = path.isAbsolute(outDir) ? outDir : path.join(projectRoot, outDir);
  fs.mkdirSync(fullOutDir, { recursive: true });
  console.log(`[smrt:prebuild] Generating declarations to ${fullOutDir}`);
  if (includeObjectTypes) {
    await generateObjectTypeDeclarations(manifest, fullOutDir);
  }
  if (includeVirtualModules) {
    await generateVirtualModuleDeclarations(manifest, fullOutDir);
  }
  console.log(
    `[smrt:prebuild] Generated declarations for ${Object.keys(manifest.objects).length} SMRT objects`
  );
}
async function generateObjectTypeDeclarations(manifest, outDir) {
  const interfaces = [];
  for (const [_objectName, objectMeta] of Object.entries(manifest.objects)) {
    const fields = objectMeta.fields || {};
    const propertyLines = [];
    propertyLines.push("  id?: string;");
    propertyLines.push("  created_at?: string;");
    propertyLines.push("  updated_at?: string;");
    for (const [fieldName, fieldDef] of Object.entries(fields)) {
      const type = mapFieldTypeToTypeScript(fieldDef.type);
      const optional = !fieldDef.required ? "?" : "";
      propertyLines.push(`  ${fieldName}${optional}: ${type};`);
    }
    const interfaceDef = `export interface ${objectMeta.className}Data {
${propertyLines.join("\n")}
}`;
    interfaces.push(interfaceDef);
  }
  const objectTypesContent = `/**
 * Auto-generated TypeScript interfaces for SMRT objects
 * Generated at build time from @smrt() decorated classes
 *
 * DO NOT EDIT THIS FILE MANUALLY
 */

${interfaces.join("\n\n")}
`;
  fs.writeFileSync(path.join(outDir, "smrt-objects.d.ts"), objectTypesContent);
}
async function generateVirtualModuleDeclarations(manifest, outDir) {
  const manifestDeclaration = `/**
 * Auto-generated manifest module declaration
 */
declare module '@smrt/manifest' {
  export interface SmrtObjectField {
    type: string;
    required?: boolean;
    default?: any;
  }

  export interface SmrtObjectMethod {
    name: string;
    parameters: Array<{
      name: string;
      type: string;
      optional?: boolean;
      default?: any;
    }>;
    returnType: string;
    async: boolean;
    isStatic: boolean;
    isPublic: boolean;
  }

  export interface SmrtObjectDefinition {
    name: string;
    className: string;
    collection: string;
    filePath: string;
    fields: Record<string, SmrtObjectField>;
    methods: Record<string, SmrtObjectMethod>;
    decoratorConfig: any;
    extends?: string;
  }

  export interface SmrtManifest {
    version: string;
    timestamp: number;
    objects: Record<string, SmrtObjectDefinition>;
  }

  export const manifest: SmrtManifest;
  export default manifest;
}`;
  const collectionNames = [
    ...new Set(Object.values(manifest.objects).map((obj) => obj.collection))
  ];
  const apiClientInterface = collectionNames.map((collection) => {
    const dataType = Object.entries(manifest.objects).find(
      ([, obj]) => obj.collection === collection
    )?.[1].className;
    const interfaceName = dataType ? `${dataType}Data` : "any";
    return `    ${collection}: CrudOperations<${interfaceName}>;`;
  }).join("\n");
  const clientDeclaration = `/**
 * Auto-generated API client module declaration
 */
declare module '@smrt/client' {
  export interface ApiResponse<T = any> {
    id?: string;
    data?: T;
    error?: string;
    message?: string;
  }

  export interface CrudOperations<T = any> {
    list(params?: Record<string, any>): Promise<ApiResponse<T[]>>;
    get(id: string): Promise<ApiResponse<T>>;
    create(data: Partial<T>): Promise<ApiResponse<T>>;
    update(id: string, data: Partial<T>): Promise<ApiResponse<T>>;
    delete(id: string): Promise<boolean>;
  }

  export interface ApiClient {
${apiClientInterface}
  }

  export function createClient(basePath?: string): ApiClient;
  export default createClient;
}`;
  const routesDeclaration = `/**
 * Auto-generated routes module declaration
 */
declare module '@smrt/routes' {
  export interface RouteApp {
    get(path: string, handler: (req: any, res: any) => void): void;
    post(path: string, handler: (req: any, res: any) => void): void;
    put(path: string, handler: (req: any, res: any) => void): void;
    delete(path: string, handler: (req: any, res: any) => void): void;
  }

  export function setupRoutes(app: RouteApp): void;
  export default setupRoutes;
}`;
  const mcpDeclaration = `/**
 * Auto-generated MCP module declaration
 */
declare module '@smrt/mcp' {
  export interface McpTool {
    name: string;
    description: string;
    inputSchema: {
      type: string;
      properties: Record<string, any>;
      required?: string[];
    };
  }

  export const tools: McpTool[];
  export function createMCPServer(): {
    name: string;
    version: string;
    tools: McpTool[]
  };
  export default createMCPServer;
}`;
  const objectImports = Object.values(manifest.objects).map(
    (obj) => `  export type ${obj.className}Data = import('./smrt-objects').${obj.className}Data;`
  ).join("\n");
  const typesDeclaration = `/**
 * Auto-generated types module declaration
 */
declare module '@smrt/types' {
${objectImports}

  export interface Request {
    params: Record<string, string>;
    query: Record<string, any>;
    json(): Promise<any>;
  }

  export interface Response {
    json(data: any, init?: { status?: number }): Response;
    status(code: number): Response;
  }
}`;
  fs.writeFileSync(
    path.join(outDir, "smrt-manifest.d.ts"),
    manifestDeclaration
  );
  fs.writeFileSync(path.join(outDir, "smrt-client.d.ts"), clientDeclaration);
  fs.writeFileSync(path.join(outDir, "smrt-routes.d.ts"), routesDeclaration);
  fs.writeFileSync(path.join(outDir, "smrt-mcp.d.ts"), mcpDeclaration);
  fs.writeFileSync(path.join(outDir, "smrt-types.d.ts"), typesDeclaration);
}
function mapFieldTypeToTypeScript(smrtType) {
  switch (smrtType) {
    case "text":
      return "string";
    case "decimal":
    case "integer":
      return "number";
    case "boolean":
      return "boolean";
    case "datetime":
      return "string | Date";
    case "json":
      return "any";
    case "foreignKey":
      return "string";
    default:
      return "any";
  }
}
async function generateDeclarationsFromCLI(args) {
  const manifestPath = args[0];
  const outDir = args[1] || "src/types/generated";
  if (!manifestPath) {
    console.error("Usage: generate-declarations <manifest-path> [output-dir]");
    process.exit(1);
  }
  if (!fs.existsSync(manifestPath)) {
    console.error(`Manifest file not found: ${manifestPath}`);
    process.exit(1);
  }
  await generateDeclarations({
    manifest: manifestPath,
    outDir
  });
}
export {
  generateDeclarationsFromCLI as a,
  generateDeclarations as g
};
//# sourceMappingURL=index-Dw0X9BVV.js.map
