{"version":3,"file":"json-DY66pnr2.js","sources":["../../src/json.ts"],"sourcesContent":["import { DatabaseError } from '@have/utils';\nimport type {\n  DatabaseInterface,\n  QueryResult,\n  TableInterface,\n  JSONOptions,\n  SchemaInitializationOptions,\n} from './shared/types';\nimport { buildWhere } from './shared/utils';\nimport { DatabaseSchemaManager } from './schema-manager';\nimport { readdir, mkdir } from 'node:fs/promises';\nimport { join, basename, extname } from 'node:path';\n\n/**\n * Schema definition extracted from SMRT ObjectRegistry\n */\ninterface SmrtSchemaDefinition {\n  ddl: string;\n  indexes: string[];\n  tableName: string;\n  fields: Map<string, any>;\n}\n\n/**\n * Creates a JSON database connection using DuckDB in-memory engine\n *\n * This adapter uses DuckDB as a query engine for JSON files, storing everything\n * in-memory and writing changes back to JSON files. No WAL files or persistent\n * database files are created.\n *\n * @param options - JSON database options\n * @returns Promise resolving to a DuckDB connection\n */\nasync function createJSONConnection(options: JSONOptions) {\n  const {\n    dataDir,\n    autoRegister = true,\n    skipSmrtTables = false,\n  } = options;\n\n  if (!dataDir) {\n    throw new DatabaseError('dataDir is required for JSON adapter', {\n      options,\n    });\n  }\n\n  try {\n    // Dynamic import to avoid bundling\n    const duckdbModule = '@duckdb/node-api';\n    const { DuckDBInstance } = await import(/* @vite-ignore */ duckdbModule);\n\n    // Always use in-memory database - no persistent files\n    const instance = await DuckDBInstance.create(':memory:');\n    const connection = await instance.connect();\n\n    // Ensure data directory exists\n    try {\n      await mkdir(dataDir, { recursive: true });\n    } catch (error) {\n      // Directory might already exist, that's okay\n    }\n\n    // Load JSON files as in-memory tables\n    if (autoRegister) {\n      await loadJSONTables(connection, dataDir, skipSmrtTables);\n    }\n\n    return connection;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new DatabaseError(`Failed to create JSON database connection: ${errorMessage}`, {\n      dataDir,\n      originalError: errorMessage,\n    });\n  }\n}\n\n/**\n * Scans the data directory and loads JSON files as queryable in-memory tables\n *\n * Unlike the DuckDB adapter which creates views, this creates actual tables\n * so that indexes can be added.\n *\n * When a JSON file corresponds to a registered SMRT object, it will use the\n * SMRT schema definition to create properly-typed tables instead of relying\n * on DuckDB's auto-detection (which fails with empty strings/null values).\n *\n * @param connection - DuckDB connection\n * @param dataDir - Directory containing JSON files\n * @param skipSmrtTables - If true, skip auto-registration for tables with SMRT schemas (default: false)\n */\nasync function loadJSONTables(\n  connection: any,\n  dataDir: string,\n  skipSmrtTables = false,\n) {\n  try {\n    const files = await readdir(dataDir);\n    const jsonFiles = files.filter((file) =>\n      extname(file).toLowerCase() === '.json',\n    );\n\n    for (const file of jsonFiles) {\n      const filePath = join(dataDir, file);\n      const tableName = basename(file, '.json');\n\n      // Check if this table has a SMRT schema definition\n      const smrtSchema = await getSmrtSchemaForTable(tableName);\n\n      if (smrtSchema && skipSmrtTables) {\n        // Skip SMRT tables - they will be created by SMRT framework\n        console.log(\n          `[json-adapter] Skipping ${tableName} - will be created by SMRT framework`,\n        );\n        continue;\n      }\n\n      if (smrtSchema) {\n        // Create table with SMRT-derived types\n        console.log(\n          `[json-adapter] Creating ${tableName} with SMRT schema definition`,\n        );\n        await createTableFromSmrtSchema(connection, tableName, smrtSchema);\n\n        // Load JSON data into properly-typed table\n        // IMPORTANT: Don't use read_json() with auto_detect because DuckDB will\n        // re-infer types from the data, causing ANY type issues with empty strings.\n        // Instead, read JSON file and insert records using our CAST logic.\n        try {\n          const { readFile } = await import('node:fs/promises');\n          const jsonContent = await readFile(filePath, 'utf-8');\n          const records = JSON.parse(jsonContent);\n\n          if (Array.isArray(records) && records.length > 0) {\n            // Use a helper to insert records with proper CAST handling\n            await insertRecordsWithCast(connection, tableName, records);\n          }\n        } catch (error) {\n          // If INSERT fails (e.g., empty file, parse error), that's okay - table structure is what matters\n          console.warn(\n            `[json-adapter] Could not load data for ${tableName}: ${error instanceof Error ? error.message : String(error)}`,\n          );\n        }\n      } else {\n        // Fallback to auto-detection for non-SMRT tables\n        await connection.run(\n          `CREATE TABLE ${tableName} AS SELECT * FROM read_json('${filePath}', auto_detect=true, format='auto', ignore_errors=true)`,\n        );\n      }\n    }\n  } catch (error) {\n    // If directory doesn't exist or is empty, that's okay\n    if ((error as any).code !== 'ENOENT') {\n      throw new DatabaseError(`Failed to load JSON tables from ${dataDir}`, {\n        dataDir,\n        originalError: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n}\n\n/**\n * Converts BigInt values to regular numbers in an object\n *\n * @param obj - Object that may contain BigInt values\n * @returns Object with BigInts converted to numbers\n */\nfunction convertBigInts(obj: any): any {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj === 'bigint') return Number(obj);\n  if (Array.isArray(obj)) return obj.map(convertBigInts);\n  if (typeof obj === 'object') {\n    const result: any = {};\n    for (const key in obj) {\n      result[key] = convertBigInts(obj[key]);\n    }\n    return result;\n  }\n  return obj;\n}\n\n/**\n * Attempts to get schema definition from SMRT ObjectRegistry for a table\n *\n * @param tableName - Name of the table to look up (snake_case plural form)\n * @returns Schema definition or null if not found in registry\n */\nasync function getSmrtSchemaForTable(\n  tableName: string,\n): Promise<SmrtSchemaDefinition | null> {\n  try {\n    // Try to import ObjectRegistry from @have/smrt\n    const smrtPackage = await import('@have/smrt');\n    const { ObjectRegistry } = smrtPackage;\n\n    // Get all registered classes\n    const allClasses = ObjectRegistry.getAllClasses();\n\n    // Search for a class whose table name matches\n    for (const [className, registered] of allClasses) {\n      const schema = ObjectRegistry.getSchema(className);\n\n      if (schema && schema.tableName === tableName) {\n        return {\n          ddl: schema.ddl,\n          indexes: schema.indexes,\n          tableName: schema.tableName,\n          fields: ObjectRegistry.getFields(className),\n        };\n      }\n    }\n\n    return null;\n  } catch (error) {\n    // @have/smrt not available or ObjectRegistry not initialized\n    return null;\n  }\n}\n\n/**\n * Creates a table from SMRT schema definition with proper typing\n *\n * DuckDB has issues with type inference when DEFAULT values are empty strings.\n * This function explicitly casts all DEFAULT values to their column types to\n * prevent DuckDB from inferring ANY type.\n *\n * @param connection - DuckDB connection\n * @param tableName - Name of the table to create\n * @param schema - Schema definition from SMRT ObjectRegistry\n */\nasync function createTableFromSmrtSchema(\n  connection: any,\n  tableName: string,\n  schema: SmrtSchemaDefinition,\n): Promise<void> {\n  // Extract CREATE TABLE statement (without triggers which aren't supported)\n  const ddlLines = schema.ddl.split('\\n');\n  const createTableEnd = ddlLines.findIndex((line) =>\n    line.trim().startsWith(');'),\n  );\n\n  if (createTableEnd === -1) {\n    throw new DatabaseError('Invalid SMRT schema DDL - no closing parenthesis', {\n      tableName,\n      ddl: schema.ddl,\n    });\n  }\n\n  // Get CREATE TABLE statement\n  let createTableSQL = ddlLines.slice(0, createTableEnd + 1).join('\\n');\n\n  // Fix DEFAULT values for DuckDB type inference\n  // DuckDB infers ANY type when DEFAULT is an empty string without explicit cast\n  // Replace patterns like: DEFAULT '' with DEFAULT CAST('' AS TEXT)\n  createTableSQL = createTableSQL.replace(\n    /\\b(\\w+)\\s+(TEXT|VARCHAR)\\s+DEFAULT\\s+''/g,\n    \"$1 $2 DEFAULT CAST('' AS $2)\",\n  );\n\n  // Also handle DEFAULT NULL cases to ensure proper typing\n  createTableSQL = createTableSQL.replace(\n    /\\b(\\w+)\\s+(TEXT|VARCHAR)\\s+DEFAULT\\s+NULL/g,\n    '$1 $2 DEFAULT CAST(NULL AS $2)',\n  );\n\n  try {\n    await connection.run(createTableSQL);\n\n    // Verify schema was created correctly\n    const schemaInfo = await connection.runAndReadAll(\n      `PRAGMA table_info(${tableName})`\n    );\n    const columns = schemaInfo.getRowObjects();\n\n    console.log(`[json-adapter] Created ${tableName} with schema:`, {\n      columns: columns.map((col: any) => ({\n        name: col.name,\n        type: col.type,\n        default: col.dflt_value,\n        notNull: col.notnull,\n        pk: col.pk\n      }))\n    });\n\n    // Create indexes if defined\n    for (const indexSQL of schema.indexes) {\n      try {\n        await connection.run(indexSQL);\n      } catch (error) {\n        // Index creation might fail if column doesn't exist or syntax incompatibility\n        console.warn(\n          `[json-adapter] Failed to create index: ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    }\n  } catch (error) {\n    throw new DatabaseError('Failed to create table from SMRT schema', {\n      tableName,\n      sql: createTableSQL,\n      originalError: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Inserts records with proper CAST handling for empty strings\n *\n * This helper avoids using read_json() with auto_detect, which causes DuckDB\n * to re-infer column types from data (causing ANY type for empty strings).\n * Instead, it uses parameterized INSERT with CAST to maintain table schema.\n *\n * @param connection - DuckDB connection\n * @param tableName - Name of the table to insert into\n * @param records - Array of records to insert\n */\nasync function insertRecordsWithCast(\n  connection: any,\n  tableName: string,\n  records: Record<string, any>[],\n): Promise<void> {\n  if (records.length === 0) return;\n\n  const keys = Object.keys(records[0]);\n\n  // Build placeholders - schema has NOT NULL DEFAULT '' to prevent ANY type\n  const values: any[] = [];\n  let paramIdx = 1;\n\n  const placeholders = records\n    .map((record) => {\n      const rowPlaceholders = keys.map((key) => {\n        const value = record[key];\n\n        if (value === null) {\n          return 'NULL';\n        } else if (value === '' && typeof value === 'string') {\n          // CAST empty strings to TEXT to prevent DuckDB ANY type inference on parameters\n          values.push(value);\n          return `CAST($${paramIdx++} AS TEXT)`;\n        } else if (value instanceof Date) {\n          // Convert Date objects to ISO strings for DuckDB\n          values.push(value.toISOString());\n          return `$${paramIdx++}`;\n        } else {\n          // Direct parameter binding for other values\n          values.push(value);\n          return `$${paramIdx++}`;\n        }\n      });\n      return `(${rowPlaceholders.join(', ')})`;\n    })\n    .join(', ');\n\n  const sql = `INSERT INTO ${tableName} (${keys.join(', ')}) VALUES ${placeholders}`;\n\n  await connection.run(sql, values);\n}\n\n/**\n * Checks if a table name corresponds to a registered SMRT object\n *\n * @param tableName - Name of the table to check\n * @returns True if the table matches a SMRT object's table name\n */\nasync function isSmrtTable(tableName: string): Promise<boolean> {\n  const schema = await getSmrtSchemaForTable(tableName);\n  return schema !== null;\n}\n\n/**\n * Creates a JSON database adapter using DuckDB in-memory engine\n *\n * This adapter provides SQL query capabilities over JSON files without creating\n * persistent database files or WAL files. All data is stored in-memory during\n * runtime and written back to JSON files based on the write strategy.\n *\n * @param options - JSON database options\n * @returns Database interface for JSON files\n */\nexport async function getDatabase(\n  options: JSONOptions,\n): Promise<DatabaseInterface> {\n  const connection = await createJSONConnection(options);\n  const writeStrategy = options.writeStrategy || 'immediate';\n  const dataDir = options.dataDir;\n\n  /**\n   * Inserts one or more records into a table\n   *\n   * @param table - Table name\n   * @param data - Single record or array of records to insert\n   * @returns Promise resolving to operation result\n   * @throws Error if the insert operation fails\n   */\n  const insert = async (\n    table: string,\n    data: Record<string, any> | Record<string, any>[],\n  ): Promise<QueryResult> => {\n    // Enforce read-only mode\n    if (writeStrategy === 'none') {\n      throw new DatabaseError(\n        'Cannot insert: write strategy is set to none (read-only mode)',\n        { table, writeStrategy }\n      );\n    }\n\n    const records = Array.isArray(data) ? data : [data];\n\n    if (records.length === 0) {\n      return { operation: 'insert', affected: 0 };\n    }\n\n    const keys = Object.keys(records[0]);\n\n    // Build placeholders with CAST for empty strings\n    const values: any[] = [];\n    let paramIdx = 1;\n\n    const placeholders = records\n      .map((record) => {\n        const rowPlaceholders = keys.map((key) => {\n          const value = record[key];\n\n          if (value === null) {\n            return 'NULL';\n          } else {\n            // Direct parameter binding - schema has NOT NULL DEFAULT '' to prevent ANY type\n            values.push(value);\n            return `$${paramIdx++}`;\n          }\n        });\n        return `(${rowPlaceholders.join(', ')})`;\n      })\n      .join(', ');\n\n    const sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES ${placeholders}`;\n\n    try {\n      await connection.run(sql, values);\n      const affected = records.length;\n\n      // Handle write-back strategy\n      if (writeStrategy === 'immediate') {\n        await exportTableToJSON(connection, table, dataDir);\n      }\n\n      return { operation: 'insert', affected };\n    } catch (e) {\n      throw new DatabaseError('Failed to insert records into table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Retrieves a single record matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to matching record or null if not found\n   * @throws Error if the query fails\n   */\n  const get = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any> | null> => {\n    const { sql: whereClause, values } = buildWhere(where, 1);\n    const sql = `SELECT * FROM ${table} ${whereClause} LIMIT 1`;\n\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      const rows = reader.getRowObjects();\n      return rows.length > 0 ? convertBigInts(rows[0]) : null;\n    } catch (e) {\n      throw new DatabaseError('Failed to retrieve record from table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Retrieves multiple records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to array of matching records\n   * @throws Error if the query fails\n   */\n  const list = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any>[]> => {\n    const { sql: whereClause, values } = buildWhere(where, 1);\n    const sql = `SELECT * FROM ${table} ${whereClause}`;\n\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      return convertBigInts(reader.getRowObjects());\n    } catch (e) {\n      throw new DatabaseError('Failed to list records from table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Updates records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records to update\n   * @param data - New data to set\n   * @returns Promise resolving to operation result\n   * @throws Error if the update operation fails\n   */\n  const update = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<QueryResult> => {\n    // Enforce read-only mode\n    if (writeStrategy === 'none') {\n      throw new DatabaseError(\n        'Cannot update: write strategy is set to none (read-only mode)',\n        { table, writeStrategy }\n      );\n    }\n\n    const keys = Object.keys(data);\n    const setClause = keys.map((key, idx) => `${key} = $${idx + 1}`).join(', ');\n    const { sql: whereClause, values: whereValues } = buildWhere(where, keys.length + 1);\n\n    const sql = `UPDATE ${table} SET ${setClause} ${whereClause}`;\n    const values = [...Object.values(data), ...whereValues];\n\n    try {\n      await connection.run(sql, values);\n\n      // Handle write-back strategy\n      if (writeStrategy === 'immediate') {\n        await exportTableToJSON(connection, table, dataDir);\n      }\n\n      // DuckDB doesn't return rowsAffected in the same way, estimate from where clause\n      return { operation: 'update', affected: 1 };\n    } catch (e) {\n      throw new DatabaseError('Failed to update records in table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Inserts a record or updates it if it already exists (UPSERT)\n   *\n   * @param table - Table name\n   * @param conflictColumns - Columns that define the uniqueness constraint\n   * @param data - Data to insert or update\n   * @returns Promise resolving to operation result\n   * @throws Error if the upsert operation fails\n   */\n  const upsert = async (\n    table: string,\n    conflictColumns: string[],\n    data: Record<string, any>,\n  ): Promise<QueryResult> => {\n    // Enforce read-only mode\n    if (writeStrategy === 'none') {\n      throw new DatabaseError(\n        'Cannot upsert: write strategy is set to none (read-only mode)',\n        { table, writeStrategy }\n      );\n    }\n\n    const keys = Object.keys(data);\n    const dataValues = Object.values(data);\n\n    // Build placeholders - schema has NOT NULL DEFAULT '' to prevent ANY type\n    const placeholders: string[] = [];\n    const values: any[] = [];\n    let paramIdx = 1;\n\n    for (const value of dataValues) {\n      if (value === null) {\n        placeholders.push('NULL');\n      } else if (value === '' && typeof value === 'string') {\n        // CAST empty strings to TEXT to prevent DuckDB ANY type inference on parameters\n        placeholders.push(`CAST($${paramIdx} AS TEXT)`);\n        values.push(value);\n        paramIdx++;\n      } else if (value instanceof Date) {\n        // Convert Date objects to ISO strings for DuckDB\n        placeholders.push(`$${paramIdx}`);\n        values.push(value.toISOString());\n        paramIdx++;\n      } else {\n        // Direct parameter binding for other values\n        placeholders.push(`$${paramIdx}`);\n        values.push(value);\n        paramIdx++;\n      }\n    }\n\n    // Build UPDATE SET clause with same approach\n    // DO NOT reset paramIdx - parameters must be unique across entire query\n    const updateSetParts: string[] = [];\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const value = dataValues[i];\n\n      if (value === null) {\n        updateSetParts.push(`${key} = NULL`);\n      } else if (value === '' && typeof value === 'string') {\n        // CAST empty strings to TEXT to prevent DuckDB ANY type inference on parameters\n        updateSetParts.push(`${key} = CAST($${paramIdx} AS TEXT)`);\n        values.push(value);\n        paramIdx++;\n      } else if (value instanceof Date) {\n        // Convert Date objects to ISO strings for DuckDB\n        updateSetParts.push(`${key} = $${paramIdx}`);\n        values.push(value.toISOString());\n        paramIdx++;\n      } else {\n        // Direct parameter binding for other values\n        updateSetParts.push(`${key} = $${paramIdx}`);\n        values.push(value);\n        paramIdx++;\n      }\n    }\n\n    const conflict = conflictColumns.join(', ');\n    const sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders.join(', ')}) ON CONFLICT(${conflict}) DO UPDATE SET ${updateSetParts.join(', ')}`;\n\n    try {\n      await connection.run(sql, values);\n\n      // Handle write-back strategy\n      if (writeStrategy === 'immediate') {\n        await exportTableToJSON(connection, table, dataDir);\n      }\n\n      return { operation: 'upsert', affected: 1 };\n    } catch (e) {\n      // Log detailed error information for debugging\n      console.error('UPSERT failed:', {\n        table,\n        sql,\n        values,\n        valueTypes: values.map((v) => `${typeof v} (${v})`),\n        conflictColumns,\n        error: e instanceof Error ? e.message : String(e),\n      });\n      throw new DatabaseError('Failed to upsert record into table', {\n        table,\n        sql,\n        values,\n        conflictColumns,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Gets a record matching the where criteria or inserts it if not found\n   *\n   * @param table - Table name\n   * @param where - Criteria to match existing record\n   * @param data - Data to insert if no record found\n   * @returns Promise resolving to the record (either retrieved or newly inserted)\n   * @throws Error if the operation fails\n   */\n  const getOrInsert = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<Record<string, any>> => {\n    const result = await get(table, where);\n    if (result) return result;\n\n    await insert(table, data);\n    const inserted = await get(table, where);\n\n    if (!inserted) {\n      throw new DatabaseError('Failed to insert and retrieve record', {\n        table,\n        where,\n        data,\n      });\n    }\n\n    return inserted;\n  };\n\n  /**\n   * Checks if a table exists in the database\n   *\n   * @param tableName - Name of the table to check\n   * @returns Promise resolving to boolean indicating if the table exists\n   */\n  const tableExists = async (tableName: string): Promise<boolean> => {\n    try {\n      // Try to query the table\n      await connection.runAndReadAll(`SELECT * FROM ${tableName} LIMIT 1`);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  /**\n   * Exports a table to a JSON file\n   *\n   * Overwrites the existing JSON file with the current table contents.\n   *\n   * @param connection - DuckDB connection\n   * @param table - Table name\n   * @param dataDir - Directory to write JSON file\n   */\n  const exportTableToJSON = async (\n    connection: any,\n    table: string,\n    dataDir: string,\n  ): Promise<void> => {\n    const filePath = join(dataDir, `${table}.json`);\n    await connection.run(\n      `COPY (SELECT * FROM ${table}) TO '${filePath}' (FORMAT JSON, ARRAY true)`\n    );\n  };\n\n  /**\n   * Manual export method for 'manual' write strategy\n   *\n   * Allows explicit control over when tables are written back to JSON files.\n   *\n   * @param table - Table name to export\n   * @returns Promise that resolves when export completes\n   */\n  const exportTable = async (table: string): Promise<void> => {\n    if (writeStrategy === 'none') {\n      throw new DatabaseError(\n        'Cannot export table: write strategy is set to none (read-only mode)',\n        { table, writeStrategy }\n      );\n    }\n    await exportTableToJSON(connection, table, dataDir);\n  };\n\n  /**\n   * Creates a table-specific interface for simplified table operations\n   *\n   * @param tableName - Table name\n   * @returns TableInterface for the specified table\n   */\n  const table = (tableName: string): TableInterface => ({\n    insert: (data) => insert(tableName, data),\n    get: (where) => get(tableName, where),\n    list: (where) => list(tableName, where),\n  });\n\n  /**\n   * Parses a tagged template literal into a SQL query and values\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Object with SQL query and values array\n   */\n  const parseTemplate = (strings: TemplateStringsArray, ...vars: any[]) => {\n    let sql = strings[0];\n    const values = [];\n    for (let i = 0; i < vars.length; i++) {\n      values.push(vars[i]);\n      sql += `$${i + 1}${strings[i + 1]}`;\n    }\n    return { sql, values };\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns multiple rows\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to array of result records\n   * @throws Error if the query fails\n   */\n  const many = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any>[]> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      return convertBigInts(reader.getRowObjects());\n    } catch (e) {\n      throw new DatabaseError('Failed to execute many query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single row\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single result record or null\n   * @throws Error if the query fails\n   */\n  const single = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any> | null> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      const rows = reader.getRowObjects();\n      return rows[0] ? convertBigInts(rows[0]) : null;\n    } catch (e) {\n      throw new DatabaseError('Failed to execute single query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single value\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single value (first column of first row)\n   * @throws Error if the query fails\n   */\n  const pluck = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<any> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      const rows = reader.getRowObjects();\n      if (rows.length === 0) return null;\n      const firstRow = rows[0];\n      const firstKey = Object.keys(firstRow)[0];\n      return convertBigInts(firstRow[firstKey]);\n    } catch (e) {\n      throw new DatabaseError('Failed to execute pluck query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals without returning results\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise that resolves when the query completes\n   * @throws Error if the query fails\n   */\n  const execute = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<void> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      await connection.run(sql, values);\n    } catch (e) {\n      throw new DatabaseError('Failed to execute query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a raw SQL query with parameterized values\n   *\n   * @param str - SQL query string\n   * @param values - Variables to use as parameters\n   * @returns Promise resolving to query result with rows and metadata\n   * @throws Error if the query fails\n   */\n  const query = async (str: string, ...values: any[]) => {\n    const sql = str;\n    const args = Array.isArray(values[0]) ? values[0] : values;\n\n    try {\n      const reader = await connection.runAndReadAll(sql, args);\n      const rows = convertBigInts(reader.getRowObjects());\n\n      return {\n        command: sql.split(' ')[0].toUpperCase(),\n        rowCount: rows.length,\n        oid: null,\n        fields: rows.length > 0\n          ? Object.keys(rows[0]).map((name) => ({\n              name,\n              tableID: 0,\n              columnID: 0,\n              dataTypeID: 0,\n              dataTypeSize: -1,\n              dataTypeModifier: -1,\n              format: 'text',\n            }))\n          : [],\n        rows,\n      };\n    } catch (e) {\n      throw new DatabaseError('Failed to execute raw query', {\n        sql,\n        args,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  // Shorthand aliases for query methods\n  const oo = many; // (o)bjective-(o)bjects: returns multiple rows\n  const oO = single; // (o)bjective-(O)bject: returns a single row\n  const ox = pluck; // (o)bjective-(x): returns a single value\n  const xx = execute; // e(x)ecute-e(x)ecute: executes without returning\n\n  /**\n   * Synchronizes database schema with provided SQL DDL\n   *\n   * Filters out CREATE TRIGGER statements since triggers are not supported\n   * in the JSON adapter (timestamps managed at application level).\n   *\n   * @param schema - SQL schema definition with CREATE TABLE statements\n   * @returns Promise that resolves when schema is synchronized\n   */\n  const syncSchema = async (schema: string): Promise<void> => {\n    const commands = schema\n      .trim()\n      .split(';')\n      .filter((command) => command.trim() !== '');\n\n    for (const command of commands) {\n      const trimmedCommand = command.trim().toUpperCase();\n\n      // Skip trigger creation - not supported in JSON adapter\n      if (trimmedCommand.startsWith('CREATE TRIGGER')) {\n        console.warn('[json-adapter] Skipping trigger creation - timestamps managed at application level');\n        continue;\n      }\n\n      try {\n        await connection.run(command);\n      } catch (e) {\n        // Log but don't fail on schema sync errors\n        console.error('Schema sync error:', e);\n      }\n    }\n  };\n\n  /**\n   * Initialize database schemas from JSON manifest\n   * Supports dependency resolution and schema overrides\n   *\n   * @param options - Schema initialization options\n   * @returns Promise that resolves when schemas are initialized\n   */\n  const initializeSchemas = async (\n    options: SchemaInitializationOptions,\n  ): Promise<void> => {\n    const schemaManager = new DatabaseSchemaManager();\n    const currentDb: DatabaseInterface = {\n      client: connection,\n      query,\n      insert,\n      update,\n      upsert,\n      get,\n      list,\n      getOrInsert,\n      table,\n      tableExists,\n      many,\n      single,\n      pluck,\n      execute,\n      oo,\n      oO,\n      ox,\n      xx,\n      syncSchema,\n    };\n\n    await schemaManager.initializeSchemas(currentDb, options);\n  };\n\n  /**\n   * Executes a callback within a database transaction\n   * Automatically commits on success or rolls back on error\n   *\n   * @param callback - Function to execute within transaction\n   * @returns Promise resolving to callback result\n   */\n  const transaction = async <T>(\n    callback: (tx: DatabaseInterface) => Promise<T>,\n  ): Promise<T> => {\n    try {\n      await connection.run('BEGIN TRANSACTION');\n\n      // Create a transaction-scoped database interface\n      const txDb: DatabaseInterface = {\n        client: connection,\n        insert,\n        get,\n        list,\n        update,\n        upsert,\n        getOrInsert,\n        table,\n        many,\n        single,\n        pluck,\n        execute,\n        query,\n        oo,\n        oO,\n        ox,\n        xx,\n        tableExists,\n        syncSchema,\n        transaction,\n      };\n\n      const result = await callback(txDb);\n      await connection.run('COMMIT');\n      return result;\n    } catch (error) {\n      await connection.run('ROLLBACK');\n      throw error;\n    }\n  };\n\n  return {\n    client: connection,\n    query,\n    insert,\n    update,\n    upsert,\n    get,\n    list,\n    getOrInsert,\n    table,\n    tableExists,\n    many,\n    single,\n    pluck,\n    execute,\n    oo,\n    oO,\n    ox,\n    xx,\n    syncSchema,\n    initializeSchemas,\n    transaction,\n    // JSON-specific export method\n    exportTable,\n  } as DatabaseInterface & { exportTable: (table: string) => Promise<void> };\n}\n"],"names":["table","connection","dataDir","options"],"mappings":";;;;AAiCA,eAAe,qBAAqB,SAAsB;AACxD,QAAM;AAAA,IACJ;AAAA,IACA,eAAe;AAAA,IACf,iBAAiB;AAAA,EAAA,IACf;AAEJ,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,cAAc,wCAAwC;AAAA,MAC9D;AAAA,IAAA,CACD;AAAA,EACH;AAEA,MAAI;AAEF,UAAM,eAAe;AACrB,UAAM,EAAE,eAAA,IAAmB,MAAM;AAAA;AAAA,MAA0B;AAAA;AAG3D,UAAM,WAAW,MAAM,eAAe,OAAO,UAAU;AACvD,UAAM,aAAa,MAAM,SAAS,QAAA;AAGlC,QAAI;AACF,YAAM,MAAM,SAAS,EAAE,WAAW,MAAM;AAAA,IAC1C,SAAS,OAAO;AAAA,IAEhB;AAGA,QAAI,cAAc;AAChB,YAAM,eAAe,YAAY,SAAS,cAAc;AAAA,IAC1D;AAEA,WAAO;AAAA,EACT,SAAS,OAAO;AACd,UAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAC1E,UAAM,IAAI,cAAc,8CAA8C,YAAY,IAAI;AAAA,MACpF;AAAA,MACA,eAAe;AAAA,IAAA,CAChB;AAAA,EACH;AACF;AAgBA,eAAe,eACb,YACA,SACA,iBAAiB,OACjB;AACA,MAAI;AACF,UAAM,QAAQ,MAAM,QAAQ,OAAO;AACnC,UAAM,YAAY,MAAM;AAAA,MAAO,CAAC,SAC9B,QAAQ,IAAI,EAAE,kBAAkB;AAAA,IAAA;AAGlC,eAAW,QAAQ,WAAW;AAC5B,YAAM,WAAW,KAAK,SAAS,IAAI;AACnC,YAAM,YAAY,SAAS,MAAM,OAAO;AAGxC,YAAM,aAAa,MAAM,sBAAsB,SAAS;AAExD,UAAI,cAAc,gBAAgB;AAEhC,gBAAQ;AAAA,UACN,2BAA2B,SAAS;AAAA,QAAA;AAEtC;AAAA,MACF;AAEA,UAAI,YAAY;AAEd,gBAAQ;AAAA,UACN,2BAA2B,SAAS;AAAA,QAAA;AAEtC,cAAM,0BAA0B,YAAY,WAAW,UAAU;AAMjE,YAAI;AACF,gBAAM,EAAE,SAAA,IAAa,MAAM,OAAO,kBAAkB;AACpD,gBAAM,cAAc,MAAM,SAAS,UAAU,OAAO;AACpD,gBAAM,UAAU,KAAK,MAAM,WAAW;AAEtC,cAAI,MAAM,QAAQ,OAAO,KAAK,QAAQ,SAAS,GAAG;AAEhD,kBAAM,sBAAsB,YAAY,WAAW,OAAO;AAAA,UAC5D;AAAA,QACF,SAAS,OAAO;AAEd,kBAAQ;AAAA,YACN,0CAA0C,SAAS,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,UAAA;AAAA,QAElH;AAAA,MACF,OAAO;AAEL,cAAM,WAAW;AAAA,UACf,gBAAgB,SAAS,gCAAgC,QAAQ;AAAA,QAAA;AAAA,MAErE;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AAEd,QAAK,MAAc,SAAS,UAAU;AACpC,YAAM,IAAI,cAAc,mCAAmC,OAAO,IAAI;AAAA,QACpE;AAAA,QACA,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAAA,CACrE;AAAA,IACH;AAAA,EACF;AACF;AAQA,SAAS,eAAe,KAAe;AACrC,MAAI,QAAQ,QAAQ,QAAQ,OAAW,QAAO;AAC9C,MAAI,OAAO,QAAQ,SAAU,QAAO,OAAO,GAAG;AAC9C,MAAI,MAAM,QAAQ,GAAG,EAAG,QAAO,IAAI,IAAI,cAAc;AACrD,MAAI,OAAO,QAAQ,UAAU;AAC3B,UAAM,SAAc,CAAA;AACpB,eAAW,OAAO,KAAK;AACrB,aAAO,GAAG,IAAI,eAAe,IAAI,GAAG,CAAC;AAAA,IACvC;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAQA,eAAe,sBACb,WACsC;AACtC,MAAI;AAEF,UAAM,cAAc,MAAM,OAAO,YAAY;AAC7C,UAAM,EAAE,mBAAmB;AAG3B,UAAM,aAAa,eAAe,cAAA;AAGlC,eAAW,CAAC,WAAW,UAAU,KAAK,YAAY;AAChD,YAAM,SAAS,eAAe,UAAU,SAAS;AAEjD,UAAI,UAAU,OAAO,cAAc,WAAW;AAC5C,eAAO;AAAA,UACL,KAAK,OAAO;AAAA,UACZ,SAAS,OAAO;AAAA,UAChB,WAAW,OAAO;AAAA,UAClB,QAAQ,eAAe,UAAU,SAAS;AAAA,QAAA;AAAA,MAE9C;AAAA,IACF;AAEA,WAAO;AAAA,EACT,SAAS,OAAO;AAEd,WAAO;AAAA,EACT;AACF;AAaA,eAAe,0BACb,YACA,WACA,QACe;AAEf,QAAM,WAAW,OAAO,IAAI,MAAM,IAAI;AACtC,QAAM,iBAAiB,SAAS;AAAA,IAAU,CAAC,SACzC,KAAK,KAAA,EAAO,WAAW,IAAI;AAAA,EAAA;AAG7B,MAAI,mBAAmB,IAAI;AACzB,UAAM,IAAI,cAAc,oDAAoD;AAAA,MAC1E;AAAA,MACA,KAAK,OAAO;AAAA,IAAA,CACb;AAAA,EACH;AAGA,MAAI,iBAAiB,SAAS,MAAM,GAAG,iBAAiB,CAAC,EAAE,KAAK,IAAI;AAKpE,mBAAiB,eAAe;AAAA,IAC9B;AAAA,IACA;AAAA,EAAA;AAIF,mBAAiB,eAAe;AAAA,IAC9B;AAAA,IACA;AAAA,EAAA;AAGF,MAAI;AACF,UAAM,WAAW,IAAI,cAAc;AAGnC,UAAM,aAAa,MAAM,WAAW;AAAA,MAClC,qBAAqB,SAAS;AAAA,IAAA;AAEhC,UAAM,UAAU,WAAW,cAAA;AAE3B,YAAQ,IAAI,0BAA0B,SAAS,iBAAiB;AAAA,MAC9D,SAAS,QAAQ,IAAI,CAAC,SAAc;AAAA,QAClC,MAAM,IAAI;AAAA,QACV,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,QACb,SAAS,IAAI;AAAA,QACb,IAAI,IAAI;AAAA,MAAA,EACR;AAAA,IAAA,CACH;AAGD,eAAW,YAAY,OAAO,SAAS;AACrC,UAAI;AACF,cAAM,WAAW,IAAI,QAAQ;AAAA,MAC/B,SAAS,OAAO;AAEd,gBAAQ;AAAA,UACN,0CAA0C,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QAAA;AAAA,MAEpG;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AACd,UAAM,IAAI,cAAc,2CAA2C;AAAA,MACjE;AAAA,MACA,KAAK;AAAA,MACL,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,IAAA,CACrE;AAAA,EACH;AACF;AAaA,eAAe,sBACb,YACA,WACA,SACe;AACf,MAAI,QAAQ,WAAW,EAAG;AAE1B,QAAM,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC;AAGnC,QAAM,SAAgB,CAAA;AACtB,MAAI,WAAW;AAEf,QAAM,eAAe,QAClB,IAAI,CAAC,WAAW;AACf,UAAM,kBAAkB,KAAK,IAAI,CAAC,QAAQ;AACxC,YAAM,QAAQ,OAAO,GAAG;AAExB,UAAI,UAAU,MAAM;AAClB,eAAO;AAAA,MACT,WAAW,UAAU,MAAM,OAAO,UAAU,UAAU;AAEpD,eAAO,KAAK,KAAK;AACjB,eAAO,SAAS,UAAU;AAAA,MAC5B,WAAW,iBAAiB,MAAM;AAEhC,eAAO,KAAK,MAAM,aAAa;AAC/B,eAAO,IAAI,UAAU;AAAA,MACvB,OAAO;AAEL,eAAO,KAAK,KAAK;AACjB,eAAO,IAAI,UAAU;AAAA,MACvB;AAAA,IACF,CAAC;AACD,WAAO,IAAI,gBAAgB,KAAK,IAAI,CAAC;AAAA,EACvC,CAAC,EACA,KAAK,IAAI;AAEZ,QAAM,MAAM,eAAe,SAAS,KAAK,KAAK,KAAK,IAAI,CAAC,YAAY,YAAY;AAEhF,QAAM,WAAW,IAAI,KAAK,MAAM;AAClC;AAuBA,eAAsB,YACpB,SAC4B;AAC5B,QAAM,aAAa,MAAM,qBAAqB,OAAO;AACrD,QAAM,gBAAgB,QAAQ,iBAAiB;AAC/C,QAAM,UAAU,QAAQ;AAUxB,QAAM,SAAS,OACbA,QACA,SACyB;AAEzB,QAAI,kBAAkB,QAAQ;AAC5B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,OAAAA,QAAO,cAAA;AAAA,MAAc;AAAA,IAE3B;AAEA,UAAM,UAAU,MAAM,QAAQ,IAAI,IAAI,OAAO,CAAC,IAAI;AAElD,QAAI,QAAQ,WAAW,GAAG;AACxB,aAAO,EAAE,WAAW,UAAU,UAAU,EAAA;AAAA,IAC1C;AAEA,UAAM,OAAO,OAAO,KAAK,QAAQ,CAAC,CAAC;AAGnC,UAAM,SAAgB,CAAA;AACtB,QAAI,WAAW;AAEf,UAAM,eAAe,QAClB,IAAI,CAAC,WAAW;AACf,YAAM,kBAAkB,KAAK,IAAI,CAAC,QAAQ;AACxC,cAAM,QAAQ,OAAO,GAAG;AAExB,YAAI,UAAU,MAAM;AAClB,iBAAO;AAAA,QACT,OAAO;AAEL,iBAAO,KAAK,KAAK;AACjB,iBAAO,IAAI,UAAU;AAAA,QACvB;AAAA,MACF,CAAC;AACD,aAAO,IAAI,gBAAgB,KAAK,IAAI,CAAC;AAAA,IACvC,CAAC,EACA,KAAK,IAAI;AAEZ,UAAM,MAAM,eAAeA,MAAK,KAAK,KAAK,KAAK,IAAI,CAAC,YAAY,YAAY;AAE5E,QAAI;AACF,YAAM,WAAW,IAAI,KAAK,MAAM;AAChC,YAAM,WAAW,QAAQ;AAGzB,UAAI,kBAAkB,aAAa;AACjC,cAAM,kBAAkB,YAAYA,QAAO,OAAO;AAAA,MACpD;AAEA,aAAO,EAAE,WAAW,UAAU,SAAA;AAAA,IAChC,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,uCAAuC;AAAA,QAC7D,OAAAA;AAAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAUA,QAAM,MAAM,OACVA,QACA,UACwC;AACxC,UAAM,EAAE,KAAK,aAAa,WAAW,WAAW,OAAO,CAAC;AACxD,UAAM,MAAM,iBAAiBA,MAAK,IAAI,WAAW;AAEjD,QAAI;AACF,YAAM,SAAS,MAAM,WAAW,cAAc,KAAK,MAAM;AACzD,YAAM,OAAO,OAAO,cAAA;AACpB,aAAO,KAAK,SAAS,IAAI,eAAe,KAAK,CAAC,CAAC,IAAI;AAAA,IACrD,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,wCAAwC;AAAA,QAC9D,OAAAA;AAAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAUA,QAAM,OAAO,OACXA,QACA,UACmC;AACnC,UAAM,EAAE,KAAK,aAAa,WAAW,WAAW,OAAO,CAAC;AACxD,UAAM,MAAM,iBAAiBA,MAAK,IAAI,WAAW;AAEjD,QAAI;AACF,YAAM,SAAS,MAAM,WAAW,cAAc,KAAK,MAAM;AACzD,aAAO,eAAe,OAAO,eAAe;AAAA,IAC9C,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,qCAAqC;AAAA,QAC3D,OAAAA;AAAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAWA,QAAM,SAAS,OACbA,QACA,OACA,SACyB;AAEzB,QAAI,kBAAkB,QAAQ;AAC5B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,OAAAA,QAAO,cAAA;AAAA,MAAc;AAAA,IAE3B;AAEA,UAAM,OAAO,OAAO,KAAK,IAAI;AAC7B,UAAM,YAAY,KAAK,IAAI,CAAC,KAAK,QAAQ,GAAG,GAAG,OAAO,MAAM,CAAC,EAAE,EAAE,KAAK,IAAI;AAC1E,UAAM,EAAE,KAAK,aAAa,QAAQ,YAAA,IAAgB,WAAW,OAAO,KAAK,SAAS,CAAC;AAEnF,UAAM,MAAM,UAAUA,MAAK,QAAQ,SAAS,IAAI,WAAW;AAC3D,UAAM,SAAS,CAAC,GAAG,OAAO,OAAO,IAAI,GAAG,GAAG,WAAW;AAEtD,QAAI;AACF,YAAM,WAAW,IAAI,KAAK,MAAM;AAGhC,UAAI,kBAAkB,aAAa;AACjC,cAAM,kBAAkB,YAAYA,QAAO,OAAO;AAAA,MACpD;AAGA,aAAO,EAAE,WAAW,UAAU,UAAU,EAAA;AAAA,IAC1C,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,qCAAqC;AAAA,QAC3D,OAAAA;AAAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAWA,QAAM,SAAS,OACbA,QACA,iBACA,SACyB;AAEzB,QAAI,kBAAkB,QAAQ;AAC5B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,OAAAA,QAAO,cAAA;AAAA,MAAc;AAAA,IAE3B;AAEA,UAAM,OAAO,OAAO,KAAK,IAAI;AAC7B,UAAM,aAAa,OAAO,OAAO,IAAI;AAGrC,UAAM,eAAyB,CAAA;AAC/B,UAAM,SAAgB,CAAA;AACtB,QAAI,WAAW;AAEf,eAAW,SAAS,YAAY;AAC9B,UAAI,UAAU,MAAM;AAClB,qBAAa,KAAK,MAAM;AAAA,MAC1B,WAAW,UAAU,MAAM,OAAO,UAAU,UAAU;AAEpD,qBAAa,KAAK,SAAS,QAAQ,WAAW;AAC9C,eAAO,KAAK,KAAK;AACjB;AAAA,MACF,WAAW,iBAAiB,MAAM;AAEhC,qBAAa,KAAK,IAAI,QAAQ,EAAE;AAChC,eAAO,KAAK,MAAM,aAAa;AAC/B;AAAA,MACF,OAAO;AAEL,qBAAa,KAAK,IAAI,QAAQ,EAAE;AAChC,eAAO,KAAK,KAAK;AACjB;AAAA,MACF;AAAA,IACF;AAIA,UAAM,iBAA2B,CAAA;AAEjC,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,YAAM,MAAM,KAAK,CAAC;AAClB,YAAM,QAAQ,WAAW,CAAC;AAE1B,UAAI,UAAU,MAAM;AAClB,uBAAe,KAAK,GAAG,GAAG,SAAS;AAAA,MACrC,WAAW,UAAU,MAAM,OAAO,UAAU,UAAU;AAEpD,uBAAe,KAAK,GAAG,GAAG,YAAY,QAAQ,WAAW;AACzD,eAAO,KAAK,KAAK;AACjB;AAAA,MACF,WAAW,iBAAiB,MAAM;AAEhC,uBAAe,KAAK,GAAG,GAAG,OAAO,QAAQ,EAAE;AAC3C,eAAO,KAAK,MAAM,aAAa;AAC/B;AAAA,MACF,OAAO;AAEL,uBAAe,KAAK,GAAG,GAAG,OAAO,QAAQ,EAAE;AAC3C,eAAO,KAAK,KAAK;AACjB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,WAAW,gBAAgB,KAAK,IAAI;AAC1C,UAAM,MAAM,eAAeA,MAAK,KAAK,KAAK,KAAK,IAAI,CAAC,aAAa,aAAa,KAAK,IAAI,CAAC,iBAAiB,QAAQ,mBAAmB,eAAe,KAAK,IAAI,CAAC;AAE7J,QAAI;AACF,YAAM,WAAW,IAAI,KAAK,MAAM;AAGhC,UAAI,kBAAkB,aAAa;AACjC,cAAM,kBAAkB,YAAYA,QAAO,OAAO;AAAA,MACpD;AAEA,aAAO,EAAE,WAAW,UAAU,UAAU,EAAA;AAAA,IAC1C,SAAS,GAAG;AAEV,cAAQ,MAAM,kBAAkB;AAAA,QAC9B,OAAAA;AAAAA,QACA;AAAA,QACA;AAAA,QACA,YAAY,OAAO,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG;AAAA,QAClD;AAAA,QACA,OAAO,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACjD;AACD,YAAM,IAAI,cAAc,sCAAsC;AAAA,QAC5D,OAAAA;AAAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAWA,QAAM,cAAc,OAClBA,QACA,OACA,SACiC;AACjC,UAAM,SAAS,MAAM,IAAIA,QAAO,KAAK;AACrC,QAAI,OAAQ,QAAO;AAEnB,UAAM,OAAOA,QAAO,IAAI;AACxB,UAAM,WAAW,MAAM,IAAIA,QAAO,KAAK;AAEvC,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,cAAc,wCAAwC;AAAA,QAC9D,OAAAA;AAAAA,QACA;AAAA,QACA;AAAA,MAAA,CACD;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAQA,QAAM,cAAc,OAAO,cAAwC;AACjE,QAAI;AAEF,YAAM,WAAW,cAAc,iBAAiB,SAAS,UAAU;AACnE,aAAO;AAAA,IACT,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAWA,QAAM,oBAAoB,OACxBC,aACAD,QACAE,aACkB;AAClB,UAAM,WAAW,KAAKA,UAAS,GAAGF,MAAK,OAAO;AAC9C,UAAMC,YAAW;AAAA,MACf,uBAAuBD,MAAK,SAAS,QAAQ;AAAA,IAAA;AAAA,EAEjD;AAUA,QAAM,cAAc,OAAOA,WAAiC;AAC1D,QAAI,kBAAkB,QAAQ;AAC5B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,OAAAA,QAAO,cAAA;AAAA,MAAc;AAAA,IAE3B;AACA,UAAM,kBAAkB,YAAYA,QAAO,OAAO;AAAA,EACpD;AAQA,QAAM,QAAQ,CAAC,eAAuC;AAAA,IACpD,QAAQ,CAAC,SAAS,OAAO,WAAW,IAAI;AAAA,IACxC,KAAK,CAAC,UAAU,IAAI,WAAW,KAAK;AAAA,IACpC,MAAM,CAAC,UAAU,KAAK,WAAW,KAAK;AAAA,EAAA;AAUxC,QAAM,gBAAgB,CAAC,YAAkC,SAAgB;AACvE,QAAI,MAAM,QAAQ,CAAC;AACnB,UAAM,SAAS,CAAA;AACf,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,aAAO,KAAK,KAAK,CAAC,CAAC;AACnB,aAAO,IAAI,IAAI,CAAC,GAAG,QAAQ,IAAI,CAAC,CAAC;AAAA,IACnC;AACA,WAAO,EAAE,KAAK,OAAA;AAAA,EAChB;AAUA,QAAM,OAAO,OACX,YACG,SACgC;AACnC,UAAM,EAAE,KAAK,OAAA,IAAW,cAAc,SAAS,GAAG,IAAI;AACtD,QAAI;AACF,YAAM,SAAS,MAAM,WAAW,cAAc,KAAK,MAAM;AACzD,aAAO,eAAe,OAAO,eAAe;AAAA,IAC9C,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,gCAAgC;AAAA,QACtD;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAUA,QAAM,SAAS,OACb,YACG,SACqC;AACxC,UAAM,EAAE,KAAK,OAAA,IAAW,cAAc,SAAS,GAAG,IAAI;AACtD,QAAI;AACF,YAAM,SAAS,MAAM,WAAW,cAAc,KAAK,MAAM;AACzD,YAAM,OAAO,OAAO,cAAA;AACpB,aAAO,KAAK,CAAC,IAAI,eAAe,KAAK,CAAC,CAAC,IAAI;AAAA,IAC7C,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,kCAAkC;AAAA,QACxD;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAUA,QAAM,QAAQ,OACZ,YACG,SACc;AACjB,UAAM,EAAE,KAAK,OAAA,IAAW,cAAc,SAAS,GAAG,IAAI;AACtD,QAAI;AACF,YAAM,SAAS,MAAM,WAAW,cAAc,KAAK,MAAM;AACzD,YAAM,OAAO,OAAO,cAAA;AACpB,UAAI,KAAK,WAAW,EAAG,QAAO;AAC9B,YAAM,WAAW,KAAK,CAAC;AACvB,YAAM,WAAW,OAAO,KAAK,QAAQ,EAAE,CAAC;AACxC,aAAO,eAAe,SAAS,QAAQ,CAAC;AAAA,IAC1C,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,iCAAiC;AAAA,QACvD;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAUA,QAAM,UAAU,OACd,YACG,SACe;AAClB,UAAM,EAAE,KAAK,OAAA,IAAW,cAAc,SAAS,GAAG,IAAI;AACtD,QAAI;AACF,YAAM,WAAW,IAAI,KAAK,MAAM;AAAA,IAClC,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,2BAA2B;AAAA,QACjD;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAUA,QAAM,QAAQ,OAAO,QAAgB,WAAkB;AACrD,UAAM,MAAM;AACZ,UAAM,OAAO,MAAM,QAAQ,OAAO,CAAC,CAAC,IAAI,OAAO,CAAC,IAAI;AAEpD,QAAI;AACF,YAAM,SAAS,MAAM,WAAW,cAAc,KAAK,IAAI;AACvD,YAAM,OAAO,eAAe,OAAO,cAAA,CAAe;AAElD,aAAO;AAAA,QACL,SAAS,IAAI,MAAM,GAAG,EAAE,CAAC,EAAE,YAAA;AAAA,QAC3B,UAAU,KAAK;AAAA,QACf,KAAK;AAAA,QACL,QAAQ,KAAK,SAAS,IAClB,OAAO,KAAK,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,UAAU;AAAA,UAClC;AAAA,UACA,SAAS;AAAA,UACT,UAAU;AAAA,UACV,YAAY;AAAA,UACZ,cAAc;AAAA,UACd,kBAAkB;AAAA,UAClB,QAAQ;AAAA,QAAA,EACR,IACF,CAAA;AAAA,QACJ;AAAA,MAAA;AAAA,IAEJ,SAAS,GAAG;AACV,YAAM,IAAI,cAAc,+BAA+B;AAAA,QACrD;AAAA,QACA;AAAA,QACA,eAAe,aAAa,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,MAAA,CACzD;AAAA,IACH;AAAA,EACF;AAGA,QAAM,KAAK;AACX,QAAM,KAAK;AACX,QAAM,KAAK;AACX,QAAM,KAAK;AAWX,QAAM,aAAa,OAAO,WAAkC;AAC1D,UAAM,WAAW,OACd,KAAA,EACA,MAAM,GAAG,EACT,OAAO,CAAC,YAAY,QAAQ,KAAA,MAAW,EAAE;AAE5C,eAAW,WAAW,UAAU;AAC9B,YAAM,iBAAiB,QAAQ,KAAA,EAAO,YAAA;AAGtC,UAAI,eAAe,WAAW,gBAAgB,GAAG;AAC/C,gBAAQ,KAAK,oFAAoF;AACjG;AAAA,MACF;AAEA,UAAI;AACF,cAAM,WAAW,IAAI,OAAO;AAAA,MAC9B,SAAS,GAAG;AAEV,gBAAQ,MAAM,sBAAsB,CAAC;AAAA,MACvC;AAAA,IACF;AAAA,EACF;AASA,QAAM,oBAAoB,OACxBG,aACkB;AAClB,UAAM,gBAAgB,IAAI,sBAAA;AAC1B,UAAM,YAA+B;AAAA,MACnC,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAGF,UAAM,cAAc,kBAAkB,WAAWA,QAAO;AAAA,EAC1D;AASA,QAAM,cAAc,OAClB,aACe;AACf,QAAI;AACF,YAAM,WAAW,IAAI,mBAAmB;AAGxC,YAAM,OAA0B;AAAA,QAC9B,QAAQ;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAGF,YAAM,SAAS,MAAM,SAAS,IAAI;AAClC,YAAM,WAAW,IAAI,QAAQ;AAC7B,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,WAAW,IAAI,UAAU;AAC/B,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AAAA,IACL,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,EAAA;AAEJ;"}