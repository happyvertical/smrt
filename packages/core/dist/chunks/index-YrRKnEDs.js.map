{"version":3,"file":"index-YrRKnEDs.js","sources":["../../src/schema/generator.ts"],"sourcesContent":["/**\n * Schema generator for SMRT objects\n * Converts AST field definitions to database schema definitions\n */\n\nimport type { FieldDefinition, SmartObjectDefinition } from '../scanner/types';\nimport type {\n  SchemaDefinition,\n  ColumnDefinition,\n  IndexDefinition,\n  TriggerDefinition,\n  SQLDataType,\n  ForeignKeyDefinition,\n} from './types';\nimport { createHash } from 'crypto';\n\nexport class SchemaGenerator {\n  /**\n   * Generate schema definition from SMRT object definition\n   */\n  generateSchema(objectDef: SmartObjectDefinition): SchemaDefinition {\n    const tableName = this.getTableName(objectDef);\n    const columns = this.generateColumns(objectDef.fields);\n    const indexes = this.generateIndexes(objectDef, columns);\n    const triggers = this.generateTriggers(objectDef, tableName);\n    const foreignKeys = this.extractForeignKeys(columns);\n    const dependencies = this.extractDependencies(objectDef, foreignKeys);\n    const version = this.generateVersion(objectDef);\n\n    return {\n      tableName,\n      columns,\n      indexes,\n      triggers,\n      foreignKeys,\n      dependencies,\n      version,\n      packageName: this.extractPackageName(objectDef.filePath),\n      baseClass: objectDef.extends,\n    };\n  }\n\n  /**\n   * Convert field type to SQL data type\n   */\n  private mapFieldTypeToSQL(fieldType: FieldDefinition['type']): SQLDataType {\n    switch (fieldType) {\n      case 'text':\n        return 'TEXT';\n      case 'integer':\n        return 'INTEGER';\n      case 'decimal':\n        return 'REAL';\n      case 'boolean':\n        return 'BOOLEAN';\n      case 'datetime':\n        return 'DATETIME';\n      case 'json':\n        return 'JSON';\n      case 'foreignKey':\n        return 'TEXT'; // Foreign keys are typically TEXT\n      default:\n        return 'TEXT'; // Default fallback\n    }\n  }\n\n  /**\n   * Generate column definitions\n   */\n  private generateColumns(\n    fields: Record<string, FieldDefinition>,\n  ): Record<string, ColumnDefinition> {\n    const columns: Record<string, ColumnDefinition> = {};\n\n    // Always include base SMRT fields\n    columns.id = {\n      type: 'TEXT',\n      primaryKey: true,\n      notNull: true,\n      description: 'Primary identifier',\n    };\n\n    columns.created_at = {\n      type: 'DATETIME',\n      notNull: true,\n      defaultValue: \"datetime('now')\",\n      description: 'Creation timestamp',\n    };\n\n    columns.updated_at = {\n      type: 'DATETIME',\n      notNull: true,\n      defaultValue: \"datetime('now')\",\n      description: 'Last update timestamp',\n    };\n\n    // Add fields from object definition\n    for (const [fieldName, fieldDef] of Object.entries(fields)) {\n      // Skip id fields as we handle them above\n      if (\n        fieldName === 'id' ||\n        fieldName === 'created_at' ||\n        fieldName === 'updated_at'\n      ) {\n        continue;\n      }\n\n      const column: ColumnDefinition = {\n        type: this.mapFieldTypeToSQL(fieldDef.type),\n        notNull: fieldDef.required || false,\n        description: fieldDef.description,\n      };\n\n      // Handle default values\n      if (fieldDef.default !== undefined) {\n        column.defaultValue = fieldDef.default;\n      } else if (!fieldDef.required && this.mapFieldTypeToSQL(fieldDef.type) === 'TEXT') {\n        // For TEXT columns without explicit default or required constraint,\n        // add NOT NULL DEFAULT '' to prevent DuckDB ANY type inference\n        // DuckDB infers ANY type for nullable TEXT columns without defaults\n        column.notNull = true;\n        column.defaultValue = '';\n      }\n\n      // Handle foreign keys\n      if (fieldDef.type === 'foreignKey' && fieldDef.related) {\n        const [table, column_name = 'id'] = fieldDef.related.split('.');\n        column.foreignKey = {\n          table,\n          column: column_name,\n          onDelete: 'CASCADE', // Default behavior\n          onUpdate: 'CASCADE',\n        };\n      }\n\n      // Handle unique constraints\n      if (fieldName === 'slug' || fieldName === 'email') {\n        column.unique = true;\n      }\n\n      columns[fieldName] = column;\n    }\n\n    return columns;\n  }\n\n  /**\n   * Generate index definitions\n   */\n  private generateIndexes(\n    objectDef: SmartObjectDefinition,\n    columns: Record<string, ColumnDefinition>,\n  ): IndexDefinition[] {\n    const indexes: IndexDefinition[] = [];\n    const tableName = this.getTableName(objectDef);\n\n    // Create indexes for foreign keys\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      if (columnDef.foreignKey) {\n        indexes.push({\n          name: `idx_${tableName}_${columnName}`,\n          columns: [columnName],\n          description: `Index for foreign key ${columnName}`,\n        });\n      }\n    }\n\n    // Create index for updated_at (common query pattern)\n    indexes.push({\n      name: `idx_${tableName}_updated_at`,\n      columns: ['updated_at'],\n      description: 'Index for timestamp queries',\n    });\n\n    // Create unique indexes\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      if (columnDef.unique && !columnDef.primaryKey) {\n        indexes.push({\n          name: `idx_${tableName}_${columnName}_unique`,\n          columns: [columnName],\n          unique: true,\n          description: `Unique index for ${columnName}`,\n        });\n      }\n    }\n\n    return indexes;\n  }\n\n  /**\n   * Generate trigger definitions for automatic timestamp updates\n   */\n  private generateTriggers(\n    objectDef: SmartObjectDefinition,\n    tableName: string,\n  ): TriggerDefinition[] {\n    return [\n      {\n        name: `trg_${tableName}_updated_at`,\n        when: 'BEFORE',\n        event: 'UPDATE',\n        body: `UPDATE ${tableName} SET updated_at = datetime('now') WHERE id = NEW.id;`,\n        description: 'Automatically update updated_at timestamp',\n      },\n    ];\n  }\n\n  /**\n   * Extract foreign key definitions\n   */\n  private extractForeignKeys(\n    columns: Record<string, ColumnDefinition>,\n  ): ForeignKeyDefinition[] {\n    const foreignKeys: ForeignKeyDefinition[] = [];\n\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      if (columnDef.foreignKey) {\n        foreignKeys.push({\n          column: columnName,\n          referencesTable: columnDef.foreignKey.table,\n          referencesColumn: columnDef.foreignKey.column,\n          onDelete: columnDef.foreignKey.onDelete,\n          onUpdate: columnDef.foreignKey.onUpdate,\n        });\n      }\n    }\n\n    return foreignKeys;\n  }\n\n  /**\n   * Extract schema dependencies from foreign keys and inheritance\n   */\n  private extractDependencies(\n    objectDef: SmartObjectDefinition,\n    foreignKeys: ForeignKeyDefinition[],\n  ): string[] {\n    const dependencies = new Set<string>();\n\n    // Add dependencies from foreign keys\n    for (const fk of foreignKeys) {\n      dependencies.add(fk.referencesTable);\n    }\n\n    // Add dependencies from base class\n    if (\n      objectDef.extends &&\n      objectDef.extends !== 'SmrtObject' &&\n      objectDef.extends !== 'SmrtCollection'\n    ) {\n      dependencies.add(this.classNameToTableName(objectDef.extends));\n    }\n\n    return Array.from(dependencies);\n  }\n\n  /**\n   * Generate version hash for schema\n   */\n  private generateVersion(objectDef: SmartObjectDefinition): string {\n    const content = JSON.stringify({\n      className: objectDef.className,\n      fields: objectDef.fields,\n      extends: objectDef.extends,\n    });\n    return createHash('sha256').update(content).digest('hex').substring(0, 8);\n  }\n\n  /**\n   * Get table name from object definition\n   */\n  private getTableName(objectDef: SmartObjectDefinition): string {\n    return this.classNameToTableName(objectDef.className);\n  }\n\n  /**\n   * Convert class name to table name (camelCase to snake_case, pluralized)\n   */\n  private classNameToTableName(className: string): string {\n    return (\n      className\n        .replace(/([A-Z])/g, '_$1')\n        .toLowerCase()\n        .replace(/^_/, '')\n        .replace(/s$/, '') + 's'\n    ); // Simple pluralization\n  }\n\n  /**\n   * Extract package name from file path\n   */\n  private extractPackageName(filePath: string): string {\n    const match = filePath.match(/packages\\/([^/]+)/);\n    return match ? match[1] : 'unknown';\n  }\n}\n"],"names":[],"mappings":";AAgBO,MAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA,EAI3B,eAAe,WAAoD;AACjE,UAAM,YAAY,KAAK,aAAa,SAAS;AAC7C,UAAM,UAAU,KAAK,gBAAgB,UAAU,MAAM;AACrD,UAAM,UAAU,KAAK,gBAAgB,WAAW,OAAO;AACvD,UAAM,WAAW,KAAK,iBAAiB,WAAW,SAAS;AAC3D,UAAM,cAAc,KAAK,mBAAmB,OAAO;AACnD,UAAM,eAAe,KAAK,oBAAoB,WAAW,WAAW;AACpE,UAAM,UAAU,KAAK,gBAAgB,SAAS;AAE9C,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,KAAK,mBAAmB,UAAU,QAAQ;AAAA,MACvD,WAAW,UAAU;AAAA,IAAA;AAAA,EAEzB;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,WAAiD;AACzE,YAAQ,WAAA;AAAA,MACN,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA;AAAA,MACT;AACE,eAAO;AAAA,IAAA;AAAA,EAEb;AAAA;AAAA;AAAA;AAAA,EAKQ,gBACN,QACkC;AAClC,UAAM,UAA4C,CAAA;AAGlD,YAAQ,KAAK;AAAA,MACX,MAAM;AAAA,MACN,YAAY;AAAA,MACZ,SAAS;AAAA,MACT,aAAa;AAAA,IAAA;AAGf,YAAQ,aAAa;AAAA,MACnB,MAAM;AAAA,MACN,SAAS;AAAA,MACT,cAAc;AAAA,MACd,aAAa;AAAA,IAAA;AAGf,YAAQ,aAAa;AAAA,MACnB,MAAM;AAAA,MACN,SAAS;AAAA,MACT,cAAc;AAAA,MACd,aAAa;AAAA,IAAA;AAIf,eAAW,CAAC,WAAW,QAAQ,KAAK,OAAO,QAAQ,MAAM,GAAG;AAE1D,UACE,cAAc,QACd,cAAc,gBACd,cAAc,cACd;AACA;AAAA,MACF;AAEA,YAAM,SAA2B;AAAA,QAC/B,MAAM,KAAK,kBAAkB,SAAS,IAAI;AAAA,QAC1C,SAAS,SAAS,YAAY;AAAA,QAC9B,aAAa,SAAS;AAAA,MAAA;AAIxB,UAAI,SAAS,YAAY,QAAW;AAClC,eAAO,eAAe,SAAS;AAAA,MACjC,WAAW,CAAC,SAAS,YAAY,KAAK,kBAAkB,SAAS,IAAI,MAAM,QAAQ;AAIjF,eAAO,UAAU;AACjB,eAAO,eAAe;AAAA,MACxB;AAGA,UAAI,SAAS,SAAS,gBAAgB,SAAS,SAAS;AACtD,cAAM,CAAC,OAAO,cAAc,IAAI,IAAI,SAAS,QAAQ,MAAM,GAAG;AAC9D,eAAO,aAAa;AAAA,UAClB;AAAA,UACA,QAAQ;AAAA,UACR,UAAU;AAAA;AAAA,UACV,UAAU;AAAA,QAAA;AAAA,MAEd;AAGA,UAAI,cAAc,UAAU,cAAc,SAAS;AACjD,eAAO,SAAS;AAAA,MAClB;AAEA,cAAQ,SAAS,IAAI;AAAA,IACvB;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,gBACN,WACA,SACmB;AACnB,UAAM,UAA6B,CAAA;AACnC,UAAM,YAAY,KAAK,aAAa,SAAS;AAG7C,eAAW,CAAC,YAAY,SAAS,KAAK,OAAO,QAAQ,OAAO,GAAG;AAC7D,UAAI,UAAU,YAAY;AACxB,gBAAQ,KAAK;AAAA,UACX,MAAM,OAAO,SAAS,IAAI,UAAU;AAAA,UACpC,SAAS,CAAC,UAAU;AAAA,UACpB,aAAa,yBAAyB,UAAU;AAAA,QAAA,CACjD;AAAA,MACH;AAAA,IACF;AAGA,YAAQ,KAAK;AAAA,MACX,MAAM,OAAO,SAAS;AAAA,MACtB,SAAS,CAAC,YAAY;AAAA,MACtB,aAAa;AAAA,IAAA,CACd;AAGD,eAAW,CAAC,YAAY,SAAS,KAAK,OAAO,QAAQ,OAAO,GAAG;AAC7D,UAAI,UAAU,UAAU,CAAC,UAAU,YAAY;AAC7C,gBAAQ,KAAK;AAAA,UACX,MAAM,OAAO,SAAS,IAAI,UAAU;AAAA,UACpC,SAAS,CAAC,UAAU;AAAA,UACpB,QAAQ;AAAA,UACR,aAAa,oBAAoB,UAAU;AAAA,QAAA,CAC5C;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,iBACN,WACA,WACqB;AACrB,WAAO;AAAA,MACL;AAAA,QACE,MAAM,OAAO,SAAS;AAAA,QACtB,MAAM;AAAA,QACN,OAAO;AAAA,QACP,MAAM,UAAU,SAAS;AAAA,QACzB,aAAa;AAAA,MAAA;AAAA,IACf;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA,EAKQ,mBACN,SACwB;AACxB,UAAM,cAAsC,CAAA;AAE5C,eAAW,CAAC,YAAY,SAAS,KAAK,OAAO,QAAQ,OAAO,GAAG;AAC7D,UAAI,UAAU,YAAY;AACxB,oBAAY,KAAK;AAAA,UACf,QAAQ;AAAA,UACR,iBAAiB,UAAU,WAAW;AAAA,UACtC,kBAAkB,UAAU,WAAW;AAAA,UACvC,UAAU,UAAU,WAAW;AAAA,UAC/B,UAAU,UAAU,WAAW;AAAA,QAAA,CAChC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,oBACN,WACA,aACU;AACV,UAAM,mCAAmB,IAAA;AAGzB,eAAW,MAAM,aAAa;AAC5B,mBAAa,IAAI,GAAG,eAAe;AAAA,IACrC;AAGA,QACE,UAAU,WACV,UAAU,YAAY,gBACtB,UAAU,YAAY,kBACtB;AACA,mBAAa,IAAI,KAAK,qBAAqB,UAAU,OAAO,CAAC;AAAA,IAC/D;AAEA,WAAO,MAAM,KAAK,YAAY;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKQ,gBAAgB,WAA0C;AAChE,UAAM,UAAU,KAAK,UAAU;AAAA,MAC7B,WAAW,UAAU;AAAA,MACrB,QAAQ,UAAU;AAAA,MAClB,SAAS,UAAU;AAAA,IAAA,CACpB;AACD,WAAO,WAAW,QAAQ,EAAE,OAAO,OAAO,EAAE,OAAO,KAAK,EAAE,UAAU,GAAG,CAAC;AAAA,EAC1E;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,WAA0C;AAC7D,WAAO,KAAK,qBAAqB,UAAU,SAAS;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKQ,qBAAqB,WAA2B;AACtD,WACE,UACG,QAAQ,YAAY,KAAK,EACzB,YAAA,EACA,QAAQ,MAAM,EAAE,EAChB,QAAQ,MAAM,EAAE,IAAI;AAAA,EAE3B;AAAA;AAAA;AAAA;AAAA,EAKQ,mBAAmB,UAA0B;AACnD,UAAM,QAAQ,SAAS,MAAM,mBAAmB;AAChD,WAAO,QAAQ,MAAM,CAAC,IAAI;AAAA,EAC5B;AACF;"}