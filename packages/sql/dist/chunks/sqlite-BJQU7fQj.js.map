{"version":3,"file":"sqlite-BJQU7fQj.js","sources":["../../src/sqlite.ts"],"sourcesContent":["import { DatabaseError } from '@have/utils';\nimport type { Client } from '@libsql/client';\nimport type {\n  DatabaseInterface,\n  QueryResult,\n  TableInterface,\n  SchemaInitializationOptions,\n} from './shared/types';\nimport { buildWhere } from './shared/utils';\nimport { DatabaseSchemaManager } from './schema-manager';\n\n/**\n * Creates a LibSQL client using the default client implementation\n * Supports in-memory databases and remote LibSQL URLs\n *\n * @param options - SQLite connection options\n * @returns Promise resolving to a LibSQL client instance\n */\nasync function createLibSQLClient(options: SqliteOptions): Promise<Client> {\n  const { url = ':memory:', authToken, encryptionKey } = options;\n\n  // Normalize URLs: add file:// prefix for local paths\n  let libsqlUrl = url;\n  if (\n    url !== ':memory:' &&\n    !url.startsWith('http://') &&\n    !url.startsWith('https://') &&\n    !url.startsWith('libsql://') &&\n    !url.startsWith('file:')\n  ) {\n    // Local file path - resolve to absolute and add file:// prefix\n    const { resolve } = await import('node:path');\n    const absolutePath = resolve(url);\n    // Use file:// format (file URL scheme with authority component omitted)\n    libsqlUrl = `file://${absolutePath}`;\n  }\n\n  try {\n    // Use explicit external import to avoid bundling\n    const libsqlClient = '@libsql/client';\n    const { createClient } = await import(/* @vite-ignore */ libsqlClient);\n    return createClient({ url: libsqlUrl, authToken, encryptionKey });\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    // Provide helpful error messages for common issues\n    if (errorMessage?.includes('URL_SCHEME_NOT_SUPPORTED')) {\n      throw new DatabaseError(\n        `Unsupported URL scheme. Use ':memory:' for in-memory databases or 'libsql://' for remote LibSQL databases. Original: ${url}, Converted: ${libsqlUrl}`,\n        { url: libsqlUrl, originalError: errorMessage },\n      );\n    }\n\n    // Re-throw other errors with context\n    throw new DatabaseError(`Failed to create LibSQL client: ${errorMessage}`, {\n      url: libsqlUrl,\n      originalError: errorMessage,\n    });\n  }\n}\n\n/**\n * Configuration options for SQLite database connections\n */\nexport interface SqliteOptions {\n  /**\n   * Connection URL for SQLite database\n   * Supported schemes:\n   * - ':memory:' for in-memory databases\n   * - 'file:path/to/database.db' for local file databases\n   * - 'libsql://...' for remote LibSQL/Turso databases\n   */\n  url?: string;\n\n  /**\n   * Authentication token for Turso/LibSQL remote connections\n   */\n  authToken?: string;\n\n  /**\n   * Encryption key for encrypted SQLite databases (LibSQL feature)\n   */\n  encryptionKey?: string;\n}\n\n/**\n * Creates a SQLite database adapter\n *\n * @param options - SQLite connection options\n * @returns Database interface for SQLite\n */\nexport async function getDatabase(\n  options: SqliteOptions = {},\n): Promise<DatabaseInterface> {\n  const client = await createLibSQLClient(options);\n\n  /**\n   * Inserts one or more records into a table\n   *\n   * @param table - Table name\n   * @param data - Single record or array of records to insert\n   * @returns Promise resolving to operation result\n   * @throws Error if the insert operation fails\n   */\n  const insert = async (\n    table: string,\n    data: Record<string, any> | Record<string, any>[],\n  ): Promise<QueryResult> => {\n    let sql: string;\n    let values: any[];\n\n    if (Array.isArray(data)) {\n      const keys = Object.keys(data[0]);\n      const placeholders = data\n        .map(() => `(${keys.map(() => '?').join(', ')})`)\n        .join(', ');\n      sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES ${placeholders}`;\n      values = data.reduce(\n        (acc, row) => acc.concat(Object.values(row)),\n        [] as any[],\n      );\n    } else {\n      const keys = Object.keys(data);\n      const placeholders = keys.map(() => '?').join(', ');\n      sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders})`;\n      values = Object.values(data);\n    }\n    try {\n      const result = await client.execute({ sql: sql, args: values });\n      return { operation: 'insert', affected: result.rowsAffected };\n    } catch (e) {\n      throw new DatabaseError('Failed to insert records into table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Retrieves a single record matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to matching record or null if not found\n   * @throws Error if the query fails\n   */\n  const get = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any> | null> => {\n    const keys = Object.keys(where);\n    const values = Object.values(where);\n    const whereClause = keys.map((key) => `${key} = ?`).join(' AND ');\n    const sql = `SELECT * FROM ${table} WHERE ${whereClause}`;\n    try {\n      const result = await client.execute({ sql: sql, args: values });\n      return result.rows[0] || null;\n    } catch (e) {\n      throw new DatabaseError('Failed to retrieve record from table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Retrieves multiple records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to array of matching records\n   * @throws Error if the query fails\n   */\n  const list = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any>[]> => {\n    const { sql: whereClause, values } = buildWhere(where);\n    const sql = `SELECT * FROM ${table} ${whereClause}`;\n    try {\n      const result = await client.execute({ sql, args: values });\n      return result.rows;\n    } catch (e) {\n      throw new DatabaseError('Failed to list records from table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Updates records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records to update\n   * @param data - New data to set\n   * @returns Promise resolving to operation result\n   * @throws Error if the update operation fails\n   */\n  const update = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<QueryResult> => {\n    const keys = Object.keys(data);\n    const values = Object.values(data);\n    const setClause = keys.map((key) => `${key} = ?`).join(', ');\n    const whereKeys = Object.keys(where);\n    const whereValues = Object.values(where);\n    const whereClause = whereKeys.map((key) => `${key} = ?`).join(' AND ');\n\n    const sql = `UPDATE ${table} SET ${setClause} WHERE ${whereClause}`;\n    try {\n      const result = await client.execute({\n        sql,\n        args: [...values, ...whereValues],\n      });\n      return { operation: 'update', affected: result.rowsAffected };\n    } catch (e) {\n      throw new DatabaseError('Failed to update records in table', {\n        table,\n        sql,\n        values: [...values, ...whereValues],\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Inserts a record or updates it if it already exists (UPSERT)\n   *\n   * @param table - Table name\n   * @param conflictColumns - Columns that define the uniqueness constraint\n   * @param data - Data to insert or update\n   * @returns Promise resolving to operation result\n   * @throws Error if the upsert operation fails\n   */\n  const upsert = async (\n    table: string,\n    conflictColumns: string[],\n    data: Record<string, any>,\n  ): Promise<QueryResult> => {\n    const keys = Object.keys(data);\n    const values = Object.values(data);\n    const placeholders = keys.map(() => '?').join(', ');\n    const updateSet = keys\n      .map((key) => `${key} = excluded.${key}`)\n      .join(', ');\n    const conflict = conflictColumns.join(', ');\n\n    const sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders}) ON CONFLICT(${conflict}) DO UPDATE SET ${updateSet}`;\n\n    try {\n      const result = await client.execute({ sql, args: values });\n      return { operation: 'upsert', affected: result.rowsAffected };\n    } catch (e) {\n      throw new DatabaseError('Failed to upsert record into table', {\n        table,\n        sql,\n        values,\n        conflictColumns,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Gets a record matching the where criteria or inserts it if not found\n   *\n   * @param table - Table name\n   * @param where - Criteria to match existing record\n   * @param data - Data to insert if no record found\n   * @returns Promise resolving to the record (either retrieved or newly inserted)\n   * @throws Error if the operation fails or if the record cannot be retrieved after insert\n   */\n  const getOrInsert = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<Record<string, any>> => {\n    const result = await get(table, where);\n    if (result) return result;\n    await insert(table, data);\n\n    const inserted = await get(table, where);\n    if (!inserted) {\n      throw new DatabaseError('Failed to insert and retrieve record', {\n        table,\n        where,\n        data,\n      });\n    }\n    return inserted;\n  };\n\n  /**\n   * Checks if a table exists in the database\n   *\n   * @param tableName - Name of the table to check\n   * @returns Promise resolving to boolean indicating if the table exists\n   */\n  const tableExists = async (tableName: string): Promise<boolean> => {\n    const tableExists =\n      !!(await pluck`SELECT name FROM sqlite_master WHERE type='table' AND name=${tableName}`);\n    return tableExists;\n  };\n\n  /**\n   * Synchronizes database schema with provided SQL DDL\n   * Creates tables if they don't exist and adds missing columns\n   *\n   * @param schema - SQL schema definition with CREATE TABLE statements\n   * @returns Promise that resolves when schema is synchronized\n   */\n  const syncSchema = async (schema: string): Promise<void> => {\n    const commands = schema\n      .trim()\n      .split(';')\n      .filter((command) => command.trim() !== '');\n\n    for (const command of commands) {\n      const createTableRegex =\n        /CREATE TABLE (IF NOT EXISTS )?(\\w+) \\(([\\s\\S]+)\\)/i;\n      const match = command.match(createTableRegex);\n\n      if (match) {\n        const tableName = match[2];\n        const columns = match[3].trim().split(',\\n');\n\n        // Check if table exists\n        const exists = await tableExists(tableName);\n\n        if (!exists) {\n          // Table doesn't exist, create it\n          await client.execute({ sql: command });\n        } else {\n          // Table exists, check for missing columns\n          for (const column of columns) {\n            const columnDef = column.trim();\n            const columnMatch = columnDef.match(/(\\w+)\\s+(\\w+[^,]*)/);\n\n            if (columnMatch) {\n              const columnName = columnMatch[1];\n\n              // Skip constraint definitions\n              if (\n                columnName.toUpperCase() === 'PRIMARY' ||\n                columnName.toUpperCase() === 'FOREIGN' ||\n                columnName.toUpperCase() === 'UNIQUE' ||\n                columnName.toUpperCase() === 'CHECK' ||\n                columnName.toUpperCase() === 'CONSTRAINT'\n              ) {\n                continue;\n              }\n\n              try {\n                // Check if column exists using pragma_table_info\n                const columnInfo = await single`\n                  SELECT *\n                  FROM pragma_table_info(${tableName})\n                  WHERE name = ${columnName}\n                `;\n\n                if (!columnInfo) {\n                  // Column doesn't exist, add it\n                  const alterCommand = `ALTER TABLE ${tableName} ADD COLUMN ${columnDef}`;\n                  await client.execute({ sql: alterCommand });\n                }\n              } catch (_error) {\n                // If there's an error checking/adding the column, try alternate method\n                try {\n                  const alterCommand = `ALTER TABLE ${tableName} ADD COLUMN ${columnDef}`;\n                  await client.execute({ sql: alterCommand });\n                } catch (alterError) {\n                  // Column might already exist, continue\n                  console.error(\n                    `Error adding column ${columnName} to ${tableName}:`,\n                    alterError,\n                  );\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Executes a callback within a database transaction\n   * Automatically commits on success or rolls back on error\n   *\n   * @param callback - Function to execute within transaction\n   * @returns Promise resolving to callback result\n   */\n  const transaction = async <T>(\n    callback: (tx: DatabaseInterface) => Promise<T>,\n  ): Promise<T> => {\n    try {\n      await client.execute({ sql: 'BEGIN TRANSACTION' });\n\n      // Create a transaction-scoped database interface\n      // SQLite doesn't have separate transaction clients, so we reuse the same client\n      const txDb: DatabaseInterface = {\n        client,\n        insert,\n        get,\n        list,\n        update,\n        upsert,\n        getOrInsert,\n        table,\n        many,\n        single,\n        pluck,\n        execute,\n        query,\n        oo: many,\n        oO: single,\n        ox: pluck,\n        xx: execute,\n        tableExists,\n        syncSchema,\n        transaction,\n      };\n\n      const result = await callback(txDb);\n      await client.execute({ sql: 'COMMIT' });\n      return result;\n    } catch (error) {\n      await client.execute({ sql: 'ROLLBACK' });\n      throw error;\n    }\n  };\n\n  /**\n   * Creates a table-specific interface for simplified table operations\n   *\n   * @param tableName - Table name\n   * @returns TableInterface for the specified table\n   */\n  const table = (tableName: string): TableInterface => ({\n    insert: (data) => insert(tableName, data),\n    get: (where) => get(tableName, where),\n    list: (where) => list(tableName, where),\n  });\n\n  /**\n   * Parses a tagged template literal into a SQL query and values\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Object with SQL query and values array\n   */\n  const parseTemplate = (strings: TemplateStringsArray, ...vars: any[]) => {\n    let sql = strings[0];\n    const values = [];\n    for (let i = 0; i < vars.length; i++) {\n      values.push(vars[i]);\n      sql += `?${strings[i + 1]}`;\n    }\n    return { sql, values };\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single value\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single value (first column of first row)\n   * @throws Error if the query fails\n   */\n  const pluck = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<any> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const result = await client.execute({ sql, args: values });\n      return result.rows[0]?.[Object.keys(result.rows[0])[0]] ?? null;\n    } catch (e) {\n      throw new DatabaseError('Failed to execute pluck query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single row\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single result record or null\n   * @throws Error if the query fails\n   */\n  const single = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any> | null> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const result = await client.execute({ sql, args: values });\n      return result.rows[0] || null;\n    } catch (e) {\n      throw new DatabaseError('Failed to execute single query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns multiple rows\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to array of result records\n   * @throws Error if the query fails\n   */\n  const many = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any>[]> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const result = await client.execute({ sql, args: values });\n      return result.rows;\n    } catch (e) {\n      throw new DatabaseError('Failed to execute many query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals without returning results\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise that resolves when the query completes\n   * @throws Error if the query fails\n   */\n  const execute = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<void> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      await client.execute({ sql, args: values });\n    } catch (e) {\n      throw new DatabaseError('Failed to execute query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a raw SQL query with parameterized values\n   *\n   * @param str - SQL query string\n   * @param values - Variables to use as parameters\n   * @returns Promise resolving to query result with rows and metadata\n   * @throws Error if the query fails\n   */\n  const query = async (str: string, ...values: any[]) => {\n    const sql = str;\n    const args = Array.isArray(values[0]) ? values[0] : values;\n    try {\n      const result = await client.execute({ sql, args });\n      return {\n        command: sql.split(' ')[0].toUpperCase(),\n        rowCount: result.rowsAffected ?? result.rows.length,\n        oid: null,\n        fields: Object.keys(result.rows[0] || {}).map((name) => ({\n          name,\n          tableID: 0,\n          columnID: 0,\n          dataTypeID: 0,\n          dataTypeSize: -1,\n          dataTypeModifier: -1,\n          format: 'text',\n        })),\n        rows: result.rows,\n      };\n    } catch (e) {\n      throw new DatabaseError('Failed to execute raw query', {\n        sql,\n        args,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  // Shorthand aliases for query methods\n  const oo = many; // (o)bjective-(o)bjects: returns multiple rows\n  const oO = single; // (o)bjective-(O)bject: returns a single row\n  const ox = pluck; // (o)bjective-(x): returns a single value\n  const xx = execute; // (x)ecute-(x)ecute: executes without returning\n\n  /**\n   * Initialize database schemas from JSON manifest\n   * Supports dependency resolution and schema overrides\n   *\n   * @param options - Schema initialization options\n   * @returns Promise that resolves when schemas are initialized\n   */\n  const initializeSchemas = async (\n    options: SchemaInitializationOptions,\n  ): Promise<void> => {\n    const schemaManager = new DatabaseSchemaManager();\n    const currentDb: DatabaseInterface = {\n      client,\n      query,\n      insert,\n      update,\n      upsert,\n      get,\n      list,\n      getOrInsert,\n      table,\n      tableExists,\n      many,\n      single,\n      pluck,\n      execute,\n      oo,\n      oO,\n      ox,\n      xx,\n      syncSchema,\n      transaction,\n    };\n\n    await schemaManager.initializeSchemas(currentDb, options);\n  };\n\n  return {\n    client,\n    query,\n    insert,\n    update,\n    upsert,\n    get,\n    list,\n    getOrInsert,\n    table,\n    tableExists,\n    many,\n    single,\n    pluck,\n    execute,\n    oo,\n    oO,\n    ox,\n    xx,\n    syncSchema,\n    initializeSchemas,\n    transaction,\n  };\n}\n"],"names":["table","tableExists","options"],"mappings":"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"}