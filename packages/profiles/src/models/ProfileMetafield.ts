/**
 * ProfileMetafield model - Controlled vocabulary for metadata fields
 *
 * Defines allowed metadata keys with validation rules.
 * Uses UUID primary key with unique slug for human-readable lookups.
 */

import { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';
import { text, json } from '@smrt/core';
import type { ValidationSchema, ValidatorFunction } from '../types';

export interface ProfileMetafieldOptions extends SmrtObjectOptions {
  slug?: string;
  name?: string;
  description?: string;
  validation?: ValidationSchema;
}

/**
 * Registry of custom validator functions
 */
const customValidators = new Map<string, ValidatorFunction>();

@smrt({
  api: { include: ['list', 'get', 'create', 'update'] },
  mcp: { include: ['list', 'get'] },
  cli: true,
})
export class ProfileMetafield extends SmrtObject {
  // id: UUID (auto-generated by SmrtObject)
  // slug is inherited from SmrtObject (auto-generated from name)
  name = text({ required: true });
  description = text();
  validation = json(); // Validation schema as JSON

  constructor(options: ProfileMetafieldOptions = {}) {
    super(options);
    // Field values are automatically set by initializePropertiesFromOptions()
    // No need to manually assign Field properties here
  }

  /**
   * Convenience method for slug-based lookup
   *
   * @param slug - The slug to search for
   * @returns ProfileMetafield instance or null if not found
   */
  static async getBySlug(slug: string): Promise<ProfileMetafield | null> {
    // Will be auto-implemented by SMRT
    return null;
  }

  /**
   * Register a custom validator function
   *
   * @param name - Name of the validator (used in validation.custom field)
   * @param validator - The validator function
   */
  static registerValidator(name: string, validator: ValidatorFunction): void {
    customValidators.set(name, validator);
  }

  /**
   * Get a registered custom validator
   *
   * @param name - Name of the validator
   * @returns The validator function or undefined
   */
  static getValidator(name: string): ValidatorFunction | undefined {
    return customValidators.get(name);
  }

  /**
   * Validate a value against this metafield's validation schema
   *
   * @param value - The value to validate
   * @returns True if valid, throws ValidationError if invalid
   */
  async validateValue(value: any): Promise<boolean> {
    if (!this.validation) return true;

    const schema = this.validation as ValidationSchema;

    // Type validation
    if (schema.type) {
      const actualType = typeof value;
      const expectedType = schema.type;

      if (expectedType === 'number' && actualType !== 'number') {
        throw new Error(
          schema.message || `Expected ${expectedType}, got ${actualType}`,
        );
      }
      if (expectedType === 'string' && actualType !== 'string') {
        throw new Error(
          schema.message || `Expected ${expectedType}, got ${actualType}`,
        );
      }
      if (expectedType === 'boolean' && actualType !== 'boolean') {
        throw new Error(
          schema.message || `Expected ${expectedType}, got ${actualType}`,
        );
      }
    }

    // String validations
    if (schema.pattern && typeof value === 'string') {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        throw new Error(schema.message || 'Pattern validation failed');
      }
    }

    if (schema.minLength && typeof value === 'string') {
      if (value.length < schema.minLength) {
        throw new Error(
          schema.message ||
            `Minimum length is ${schema.minLength}, got ${value.length}`,
        );
      }
    }

    if (schema.maxLength && typeof value === 'string') {
      if (value.length > schema.maxLength) {
        throw new Error(
          schema.message ||
            `Maximum length is ${schema.maxLength}, got ${value.length}`,
        );
      }
    }

    // Numeric validations
    if (schema.min !== undefined && typeof value === 'number') {
      if (value < schema.min) {
        throw new Error(
          schema.message || `Value must be at least ${schema.min}`,
        );
      }
    }

    if (schema.max !== undefined && typeof value === 'number') {
      if (value > schema.max) {
        throw new Error(
          schema.message || `Value must be at most ${schema.max}`,
        );
      }
    }

    // Custom validator
    if (schema.custom) {
      const validator = ProfileMetafield.getValidator(schema.custom);
      if (!validator) {
        throw new Error(`Custom validator '${schema.custom}' not registered`);
      }

      const result = await validator(value);
      if (!result) {
        throw new Error(schema.message || 'Custom validation failed');
      }
    }

    return true;
  }
}
