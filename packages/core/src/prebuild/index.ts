/**
 * Pre-build utilities for generating TypeScript declarations
 * Solves virtual module resolution by creating physical .d.ts files
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import type { SmartObjectManifest } from '../scanner/types';

export interface PrebuildOptions {
  /** Path to manifest file or manifest object */
  manifest: string | SmartObjectManifest;
  /** Output directory for generated types */
  outDir: string;
  /** Include virtual module declarations */
  includeVirtualModules?: boolean;
  /** Include object type definitions */
  includeObjectTypes?: boolean;
  /** Project root path for resolving relative paths */
  projectRoot?: string;
}

/**
 * Generate TypeScript declaration files from SMRT manifest
 */
export async function generateDeclarations(
  options: PrebuildOptions,
): Promise<void> {
  const {
    manifest: manifestInput,
    outDir,
    includeVirtualModules = true,
    includeObjectTypes = true,
    projectRoot = process.cwd(),
  } = options;

  // Load manifest
  const manifest: SmartObjectManifest =
    typeof manifestInput === 'string'
      ? JSON.parse(fs.readFileSync(manifestInput, 'utf-8'))
      : manifestInput;

  // Ensure output directory exists
  const fullOutDir = path.isAbsolute(outDir)
    ? outDir
    : path.join(projectRoot, outDir);
  fs.mkdirSync(fullOutDir, { recursive: true });

  console.log(`[smrt:prebuild] Generating declarations to ${fullOutDir}`);

  if (includeObjectTypes) {
    await generateObjectTypeDeclarations(manifest, fullOutDir);
  }

  if (includeVirtualModules) {
    await generateVirtualModuleDeclarations(manifest, fullOutDir);
  }

  console.log(
    `[smrt:prebuild] Generated declarations for ${Object.keys(manifest.objects).length} SMRT objects`,
  );
}

/**
 * Generate TypeScript interfaces for SMRT objects
 */
async function generateObjectTypeDeclarations(
  manifest: SmartObjectManifest,
  outDir: string,
): Promise<void> {
  const interfaces: string[] = [];

  // Generate interfaces for each discovered SMRT object
  for (const [_objectName, objectMeta] of Object.entries(manifest.objects)) {
    const fields = objectMeta.fields || {};
    const propertyLines: string[] = [];

    // Add standard SmrtObject properties
    propertyLines.push('  id?: string;');
    propertyLines.push('  created_at?: string;');
    propertyLines.push('  updated_at?: string;');

    // Add object-specific properties
    for (const [fieldName, fieldDef] of Object.entries(fields)) {
      const type = mapFieldTypeToTypeScript(fieldDef.type);
      const optional = !fieldDef.required ? '?' : '';
      propertyLines.push(`  ${fieldName}${optional}: ${type};`);
    }

    const interfaceDef = `export interface ${objectMeta.className}Data {
${propertyLines.join('\n')}
}`;
    interfaces.push(interfaceDef);
  }

  // Write object types file
  const objectTypesContent = `/**
 * Auto-generated TypeScript interfaces for SMRT objects
 * Generated at build time from @smrt() decorated classes
 *
 * DO NOT EDIT THIS FILE MANUALLY
 */

${interfaces.join('\n\n')}
`;

  fs.writeFileSync(path.join(outDir, 'smrt-objects.d.ts'), objectTypesContent);
}

/**
 * Generate virtual module declarations
 */
async function generateVirtualModuleDeclarations(
  manifest: SmartObjectManifest,
  outDir: string,
): Promise<void> {
  // Generate manifest module declaration
  const manifestDeclaration = `/**
 * Auto-generated manifest module declaration
 */
declare module '@smrt/manifest' {
  export interface SmrtObjectField {
    type: string;
    required?: boolean;
    default?: any;
  }

  export interface SmrtObjectMethod {
    name: string;
    parameters: Array<{
      name: string;
      type: string;
      optional?: boolean;
      default?: any;
    }>;
    returnType: string;
    async: boolean;
    isStatic: boolean;
    isPublic: boolean;
  }

  export interface SmrtObjectDefinition {
    name: string;
    className: string;
    collection: string;
    filePath: string;
    fields: Record<string, SmrtObjectField>;
    methods: Record<string, SmrtObjectMethod>;
    decoratorConfig: any;
    extends?: string;
  }

  export interface SmrtManifest {
    version: string;
    timestamp: number;
    objects: Record<string, SmrtObjectDefinition>;
  }

  export const manifest: SmrtManifest;
  export default manifest;
}`;

  // Generate client module declaration
  const collectionNames = [
    ...new Set(Object.values(manifest.objects).map((obj) => obj.collection)),
  ];

  const apiClientInterface = collectionNames
    .map((collection) => {
      const dataType = Object.entries(manifest.objects).find(
        ([, obj]) => obj.collection === collection,
      )?.[1].className;
      const interfaceName = dataType ? `${dataType}Data` : 'any';
      return `    ${collection}: CrudOperations<${interfaceName}>;`;
    })
    .join('\n');

  const clientDeclaration = `/**
 * Auto-generated API client module declaration
 */
declare module '@smrt/client' {
  export interface ApiResponse<T = any> {
    id?: string;
    data?: T;
    error?: string;
    message?: string;
  }

  export interface CrudOperations<T = any> {
    list(params?: Record<string, any>): Promise<ApiResponse<T[]>>;
    get(id: string): Promise<ApiResponse<T>>;
    create(data: Partial<T>): Promise<ApiResponse<T>>;
    update(id: string, data: Partial<T>): Promise<ApiResponse<T>>;
    delete(id: string): Promise<boolean>;
  }

  export interface ApiClient {
${apiClientInterface}
  }

  export function createClient(basePath?: string): ApiClient;
  export default createClient;
}`;

  // Generate routes module declaration
  const routesDeclaration = `/**
 * Auto-generated routes module declaration
 */
declare module '@smrt/routes' {
  export interface RouteApp {
    get(path: string, handler: (req: any, res: any) => void): void;
    post(path: string, handler: (req: any, res: any) => void): void;
    put(path: string, handler: (req: any, res: any) => void): void;
    delete(path: string, handler: (req: any, res: any) => void): void;
  }

  export function setupRoutes(app: RouteApp): void;
  export default setupRoutes;
}`;

  // Generate MCP module declaration
  const mcpDeclaration = `/**
 * Auto-generated MCP module declaration
 */
declare module '@smrt/mcp' {
  export interface McpTool {
    name: string;
    description: string;
    inputSchema: {
      type: string;
      properties: Record<string, any>;
      required?: string[];
    };
  }

  export const tools: McpTool[];
  export function createMCPServer(): {
    name: string;
    version: string;
    tools: McpTool[]
  };
  export default createMCPServer;
}`;

  // Generate types module declaration with object imports
  const objectImports = Object.values(manifest.objects)
    .map(
      (obj) =>
        `  export type ${obj.className}Data = import('./smrt-objects').${obj.className}Data;`,
    )
    .join('\n');

  const typesDeclaration = `/**
 * Auto-generated types module declaration
 */
declare module '@smrt/types' {
${objectImports}

  export interface Request {
    params: Record<string, string>;
    query: Record<string, any>;
    json(): Promise<any>;
  }

  export interface Response {
    json(data: any, init?: { status?: number }): Response;
    status(code: number): Response;
  }
}`;

  // Write all virtual module declarations
  fs.writeFileSync(
    path.join(outDir, 'smrt-manifest.d.ts'),
    manifestDeclaration,
  );
  fs.writeFileSync(path.join(outDir, 'smrt-client.d.ts'), clientDeclaration);
  fs.writeFileSync(path.join(outDir, 'smrt-routes.d.ts'), routesDeclaration);
  fs.writeFileSync(path.join(outDir, 'smrt-mcp.d.ts'), mcpDeclaration);
  fs.writeFileSync(path.join(outDir, 'smrt-types.d.ts'), typesDeclaration);
}

/**
 * Map SMRT field types to TypeScript types
 */
function mapFieldTypeToTypeScript(smrtType: string): string {
  switch (smrtType) {
    case 'text':
      return 'string';
    case 'decimal':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'datetime':
      return 'string | Date';
    case 'json':
      return 'any';
    case 'foreignKey':
      return 'string';
    default:
      return 'any';
  }
}

/**
 * CLI command for generating declarations
 */
export async function generateDeclarationsFromCLI(
  args: string[],
): Promise<void> {
  const manifestPath = args[0];
  const outDir = args[1] || 'src/types/generated';

  if (!manifestPath) {
    console.error('Usage: generate-declarations <manifest-path> [output-dir]');
    process.exit(1);
  }

  if (!fs.existsSync(manifestPath)) {
    console.error(`Manifest file not found: ${manifestPath}`);
    process.exit(1);
  }

  await generateDeclarations({
    manifest: manifestPath,
    outDir,
  });
}
