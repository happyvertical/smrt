{"version":3,"file":"index.js","sources":["../src/models/Account.ts","../src/models/AccountTransaction.ts","../src/models/AccountTransactionEntry.ts","../src/collections/AccountCollection.ts","../src/collections/AccountTransactionCollection.ts","../src/collections/AccountTransactionEntryCollection.ts"],"sourcesContent":["/**\n * Account model - Financial account with hierarchical support\n *\n * Represents a category of economic activity (asset, liability, equity, revenue, expense)\n */\n\nimport { SmrtObject, smrt } from '@smrt/core';\nimport type { AccountOptions, AccountType, CurrencyCode } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class Account extends SmrtObject {\n  // id, slug, name inherited from SmrtObject\n\n  type: AccountType = 'asset';\n  currency: CurrencyCode = 'USD'; // Default to USD, should be set explicitly\n  parentId = ''; // FK to parent Account (nullable for root accounts)\n  description = '';\n  metadata = ''; // JSON metadata (stored as text)\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: AccountOptions = {}) {\n    super(options);\n\n    if (options.type !== undefined) this.type = options.type;\n    if (options.currency !== undefined) this.currency = options.currency;\n    if (options.parentId !== undefined) this.parentId = options.parentId;\n    if (options.description !== undefined)\n      this.description = options.description;\n\n    // Handle metadata - can be object or JSON string\n    if (options.metadata !== undefined) {\n      if (typeof options.metadata === 'string') {\n        this.metadata = options.metadata;\n      } else {\n        this.metadata = JSON.stringify(options.metadata);\n      }\n    }\n\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get metadata as parsed object\n   *\n   * @returns Parsed metadata object or empty object\n   */\n  getMetadata(): Record<string, any> {\n    if (!this.metadata) return {};\n    try {\n      return JSON.parse(this.metadata);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set metadata from object\n   *\n   * @param data - Metadata object to store\n   */\n  setMetadata(data: Record<string, any>): void {\n    this.metadata = JSON.stringify(data);\n  }\n\n  /**\n   * Update metadata by merging with existing values\n   *\n   * @param updates - Partial metadata to merge\n   */\n  updateMetadata(updates: Record<string, any>): void {\n    const current = this.getMetadata();\n    this.setMetadata({ ...current, ...updates });\n  }\n\n  /**\n   * Get the parent account\n   *\n   * @returns Parent Account instance or null\n   */\n  async getParent(): Promise<Account | null> {\n    if (!this.parentId) return null;\n\n    const { AccountCollection } = await import(\n      '../collections/AccountCollection'\n    );\n    const { persistence, db, ai, fs, _className } = this.options;\n    const collection = await AccountCollection.create({\n      persistence,\n      db,\n      ai,\n      fs,\n      _className,\n    });\n\n    return await collection.get({ id: this.parentId });\n  }\n\n  /**\n   * Get immediate child accounts\n   *\n   * @returns Array of child Account instances\n   */\n  async getChildren(): Promise<Account[]> {\n    const { AccountCollection } = await import(\n      '../collections/AccountCollection'\n    );\n    const { persistence, db, ai, fs, _className } = this.options;\n    const collection = await AccountCollection.create({\n      persistence,\n      db,\n      ai,\n      fs,\n      _className,\n    });\n\n    return await collection.list({ where: { parentId: this.id } });\n  }\n\n  /**\n   * Get all ancestor accounts (recursive)\n   *\n   * @returns Array of ancestor accounts from root to immediate parent\n   */\n  async getAncestors(): Promise<Account[]> {\n    const ancestors: Account[] = [];\n    let currentAccount: Account | null = this;\n\n    while (currentAccount && currentAccount.parentId) {\n      const parent = await currentAccount.getParent();\n      if (!parent) break;\n      ancestors.unshift(parent); // Add to beginning\n      currentAccount = parent;\n    }\n\n    return ancestors;\n  }\n\n  /**\n   * Get all descendant accounts (recursive)\n   *\n   * @returns Array of all descendant accounts\n   */\n  async getDescendants(): Promise<Account[]> {\n    const children = await this.getChildren();\n    const descendants: Account[] = [...children];\n\n    for (const child of children) {\n      const childDescendants = await child.getDescendants();\n      descendants.push(...childDescendants);\n    }\n\n    return descendants;\n  }\n\n  /**\n   * Get root account (top-level account with no parent)\n   *\n   * @returns Root account instance\n   */\n  async getRootAccount(): Promise<Account> {\n    const ancestors = await this.getAncestors();\n    return ancestors.length > 0 ? ancestors[0] : this;\n  }\n\n  /**\n   * Get full hierarchy for this account\n   *\n   * @returns Object with ancestors, current, and descendants\n   */\n  async getHierarchy(): Promise<{\n    ancestors: Account[];\n    current: Account;\n    descendants: Account[];\n  }> {\n    const [ancestors, descendants] = await Promise.all([\n      this.getAncestors(),\n      this.getDescendants(),\n    ]);\n\n    return {\n      ancestors,\n      current: this,\n      descendants,\n    };\n  }\n\n  /**\n   * Check if account is a root account (no parent)\n   *\n   * @returns True if parentId is empty\n   */\n  isRoot(): boolean {\n    return !this.parentId;\n  }\n\n  /**\n   * Get the depth of this account in the hierarchy\n   *\n   * @returns Number of ancestors (0 for root accounts)\n   */\n  async getDepth(): Promise<number> {\n    const ancestors = await this.getAncestors();\n    return ancestors.length;\n  }\n\n  /**\n   * Get all transaction entries for this account\n   *\n   * @returns Array of AccountTransactionEntry instances\n   */\n  async getTransactionEntries() {\n    const { AccountTransactionEntryCollection } = await import(\n      '../collections/AccountTransactionEntryCollection'\n    );\n    const { persistence, db, ai, fs, _className } = this.options;\n    const collection = await AccountTransactionEntryCollection.create({\n      persistence,\n      db,\n      ai,\n      fs,\n      _className,\n    });\n\n    return await collection.list({ where: { accountId: this.id } });\n  }\n\n  /**\n   * Calculate the balance for this account\n   * Sum of all transaction entries (debits positive, credits negative)\n   *\n   * @returns Balance in smallest currency unit (e.g., cents)\n   */\n  async getBalance(): Promise<number> {\n    const entries = await this.getTransactionEntries();\n    return entries.reduce((sum, entry) => sum + entry.amount, 0);\n  }\n}\n","/**\n * AccountTransaction model - Financial transaction record\n *\n * Represents a financial event with one or more entries\n */\n\nimport { SmrtObject, smrt } from '@smrt/core';\nimport type { AccountTransactionOptions } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class AccountTransaction extends SmrtObject {\n  // id inherited from SmrtObject\n  // Note: slug and name not typically used for transactions\n\n  date: Date = new Date();\n  description = '';\n  metadata = ''; // JSON metadata (stored as text)\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: AccountTransactionOptions = {}) {\n    super(options);\n\n    if (options.date !== undefined) this.date = options.date;\n    if (options.description !== undefined)\n      this.description = options.description;\n\n    // Handle metadata - can be object or JSON string\n    if (options.metadata !== undefined) {\n      if (typeof options.metadata === 'string') {\n        this.metadata = options.metadata;\n      } else {\n        this.metadata = JSON.stringify(options.metadata);\n      }\n    }\n\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get metadata as parsed object\n   *\n   * @returns Parsed metadata object or empty object\n   */\n  getMetadata(): Record<string, any> {\n    if (!this.metadata) return {};\n    try {\n      return JSON.parse(this.metadata);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set metadata from object\n   *\n   * @param data - Metadata object to store\n   */\n  setMetadata(data: Record<string, any>): void {\n    this.metadata = JSON.stringify(data);\n  }\n\n  /**\n   * Update metadata by merging with existing values\n   *\n   * @param updates - Partial metadata to merge\n   */\n  updateMetadata(updates: Record<string, any>): void {\n    const current = this.getMetadata();\n    this.setMetadata({ ...current, ...updates });\n  }\n\n  /**\n   * Get all entries for this transaction\n   *\n   * @returns Array of AccountTransactionEntry instances\n   */\n  async getEntries() {\n    const { AccountTransactionEntryCollection } = await import(\n      '../collections/AccountTransactionEntryCollection'\n    );\n    const { persistence, db, ai, fs, _className } = this.options;\n    const collection = await AccountTransactionEntryCollection.create({\n      persistence,\n      db,\n      ai,\n      fs,\n      _className,\n    });\n\n    return await collection.list({ where: { transactionId: this.id } });\n  }\n\n  /**\n   * Calculate the total balance of all entries\n   * For balanced transactions, this should be zero\n   *\n   * @returns Sum of all entry amounts (debits positive, credits negative)\n   */\n  async getBalance(): Promise<number> {\n    const entries = await this.getEntries();\n    return entries.reduce((sum, entry) => sum + entry.amount, 0);\n  }\n\n  /**\n   * Check if this transaction is balanced\n   * In double-entry accounting, balanced means debits = credits (sum = 0)\n   *\n   * @returns True if sum of all entries equals zero\n   */\n  async isBalanced(): Promise<boolean> {\n    const balance = await this.getBalance();\n    return balance === 0;\n  }\n\n  /**\n   * Get total debits (positive amounts)\n   *\n   * @returns Sum of all positive entry amounts\n   */\n  async getTotalDebits(): Promise<number> {\n    const entries = await this.getEntries();\n    return entries\n      .filter((entry) => entry.amount > 0)\n      .reduce((sum, entry) => sum + entry.amount, 0);\n  }\n\n  /**\n   * Get total credits (negative amounts, returned as positive)\n   *\n   * @returns Sum of all negative entry amounts (as positive number)\n   */\n  async getTotalCredits(): Promise<number> {\n    const entries = await this.getEntries();\n    return Math.abs(\n      entries\n        .filter((entry) => entry.amount < 0)\n        .reduce((sum, entry) => sum + entry.amount, 0),\n    );\n  }\n\n  /**\n   * Get entries grouped by currency\n   *\n   * @returns Map of currency codes to arrays of entries\n   */\n  async getEntriesByCurrency(): Promise<Map<string, any[]>> {\n    const entries = await this.getEntries();\n    const byCurrency = new Map<string, any[]>();\n\n    for (const entry of entries) {\n      const currency = entry.currency || 'UNKNOWN';\n      if (!byCurrency.has(currency)) {\n        byCurrency.set(currency, []);\n      }\n      byCurrency.get(currency)?.push(entry);\n    }\n\n    return byCurrency;\n  }\n}\n","/**\n * AccountTransactionEntry model - Individual entry in a transaction\n *\n * Represents a debit or credit to a specific account\n */\n\nimport { SmrtObject, smrt } from '@smrt/core';\nimport type { AccountTransactionEntryOptions, CurrencyCode } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class AccountTransactionEntry extends SmrtObject {\n  // id inherited from SmrtObject\n  // Note: slug and name not typically used for transaction entries\n\n  transactionId = ''; // FK to AccountTransaction\n  accountId = ''; // FK to Account\n  amount = 0; // Integer in smallest currency unit (e.g., cents)\n  currency: CurrencyCode = 'USD'; // ISO 4217 currency code\n  description = ''; // Optional entry-specific description\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: AccountTransactionEntryOptions = {}) {\n    super(options);\n\n    if (options.transactionId !== undefined)\n      this.transactionId = options.transactionId;\n    if (options.accountId !== undefined) this.accountId = options.accountId;\n    if (options.amount !== undefined) this.amount = options.amount;\n    if (options.currency !== undefined) this.currency = options.currency;\n    if (options.description !== undefined)\n      this.description = options.description;\n\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get the transaction this entry belongs to\n   *\n   * @returns AccountTransaction instance or null\n   */\n  async getTransaction() {\n    if (!this.transactionId) return null;\n\n    const { AccountTransactionCollection } = await import(\n      '../collections/AccountTransactionCollection'\n    );\n    const { persistence, db, ai, fs, _className } = this.options;\n    const collection = await AccountTransactionCollection.create({\n      persistence,\n      db,\n      ai,\n      fs,\n      _className,\n    });\n\n    return await collection.get({ id: this.transactionId });\n  }\n\n  /**\n   * Get the account this entry affects\n   *\n   * @returns Account instance or null\n   */\n  async getAccount() {\n    if (!this.accountId) return null;\n\n    const { AccountCollection } = await import(\n      '../collections/AccountCollection'\n    );\n    const { persistence, db, ai, fs, _className } = this.options;\n    const collection = await AccountCollection.create({\n      persistence,\n      db,\n      ai,\n      fs,\n      _className,\n    });\n\n    return await collection.get({ id: this.accountId });\n  }\n\n  /**\n   * Check if this entry is a debit\n   *\n   * @returns True if amount is positive\n   */\n  isDebit(): boolean {\n    return this.amount > 0;\n  }\n\n  /**\n   * Check if this entry is a credit\n   *\n   * @returns True if amount is negative\n   */\n  isCredit(): boolean {\n    return this.amount < 0;\n  }\n\n  /**\n   * Get the absolute amount value\n   *\n   * @returns Absolute value of amount\n   */\n  getAbsoluteAmount(): number {\n    return Math.abs(this.amount);\n  }\n\n  /**\n   * Format amount as currency string\n   * Converts from smallest unit (cents) to standard format\n   *\n   * @param locale - Optional locale for formatting (default: 'en-US')\n   * @returns Formatted currency string\n   */\n  formatAmount(locale = 'en-US'): string {\n    // Convert cents to standard currency units\n    const standardAmount = this.amount / 100;\n\n    try {\n      return new Intl.NumberFormat(locale, {\n        style: 'currency',\n        currency: this.currency,\n      }).format(standardAmount);\n    } catch {\n      // Fallback if currency not recognized\n      return `${this.currency} ${standardAmount.toFixed(2)}`;\n    }\n  }\n\n  /**\n   * Create a debit entry helper\n   * Static factory method for creating debit entries\n   *\n   * @param options - Entry options with positive amount\n   * @returns New AccountTransactionEntry instance\n   */\n  static createDebit(\n    options: Omit<AccountTransactionEntryOptions, 'amount'> & {\n      amount: number;\n    },\n  ): AccountTransactionEntry {\n    return new AccountTransactionEntry({\n      ...options,\n      amount: Math.abs(options.amount), // Ensure positive\n    });\n  }\n\n  /**\n   * Create a credit entry helper\n   * Static factory method for creating credit entries\n   *\n   * @param options - Entry options with amount (will be made negative)\n   * @returns New AccountTransactionEntry instance\n   */\n  static createCredit(\n    options: Omit<AccountTransactionEntryOptions, 'amount'> & {\n      amount: number;\n    },\n  ): AccountTransactionEntry {\n    return new AccountTransactionEntry({\n      ...options,\n      amount: -Math.abs(options.amount), // Ensure negative\n    });\n  }\n}\n","/**\n * AccountCollection - Collection manager for Account objects\n *\n * Provides account hierarchy traversal, filtering by type and currency.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { Account } from '../models/Account';\nimport type { AccountType, CurrencyCode } from '../types';\n\nexport class AccountCollection extends SmrtCollection<Account> {\n  static readonly _itemClass = Account;\n\n  /**\n   * Get accounts by type\n   *\n   * @param type - Account type (asset, liability, equity, revenue, expense)\n   * @returns Array of Account instances\n   */\n  async getByType(type: AccountType): Promise<Account[]> {\n    return await this.list({ where: { type } });\n  }\n\n  /**\n   * Get accounts by currency\n   *\n   * @param currency - ISO 4217 currency code\n   * @returns Array of Account instances\n   */\n  async getByCurrency(currency: CurrencyCode): Promise<Account[]> {\n    return await this.list({ where: { currency } });\n  }\n\n  /**\n   * Get root accounts (accounts with no parent)\n   *\n   * @returns Array of root Account instances\n   */\n  async getRootAccounts(): Promise<Account[]> {\n    const allAccounts = await this.list({});\n    return allAccounts.filter((account) => !account.parentId);\n  }\n\n  /**\n   * Get child accounts of a parent\n   *\n   * @param parentId - Parent account ID\n   * @returns Array of child Account instances\n   */\n  async getChildren(parentId: string): Promise<Account[]> {\n    return await this.list({ where: { parentId } });\n  }\n\n  /**\n   * Get all accounts of a specific type and currency\n   *\n   * @param type - Account type\n   * @param currency - Currency code\n   * @returns Array of Account instances\n   */\n  async getByTypeAndCurrency(\n    type: AccountType,\n    currency: CurrencyCode,\n  ): Promise<Account[]> {\n    return await this.list({ where: { type, currency } });\n  }\n\n  /**\n   * Search accounts by name (case-insensitive partial match)\n   *\n   * @param searchTerm - Search term\n   * @returns Array of matching Account instances\n   */\n  async searchByName(searchTerm: string): Promise<Account[]> {\n    const allAccounts = await this.list({});\n    const lowerSearch = searchTerm.toLowerCase();\n\n    return allAccounts.filter((account) =>\n      account.name.toLowerCase().includes(lowerSearch),\n    );\n  }\n\n  /**\n   * Get account hierarchy tree structure\n   * Returns root accounts with nested children\n   *\n   * @returns Array of root accounts with children property\n   */\n  async getHierarchyTree(): Promise<any[]> {\n    const allAccounts = await this.list({});\n    const accountMap = new Map<string, any>();\n    const roots: any[] = [];\n\n    // Create map of accounts with children arrays\n    for (const account of allAccounts) {\n      accountMap.set(account.id, { ...account, children: [] });\n    }\n\n    // Build tree structure\n    for (const account of allAccounts) {\n      const node = accountMap.get(account.id);\n      if (account.parentId && accountMap.has(account.parentId)) {\n        accountMap.get(account.parentId)?.children.push(node);\n      } else {\n        roots.push(node);\n      }\n    }\n\n    return roots;\n  }\n}\n","/**\n * AccountTransactionCollection - Collection manager for AccountTransaction objects\n *\n * Provides transaction filtering by date range and description search.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { AccountTransaction } from '../models/AccountTransaction';\n\nexport class AccountTransactionCollection extends SmrtCollection<AccountTransaction> {\n  static readonly _itemClass = AccountTransaction;\n\n  /**\n   * Get transactions by date range\n   *\n   * @param startDate - Start of date range\n   * @param endDate - End of date range\n   * @returns Array of AccountTransaction instances\n   */\n  async getByDateRange(\n    startDate: Date,\n    endDate: Date,\n  ): Promise<AccountTransaction[]> {\n    const allTransactions = await this.list({});\n\n    return allTransactions.filter(\n      (transaction) =>\n        transaction.date >= startDate && transaction.date <= endDate,\n    );\n  }\n\n  /**\n   * Get transactions on a specific date\n   *\n   * @param date - Date to filter by\n   * @returns Array of AccountTransaction instances\n   */\n  async getByDate(date: Date): Promise<AccountTransaction[]> {\n    const startOfDay = new Date(date);\n    startOfDay.setHours(0, 0, 0, 0);\n\n    const endOfDay = new Date(date);\n    endOfDay.setHours(23, 59, 59, 999);\n\n    return await this.getByDateRange(startOfDay, endOfDay);\n  }\n\n  /**\n   * Search transactions by description (case-insensitive partial match)\n   *\n   * @param searchTerm - Search term\n   * @returns Array of matching AccountTransaction instances\n   */\n  async searchByDescription(searchTerm: string): Promise<AccountTransaction[]> {\n    const allTransactions = await this.list({});\n    const lowerSearch = searchTerm.toLowerCase();\n\n    return allTransactions.filter((transaction) =>\n      transaction.description.toLowerCase().includes(lowerSearch),\n    );\n  }\n\n  /**\n   * Get recent transactions\n   *\n   * @param limit - Maximum number of transactions to return\n   * @returns Array of recent AccountTransaction instances\n   */\n  async getRecent(limit = 10): Promise<AccountTransaction[]> {\n    const allTransactions = await this.list({});\n\n    return allTransactions\n      .sort((a, b) => b.date.getTime() - a.date.getTime())\n      .slice(0, limit);\n  }\n\n  /**\n   * Get transactions for current month\n   *\n   * @returns Array of AccountTransaction instances\n   */\n  async getCurrentMonth(): Promise<AccountTransaction[]> {\n    const now = new Date();\n    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);\n    endOfMonth.setHours(23, 59, 59, 999);\n\n    return await this.getByDateRange(startOfMonth, endOfMonth);\n  }\n\n  /**\n   * Get transactions for current year\n   *\n   * @returns Array of AccountTransaction instances\n   */\n  async getCurrentYear(): Promise<AccountTransaction[]> {\n    const now = new Date();\n    const startOfYear = new Date(now.getFullYear(), 0, 1);\n    const endOfYear = new Date(now.getFullYear(), 11, 31);\n    endOfYear.setHours(23, 59, 59, 999);\n\n    return await this.getByDateRange(startOfYear, endOfYear);\n  }\n}\n","/**\n * AccountTransactionEntryCollection - Collection manager for AccountTransactionEntry objects\n *\n * Provides entry filtering by transaction, account, currency, and amount.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { AccountTransactionEntry } from '../models/AccountTransactionEntry';\nimport type { CurrencyCode } from '../types';\n\nexport class AccountTransactionEntryCollection extends SmrtCollection<AccountTransactionEntry> {\n  static readonly _itemClass = AccountTransactionEntry;\n\n  /**\n   * Get entries for a specific transaction\n   *\n   * @param transactionId - Transaction ID\n   * @returns Array of AccountTransactionEntry instances\n   */\n  async getByTransactionId(\n    transactionId: string,\n  ): Promise<AccountTransactionEntry[]> {\n    return await this.list({ where: { transactionId } });\n  }\n\n  /**\n   * Get entries for a specific account\n   *\n   * @param accountId - Account ID\n   * @returns Array of AccountTransactionEntry instances\n   */\n  async getByAccountId(accountId: string): Promise<AccountTransactionEntry[]> {\n    return await this.list({ where: { accountId } });\n  }\n\n  /**\n   * Get entries by currency\n   *\n   * @param currency - ISO 4217 currency code\n   * @returns Array of AccountTransactionEntry instances\n   */\n  async getByCurrency(\n    currency: CurrencyCode,\n  ): Promise<AccountTransactionEntry[]> {\n    return await this.list({ where: { currency } });\n  }\n\n  /**\n   * Get debit entries only (positive amounts)\n   *\n   * @returns Array of debit AccountTransactionEntry instances\n   */\n  async getDebits(): Promise<AccountTransactionEntry[]> {\n    const allEntries = await this.list({});\n    return allEntries.filter((entry) => entry.amount > 0);\n  }\n\n  /**\n   * Get credit entries only (negative amounts)\n   *\n   * @returns Array of credit AccountTransactionEntry instances\n   */\n  async getCredits(): Promise<AccountTransactionEntry[]> {\n    const allEntries = await this.list({});\n    return allEntries.filter((entry) => entry.amount < 0);\n  }\n\n  /**\n   * Get entries within amount range\n   *\n   * @param minAmount - Minimum amount (inclusive)\n   * @param maxAmount - Maximum amount (inclusive)\n   * @returns Array of AccountTransactionEntry instances\n   */\n  async getByAmountRange(\n    minAmount: number,\n    maxAmount: number,\n  ): Promise<AccountTransactionEntry[]> {\n    const allEntries = await this.list({});\n    return allEntries.filter(\n      (entry) => entry.amount >= minAmount && entry.amount <= maxAmount,\n    );\n  }\n\n  /**\n   * Calculate total for account\n   *\n   * @param accountId - Account ID\n   * @returns Sum of all entry amounts for the account\n   */\n  async calculateAccountTotal(accountId: string): Promise<number> {\n    const entries = await this.getByAccountId(accountId);\n    return entries.reduce((sum, entry) => sum + entry.amount, 0);\n  }\n\n  /**\n   * Calculate total for transaction\n   *\n   * @param transactionId - Transaction ID\n   * @returns Sum of all entry amounts for the transaction\n   */\n  async calculateTransactionTotal(transactionId: string): Promise<number> {\n    const entries = await this.getByTransactionId(transactionId);\n    return entries.reduce((sum, entry) => sum + entry.amount, 0);\n  }\n\n  /**\n   * Get entries grouped by account\n   *\n   * @returns Map of account IDs to arrays of entries\n   */\n  async groupByAccount(): Promise<Map<string, AccountTransactionEntry[]>> {\n    const allEntries = await this.list({});\n    const grouped = new Map<string, AccountTransactionEntry[]>();\n\n    for (const entry of allEntries) {\n      if (!grouped.has(entry.accountId)) {\n        grouped.set(entry.accountId, []);\n      }\n      grouped.get(entry.accountId)?.push(entry);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Get entries grouped by currency\n   *\n   * @returns Map of currency codes to arrays of entries\n   */\n  async groupByCurrency(): Promise<Map<string, AccountTransactionEntry[]>> {\n    const allEntries = await this.list({});\n    const grouped = new Map<string, AccountTransactionEntry[]>();\n\n    for (const entry of allEntries) {\n      if (!grouped.has(entry.currency)) {\n        grouped.set(entry.currency, []);\n      }\n      grouped.get(entry.currency)?.push(entry);\n    }\n\n    return grouped;\n  }\n}\n"],"names":["AccountCollection","AccountTransactionEntryCollection","_init","AccountTransactionCollection"],"mappings":"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"}