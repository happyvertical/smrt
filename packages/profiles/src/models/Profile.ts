/**
 * Profile model - Core entity representing any profile type
 *
 * Central table holding all primary entities with type, email, name, and description.
 * Uses UUID primary key with relationships to ProfileType for classification.
 */

import {
  foreignKey,
  oneToMany,
  SmrtObject,
  type SmrtObjectOptions,
  smrt,
  text,
} from '@smrt/core';
import { ProfileType } from './ProfileType';

export interface ProfileOptions extends SmrtObjectOptions {
  typeId?: string;
  email?: string;
  name?: string;
  description?: string;
}

@smrt({
  api: { include: ['list', 'get', 'create', 'update', 'delete'] },
  mcp: { include: ['list', 'get', 'create', 'update'] },
  cli: true,
})
export class Profile extends SmrtObject {
  // id: UUID (auto-generated by SmrtObject)
  typeId = foreignKey('ProfileType', { required: true }); // References ProfileType.id
  email = text({ unique: true }); // Optional email address
  name = text({ required: true }); // Display name
  description = text(); // Short bio or description

  // Relationships (not stored as columns)
  metadata = oneToMany('ProfileMetadata');
  relationshipsFrom = oneToMany('ProfileRelationship');
  relationshipsTo = oneToMany('ProfileRelationship');

  constructor(options: ProfileOptions = {}) {
    super(options);
    // Field values are automatically set by initializePropertiesFromOptions()
    // No need to manually assign Field properties here
  }

  /**
   * Get the profile type slug for this profile
   *
   * @returns The slug of the profile type
   */
  async getTypeSlug(): Promise<string> {
    const type = await this.loadRelated('typeId');
    return type?.slug || '';
  }

  /**
   * Set the profile type by slug
   *
   * @param slug - The slug of the profile type
   * @throws Error if profile type not found
   */
  async setTypeBySlug(slug: string): Promise<void> {
    const type = await ProfileType.getBySlug(slug);
    if (!type) throw new Error(`Profile type '${slug}' not found`);
    this.typeId.value = type.id;
  }

  /**
   * Add metadata to this profile
   *
   * @param metafieldSlug - The slug of the metafield
   * @param value - The value to set
   */
  async addMetadata(metafieldSlug: string, value: any): Promise<void> {
    const { ProfileMetafieldCollection } = await import(
      '../collections/ProfileMetafieldCollection'
    );
    const { ProfileMetadataCollection } = await import(
      '../collections/ProfileMetadataCollection'
    );

    // Get or create metafield collection
    const metafieldCollection = await (
      ProfileMetafieldCollection as any
    ).create(this.options);

    // Find the metafield by slug
    const metafield = await metafieldCollection.getBySlug(metafieldSlug);
    if (!metafield) {
      throw new Error(`Metafield '${metafieldSlug}' not found`);
    }

    // Validate the value
    await metafield.validateValue(value);

    // Get or create metadata collection
    const metadataCollection = await (ProfileMetadataCollection as any).create(
      this.options,
    );

    // Check if metadata already exists
    const existing = await metadataCollection.list({
      where: { profileId: this.id, metafieldId: metafield.id },
      limit: 1,
    });

    if (existing.length > 0) {
      // Update existing
      const metadata = existing[0];
      metadata.value = String(value);
      await metadata.save();
    } else {
      // Create new
      const metadata = await metadataCollection.create({
        profileId: this.id,
        metafieldId: metafield.id,
        value: String(value),
      });
      await metadata.save();
    }
  }

  /**
   * Get all metadata for this profile as key-value object
   *
   * @returns Object with metafield slugs as keys
   */
  async getMetadata(): Promise<Record<string, any>> {
    const { ProfileMetadataCollection } = await import(
      '../collections/ProfileMetadataCollection'
    );

    const metadataCollection = await (ProfileMetadataCollection as any).create(
      this.options,
    );

    return await metadataCollection.getMetadataObject(this.id);
  }

  /**
   * Update multiple metadata values
   *
   * @param metadata - Object with metafield slugs as keys and values
   */
  async updateMetadata(metadata: Record<string, any>): Promise<void> {
    for (const [metafieldSlug, value] of Object.entries(metadata)) {
      await this.addMetadata(metafieldSlug, value);
    }
  }

  /**
   * Remove metadata by metafield slug
   *
   * @param metafieldSlug - The slug of the metafield to remove
   */
  async removeMetadata(metafieldSlug: string): Promise<void> {
    const { ProfileMetafieldCollection } = await import(
      '../collections/ProfileMetafieldCollection'
    );
    const { ProfileMetadataCollection } = await import(
      '../collections/ProfileMetadataCollection'
    );

    const metafieldCollection = await (
      ProfileMetafieldCollection as any
    ).create(this.options);

    const metafield = await metafieldCollection.getBySlug(metafieldSlug);
    if (!metafield) {
      throw new Error(`Metafield '${metafieldSlug}' not found`);
    }

    const metadataCollection = await (ProfileMetadataCollection as any).create(
      this.options,
    );

    const existing = await metadataCollection.list({
      where: { profileId: this.id, metafieldId: metafield.id },
      limit: 1,
    });

    if (existing.length > 0) {
      await existing[0].delete();
    }
  }

  /**
   * Add a relationship to another profile
   *
   * @param toProfile - The target profile
   * @param relationshipSlug - The type of relationship
   * @param contextProfile - Optional context profile for tertiary relationships
   */
  async addRelationship(
    toProfile: Profile,
    relationshipSlug: string,
    contextProfile?: Profile,
  ): Promise<void> {
    const { ProfileRelationshipTypeCollection } = await import(
      '../collections/ProfileRelationshipTypeCollection'
    );
    const { ProfileRelationshipCollection } = await import(
      '../collections/ProfileRelationshipCollection'
    );
    const { ProfileRelationshipType } = await import(
      './ProfileRelationshipType'
    );

    // Get relationship type
    const relationshipTypeCollection = await (
      ProfileRelationshipTypeCollection as any
    ).create(this.options);

    const relationshipType =
      await relationshipTypeCollection.getBySlug(relationshipSlug);
    if (!relationshipType) {
      throw new Error(`Relationship type '${relationshipSlug}' not found`);
    }

    // Check if relationship already exists
    const relationshipCollection = await (
      ProfileRelationshipCollection as any
    ).create(this.options);

    const exists = await relationshipCollection.exists(
      this.id,
      toProfile.id,
      relationshipType.id,
    );

    if (!exists) {
      // Create the relationship
      const relationship = await relationshipCollection.create({
        fromProfileId: this.id,
        toProfileId: toProfile.id,
        typeId: relationshipType.id,
        contextProfileId: contextProfile?.id,
      });
      await relationship.save();
    }

    // Handle reciprocal relationships
    if (relationshipType.reciprocal) {
      const handler =
        ProfileRelationshipType.getReciprocalHandler(relationshipSlug);
      if (handler) {
        await handler(this, toProfile, contextProfile);
      }
    }
  }

  /**
   * Get all relationships for this profile
   *
   * @param options - Filter options (typeSlug, direction)
   * @returns Array of ProfileRelationship instances
   */
  async getRelationships(options?: {
    typeSlug?: string;
    direction?: 'from' | 'to' | 'all';
  }): Promise<ProfileRelationship[]> {
    const { ProfileRelationshipCollection } = await import(
      '../collections/ProfileRelationshipCollection'
    );
    const { ProfileRelationshipTypeCollection } = await import(
      '../collections/ProfileRelationshipTypeCollection'
    );

    const relationshipCollection = await (
      ProfileRelationshipCollection as any
    ).create(this.options);

    const direction = options?.direction || 'all';

    // Get type ID if typeSlug is provided
    let typeId: string | undefined;
    if (options?.typeSlug) {
      const relationshipTypeCollection = await (
        ProfileRelationshipTypeCollection as any
      ).create(this.options);

      const relationshipType = await relationshipTypeCollection.getBySlug(
        options.typeSlug,
      );
      typeId = relationshipType?.id;
    }

    // Fetch relationships based on direction
    if (direction === 'from') {
      return await relationshipCollection.getFromProfile(this.id, typeId);
    } else if (direction === 'to') {
      return await relationshipCollection.getToProfile(this.id, typeId);
    } else {
      return await relationshipCollection.getForProfile(this.id, typeId);
    }
  }

  /**
   * Get related profiles
   *
   * @param relationshipSlug - Optional filter by relationship type slug
   * @returns Array of related Profile instances
   */
  async getRelatedProfiles(relationshipSlug?: string): Promise<Profile[]> {
    const { ProfileCollection } = await import(
      '../collections/ProfileCollection'
    );

    const relationships = await this.getRelationships({
      typeSlug: relationshipSlug,
      direction: 'all',
    });

    const profileCollection = await (ProfileCollection as any).create(
      this.options,
    );

    const relatedProfiles: Profile[] = [];
    const seenIds = new Set<string>();

    for (const relationship of relationships) {
      // Get the other profile (not this one)
      // Convert Field instances to strings for comparison
      const fromId = String(relationship.fromProfileId);
      const toId = String(relationship.toProfileId);
      const thisId = String(this.id);
      const otherId = fromId === thisId ? toId : fromId;

      if (!seenIds.has(otherId)) {
        seenIds.add(otherId);
        const profile = await profileCollection.get({ id: otherId });
        if (profile) {
          relatedProfiles.push(profile);
        }
      }
    }

    return relatedProfiles;
  }

  /**
   * Remove a relationship to another profile
   *
   * @param toProfile - The target profile
   * @param relationshipSlug - The type of relationship to remove
   */
  async removeRelationship(
    toProfile: Profile,
    relationshipSlug: string,
  ): Promise<void> {
    const { ProfileRelationshipTypeCollection } = await import(
      '../collections/ProfileRelationshipTypeCollection'
    );
    const { ProfileRelationshipCollection } = await import(
      '../collections/ProfileRelationshipCollection'
    );

    // Get relationship type
    const relationshipTypeCollection = await (
      ProfileRelationshipTypeCollection as any
    ).create(this.options);

    const relationshipType =
      await relationshipTypeCollection.getBySlug(relationshipSlug);
    if (!relationshipType) {
      throw new Error(`Relationship type '${relationshipSlug}' not found`);
    }

    // Find and delete the relationship
    const relationshipCollection = await (
      ProfileRelationshipCollection as any
    ).create(this.options);

    const relationships = await relationshipCollection.list({
      where: {
        fromProfileId: this.id,
        toProfileId: toProfile.id,
        typeId: relationshipType.id,
      },
    });

    for (const relationship of relationships) {
      await relationship.delete();
    }

    // Handle reciprocal relationships - delete the inverse
    if (relationshipType.reciprocal) {
      const inverseRelationships = await relationshipCollection.list({
        where: {
          fromProfileId: toProfile.id,
          toProfileId: this.id,
          typeId: relationshipType.id,
        },
      });

      for (const relationship of inverseRelationships) {
        await relationship.delete();
      }
    }
  }

  /**
   * AI-powered: Generate a professional bio for this profile
   *
   * @returns Generated bio text
   */
  async generateBio(): Promise<string> {
    return await this.do('Write a short, professional bio for this person.');
  }

  /**
   * AI-powered: Check if profile matches criteria
   *
   * @param criteria - Criteria to match against
   * @returns True if matches criteria
   */
  async matches(criteria: string): Promise<boolean> {
    return await this.is(criteria);
  }

  /**
   * Find profiles by metadata key-value pair
   *
   * @param metafieldSlug - The metafield slug to search
   * @param value - The value to match
   * @returns Array of matching profiles
   */
  static async findByMetadata(
    _metafieldSlug: string,
    _value: any,
  ): Promise<Profile[]> {
    // Will be auto-implemented by SMRT
    return [];
  }

  /**
   * Find profiles by type slug
   *
   * @param typeSlug - The profile type slug
   * @returns Array of matching profiles
   */
  static async findByType(_typeSlug: string): Promise<Profile[]> {
    // Will be auto-implemented by SMRT
    return [];
  }

  /**
   * Find related profiles for a given profile
   *
   * @param profileId - The profile UUID
   * @param relationshipSlug - Optional filter by relationship type
   * @returns Array of related profiles
   */
  static async findRelated(
    _profileId: string,
    _relationshipSlug?: string,
  ): Promise<Profile[]> {
    // Will be auto-implemented by SMRT
    return [];
  }

  /**
   * Search profiles by email
   *
   * @param email - The email to search for
   * @returns Profile or null if not found
   */
  static async searchByEmail(_email: string): Promise<Profile | null> {
    // Will be auto-implemented by SMRT
    return null;
  }
}
