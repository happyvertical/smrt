{"version":3,"file":"index.js","sources":["../src/tools/tool-executor.ts","../src/object.ts","../src/pleb.ts"],"sourcesContent":["/**\n * Tool Call Execution for AI Function Calling\n *\n * This module handles runtime execution of AI tool calls on SMRT object instances.\n */\n\nimport type { Signal } from '@smrt/types';\nimport { RuntimeError, ValidationError } from '../errors.js';\nimport type { SignalBus } from '../signals/bus.js';\n\n/**\n * Tool call structure from AI response\n */\nexport interface ToolCall {\n  /**\n   * Unique identifier for this tool call\n   */\n  id: string;\n\n  /**\n   * Type of tool (always 'function' for now)\n   */\n  type: 'function';\n\n  /**\n   * Function details\n   */\n  function: {\n    /**\n     * Name of the method to call\n     */\n    name: string;\n\n    /**\n     * JSON string of arguments to pass to the method\n     */\n    arguments: string;\n  };\n}\n\n/**\n * Result of executing a tool call\n */\nexport interface ToolCallResult {\n  /**\n   * Tool call ID for correlation\n   */\n  id: string;\n\n  /**\n   * Method name that was called\n   */\n  methodName: string;\n\n  /**\n   * Parsed arguments that were used\n   */\n  arguments: Record<string, any>;\n\n  /**\n   * Result returned from the method\n   */\n  result: any;\n\n  /**\n   * Whether the call succeeded\n   */\n  success: boolean;\n\n  /**\n   * Error message if call failed\n   */\n  error?: string;\n\n  /**\n   * Execution time in milliseconds\n   */\n  duration?: number;\n}\n\n/**\n * Validates tool call arguments against method parameters\n *\n * @param methodName - Name of the method being called\n * @param args - Parsed arguments from tool call\n * @param allowedMethods - List of methods AI is allowed to call\n * @throws ValidationError if method not allowed or arguments invalid\n */\nexport function validateToolCall(\n  methodName: string,\n  args: Record<string, any>,\n  allowedMethods: string[],\n): void {\n  // Check if method is allowed\n  if (!allowedMethods.includes(methodName)) {\n    throw ValidationError.invalidValue(\n      'methodName',\n      methodName,\n      `Method must be one of: ${allowedMethods.join(', ')}`,\n    );\n  }\n\n  // Basic argument validation (could be enhanced)\n  if (typeof args !== 'object' || args === null) {\n    throw ValidationError.invalidValue(\n      'arguments',\n      args,\n      'Arguments must be a valid object',\n    );\n  }\n}\n\n/**\n * Executes a tool call on an object instance\n *\n * @param instance - Object instance to call method on\n * @param toolCall - Tool call from AI\n * @param allowedMethods - List of methods AI is allowed to call\n * @param signalBus - Optional signal bus for emitting execution events\n * @returns Result of the tool call execution\n */\nexport async function executeToolCall(\n  instance: any,\n  toolCall: ToolCall,\n  allowedMethods: string[],\n  signalBus?: SignalBus,\n): Promise<ToolCallResult> {\n  const startTime = Date.now();\n  const methodName = toolCall.function.name;\n  const executionId = signalBus?.generateExecutionId() ?? toolCall.id;\n\n  // Declare args outside try blocks so it's accessible in catch block\n  let args: Record<string, any> | undefined;\n\n  try {\n    // Parse arguments\n    try {\n      args = JSON.parse(toolCall.function.arguments);\n    } catch (_parseError) {\n      throw ValidationError.invalidValue(\n        'arguments',\n        toolCall.function.arguments,\n        'Arguments must be valid JSON',\n      );\n    }\n\n    // Type guard - args is always defined after successful parsing\n    if (!args) {\n      throw ValidationError.invalidValue(\n        'arguments',\n        toolCall.function.arguments,\n        'Arguments must be a valid object',\n      );\n    }\n\n    // Validate tool call\n    validateToolCall(methodName, args, allowedMethods);\n\n    // Check method exists\n    if (typeof instance[methodName] !== 'function') {\n      throw RuntimeError.operationFailed(\n        `Method '${methodName}' not found on object`,\n      );\n    }\n\n    // Emit start signal\n    if (signalBus) {\n      const startSignal: Signal = {\n        id: executionId,\n        objectId: instance.id ?? 'unknown',\n        className: instance.constructor?.name ?? 'Unknown',\n        method: methodName,\n        type: 'start',\n        args: [args], // Wrap in array for consistency\n        timestamp: new Date(),\n      };\n      await signalBus.emit(startSignal);\n    }\n\n    // Execute method\n    const result = await instance[methodName](args);\n\n    // Emit end signal\n    if (signalBus) {\n      const endSignal: Signal = {\n        id: executionId,\n        objectId: instance.id ?? 'unknown',\n        className: instance.constructor?.name ?? 'Unknown',\n        method: methodName,\n        type: 'end',\n        args: [args],\n        result,\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n      await signalBus.emit(endSignal);\n    }\n\n    return {\n      id: toolCall.id,\n      methodName,\n      arguments: args,\n      result,\n      success: true,\n      duration: Date.now() - startTime,\n    };\n  } catch (error) {\n    // Emit error signal\n    if (signalBus) {\n      const errorSignal: Signal = {\n        id: executionId,\n        objectId: instance.id ?? 'unknown',\n        className: instance.constructor?.name ?? 'Unknown',\n        method: methodName,\n        type: 'error',\n        // Preserve actual args if parsed, otherwise include raw arguments for debugging\n        args: [\n          typeof args !== 'undefined' ? args : toolCall.function.arguments,\n        ],\n        error: error instanceof Error ? error : new Error(String(error)),\n        duration: Date.now() - startTime,\n        timestamp: new Date(),\n      };\n      await signalBus.emit(errorSignal);\n    }\n\n    return {\n      id: toolCall.id,\n      methodName,\n      arguments: {},\n      result: null,\n      success: false,\n      error: error instanceof Error ? error.message : String(error),\n      duration: Date.now() - startTime,\n    };\n  }\n}\n\n/**\n * Executes multiple tool calls in sequence\n *\n * @param instance - Object instance to call methods on\n * @param toolCalls - Array of tool calls from AI\n * @param allowedMethods - List of methods AI is allowed to call\n * @param signalBus - Optional signal bus for emitting execution events\n * @returns Array of tool call results\n */\nexport async function executeToolCalls(\n  instance: any,\n  toolCalls: ToolCall[],\n  allowedMethods: string[],\n  signalBus?: SignalBus,\n): Promise<ToolCallResult[]> {\n  const results: ToolCallResult[] = [];\n\n  for (const toolCall of toolCalls) {\n    const result = await executeToolCall(\n      instance,\n      toolCall,\n      allowedMethods,\n      signalBus,\n    );\n    results.push(result);\n\n    // Stop on first error if needed\n    if (!result.success) {\n      console.warn(\n        `Tool call failed for ${result.methodName}: ${result.error}`,\n      );\n      // Continue executing other tools (don't break)\n    }\n  }\n\n  return results;\n}\n\n/**\n * Formats tool call results into messages for AI\n *\n * @param results - Tool call execution results\n * @returns Array of tool response messages\n */\nexport function formatToolResults(\n  results: ToolCallResult[],\n): Array<{ role: 'tool'; tool_call_id: string; content: string }> {\n  return results.map((result) => ({\n    role: 'tool' as const,\n    tool_call_id: result.id,\n    content: result.success\n      ? JSON.stringify(result.result)\n      : `Error: ${result.error}`,\n  }));\n}\n","// import type { AIMessageOptions } from '@have/ai';\n\nimport type { AITool } from '@have/ai';\nimport type { SmrtClassOptions } from './class';\nimport { SmrtClass } from './class';\nimport {\n  DatabaseError,\n  ErrorUtils,\n  RuntimeError,\n  ValidationError,\n} from './errors';\nimport { Field } from './fields/index';\nimport { ObjectRegistry } from './registry';\nimport {\n  executeToolCall as executeToolCallInternal,\n  type ToolCall,\n  type ToolCallResult,\n} from './tools/tool-executor';\nimport {\n  fieldsFromClass,\n  setupTableFromClass,\n  tableNameFromClass,\n  toSnakeCase,\n} from './utils';\n\n/**\n * Options for SmrtObject initialization\n */\nexport interface SmrtObjectOptions extends SmrtClassOptions {\n  /**\n   * Unique identifier for the object\n   */\n  id?: string;\n\n  /**\n   * Human-readable name for the object\n   */\n  name?: string;\n\n  /**\n   * URL-friendly identifier\n   */\n  slug?: string;\n\n  /**\n   * Optional context to scope the slug (could be a path, domain, etc.)\n   */\n  context?: string;\n\n  /**\n   * Creation timestamp\n   */\n  created_at?: Date;\n\n  /**\n   * Last update timestamp\n   */\n  updated_at?: Date;\n\n  /**\n   * Flag to skip automatic field extraction (internal use)\n   */\n  _extractingFields?: boolean;\n\n  /**\n   * Flag to skip database loading (internal use)\n   */\n  _skipLoad?: boolean;\n\n  /**\n   * Allow arbitrary field values to be passed\n   */\n  [key: string]: any;\n}\n\n/**\n * Core persistent object with unique identifiers and database storage\n *\n * SmrtObject provides functionality for creating, loading, and saving objects\n * to a database. It supports identification via unique IDs and URL-friendly\n * slugs, with optional context scoping.\n */\nexport class SmrtObject extends SmrtClass {\n  /**\n   * Database table name for this object\n   */\n  public _tableName!: string;\n\n  /**\n   * Cache for loaded relationships to avoid repeated database queries\n   * Maps fieldName to loaded object(s)\n   */\n  private _loadedRelationships: Map<string, any> = new Map();\n\n  /**\n   * Override options with SmrtObjectOptions type for proper type narrowing.\n   * Initialized by parent constructor via super() call.\n   */\n  protected declare options: SmrtObjectOptions;\n\n  /**\n   * Unique identifier for the object\n   */\n  protected _id: string | null | undefined;\n\n  /**\n   * URL-friendly identifier\n   */\n  protected _slug: string | null | undefined;\n\n  /**\n   * Optional context to scope the slug\n   */\n  protected _context: string | null | undefined;\n\n  /**\n   * Human-readable name, primarily for display purposes\n   * Can be a string value or a Field instance (for Field-based schema definition)\n   */\n  public name?: string | Field | null = null;\n\n  /**\n   * Creation timestamp\n   */\n  public created_at: Date | null | undefined = null;\n\n  /**\n   * Last update timestamp\n   */\n  public updated_at: Date | null | undefined = null;\n\n  /**\n   * Creates a new SmrtObject instance\n   *\n   * @param options - Configuration options including identifiers and metadata\n   * @throws Error if options is null\n   */\n  constructor(options: SmrtObjectOptions = {}) {\n    super(options);\n    // Explicitly set child's options property after parent initialization\n    // This is required because the override declaration creates a new property slot\n    this.options = options;\n    if (options === null) {\n      throw new Error('options cant be null');\n    }\n    this._id = options.id || null;\n    this._slug = options.slug || null;\n    this._context = options.context || '';\n\n    // Auto-register the class if it's not already registered\n    // and it's not the base SmrtObject class itself\n    // Skip registration during field extraction to avoid infinite recursion\n    if (\n      this.constructor !== SmrtObject &&\n      !ObjectRegistry.hasClass(this.constructor.name) &&\n      !(options as any)?._skipRegistration\n    ) {\n      ObjectRegistry.register(this.constructor as typeof SmrtObject, {});\n    }\n  }\n\n  /**\n   * Initialize properties from options after field initializers have run\n   * This ensures option values take precedence over default field initializer values\n   */\n  private initializePropertiesFromOptions(): void {\n    const options = this.options;\n\n    // Set base properties that exist on SmrtObject\n    if (options.name !== undefined) this.name = options.name;\n    if (options.created_at !== undefined) this.created_at = options.created_at;\n    if (options.updated_at !== undefined) this.updated_at = options.updated_at;\n\n    // Get all fields (both Field instances and plain properties)\n    const fields = fieldsFromClass(\n      this.constructor as new (\n        ...args: any[]\n      ) => any,\n    );\n\n    // Apply option values to all fields\n    for (const [key, field] of Object.entries(fields)) {\n      if (options[key] !== undefined) {\n        // Set the property value\n        this[key as keyof this] = options[key];\n\n        // If it's a Field instance, also update field.value\n        if (field instanceof Field) {\n          field.value = options[key];\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the unique identifier for this object\n   */\n  get id(): string | null | undefined {\n    return this._id;\n  }\n\n  /**\n   * Sets the unique identifier for this object\n   *\n   * @param value - The ID to set\n   * @throws Error if the value is invalid\n   */\n  set id(value: string | null | undefined) {\n    if (!value || value === 'undefined' || value === 'null') {\n      throw new Error(`id is required, ${value} given`);\n    }\n    this._id = value;\n  }\n\n  /**\n   * Gets the URL-friendly slug for this object\n   */\n  get slug(): string | null | undefined {\n    return this._slug;\n  }\n\n  /**\n   * Sets the URL-friendly slug for this object\n   *\n   * @param value - The slug to set\n   * @throws Error if the value is invalid\n   */\n  set slug(value: string | null | undefined) {\n    if (!value || value === 'undefined' || value === 'null') {\n      throw new Error(`slug is invalid, ${value} given`);\n    }\n\n    this._slug = value;\n  }\n\n  /**\n   * Gets the context that scopes this object's slug\n   */\n  get context(): string {\n    return this._context || '';\n  }\n\n  /**\n   * Sets the context that scopes this object's slug\n   *\n   * @param value - The context to set\n   * @throws Error if the value is invalid\n   */\n  set context(value: string | null | undefined) {\n    if (value !== '' && !value) {\n      throw new Error(`context is invalid, ${value} given`);\n    }\n    this._context = value;\n  }\n\n  /**\n   * Initializes this object, setting up database tables and loading data if identifiers are provided\n   *\n   * @returns Promise that resolves to this instance for chaining\n   */\n  public async initialize(): Promise<this> {\n    await super.initialize();\n\n    // Initialize properties from options AFTER all field initializers have run\n    // This prevents TypeScript field initializers from overwriting option values\n    if (!this.options._extractingFields) {\n      this.initializePropertiesFromOptions();\n    }\n\n    // Setup database tables if database is configured\n    if (this.options.db) {\n      await setupTableFromClass(this.db, this.constructor);\n      // Note: SchemaGenerator already creates the unique index on (slug, context)\n      // No need to create it manually here\n    }\n\n    if (this._id && !(this.options as any)._skipLoad) {\n      await this.loadFromId();\n    } else if (this._slug && !(this.options as any)._skipLoad) {\n      await this.loadFromSlug();\n    }\n\n    return this;\n  }\n\n  /**\n   * Loads data from a database row into this object's properties\n   *\n   * @param data - Database row data\n   */\n  loadDataFromDb(data: any) {\n    const fields = this.getFields();\n    for (const field in fields) {\n      if (Object.hasOwn(fields, field)) {\n        this[field as keyof this] = data[field];\n      }\n    }\n  }\n\n  /**\n   * Gets all property descriptors from this object's prototype\n   *\n   * @returns Object containing all property descriptors\n   */\n  allDescriptors() {\n    const proto = Object.getPrototypeOf(this);\n    const descriptors = Object.getOwnPropertyDescriptors(proto);\n    return descriptors;\n  }\n\n  /**\n   * Gets the database table name for this object\n   */\n  get tableName() {\n    if (!this._tableName) {\n      this._tableName = tableNameFromClass(this.constructor);\n    }\n    return this._tableName;\n  }\n\n  /**\n   * Gets field definitions and current values for this object\n   *\n   * @returns Object containing field definitions with current values\n   */\n  getFields() {\n    // Use cached field definitions from ObjectRegistry (via fieldsFromClass)\n    // This is much more efficient than creating temporary instances\n    const fields = fieldsFromClass(\n      this.constructor as new (\n        ...args: any[]\n      ) => any,\n    );\n\n    // Add current instance values to the fields\n    // Use getPropertyValue to unwrap Field instances\n    for (const key in fields) {\n      fields[key].value = this.getPropertyValue(key);\n    }\n\n    return fields;\n  }\n\n  /**\n   * Custom JSON serialization\n   * Returns a plain object with all field values for proper JSON.stringify() behavior\n   * Field instances automatically call their toJSON() method during serialization\n   */\n  toJSON() {\n    const fields = this.getFields();\n    const data: any = {\n      id: this.id,\n      slug: this.slug,\n      context: this.context,\n      name: this.name,\n      created_at: this.created_at,\n      updated_at: this.updated_at,\n    };\n\n    // Add all field values\n    // Field.toJSON() is called automatically for Field instances\n    for (const [key, field] of Object.entries(fields)) {\n      data[key] = field.value;\n    }\n\n    return data;\n  }\n\n  /**\n   * Gets or generates a unique ID for this object\n   *\n   * @returns Promise resolving to the object's ID\n   */\n  async getId() {\n    // lookup by slug and context\n    const saved = await this.db\n      .pluck`SELECT id FROM ${this.tableName} WHERE slug = ${this.slug} AND context = ${this.context} LIMIT 1`;\n    if (saved) {\n      this.id = saved;\n    }\n\n    if (!this.id) {\n      this.id = crypto.randomUUID();\n    }\n    return this.id;\n  }\n\n  /**\n   * Gets or generates a slug for this object based on its name\n   *\n   * @returns Promise resolving to the object's slug\n   */\n  async getSlug() {\n    if (!this.slug && this.name) {\n      // Generate slug from name if not set\n      // Explicitly convert Field to string for TypeScript\n      const nameStr = String(this.name);\n      this.slug = nameStr\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '-')\n        .replace(/(^-|-$)/g, '');\n    }\n\n    // check for existing slug and make unique?\n    return this.slug;\n  }\n\n  /**\n   * Gets the ID of this object if it's already saved in the database\n   *\n   * @returns Promise resolving to the saved ID or null if not saved\n   */\n  async getSavedId() {\n    const { pluck } = this.db;\n    const saved =\n      await pluck`SELECT id FROM ${this.tableName} WHERE id = ${this.id} OR slug = ${this.slug} LIMIT 1`;\n    return saved;\n  }\n\n  /**\n   * Checks if this object is already saved in the database\n   *\n   * @returns Promise resolving to true if saved, false otherwise\n   */\n  async isSaved() {\n    const saved = await this.getSavedId();\n    return !!saved;\n  }\n\n  /**\n   * Saves this object to the database\n   *\n   * @returns Promise resolving to this object\n   */\n  async save() {\n    try {\n      // Validate object state before saving\n      await this.validateBeforeSave();\n\n      if (!this.id) {\n        this.id = crypto.randomUUID();\n      }\n\n      if (!this.slug) {\n        this.slug = await this.getSlug();\n      }\n\n      // Update the updated_at timestamp\n      this.updated_at = new Date();\n\n      if (!this.created_at) {\n        this.created_at = new Date();\n      }\n\n      // Setup database table with proper error handling\n      try {\n        await setupTableFromClass(this.db, this.constructor);\n      } catch (error) {\n        throw DatabaseError.schemaError(\n          this._tableName || this.constructor.name,\n          'table setup',\n          error instanceof Error ? error : new Error(String(error)),\n        );\n      }\n\n      // Execute save operation with retry logic for transient failures\n      // Use per-adapter upsert method instead of generating SQL\n      const jsonData = this.toJSON();\n\n      // Convert camelCase keys to snake_case for database columns\n      const data: Record<string, any> = {};\n      for (const [key, value] of Object.entries(jsonData)) {\n        data[toSnakeCase(key)] = value;\n      }\n\n      await ErrorUtils.withRetry(\n        async () => {\n          try {\n            await this.db.upsert(this.tableName, ['slug', 'context'], data);\n          } catch (error) {\n            // Detect specific database error types\n            if (error instanceof Error) {\n              if (error.message.includes('UNIQUE constraint failed')) {\n                const field = this.extractConstraintField(error.message);\n                throw ValidationError.uniqueConstraint(\n                  field,\n                  this.getFieldValue(field),\n                );\n              }\n              if (error.message.includes('NOT NULL constraint failed')) {\n                const field = this.extractConstraintField(error.message);\n                throw ValidationError.requiredField(\n                  field,\n                  this.constructor.name,\n                );\n              }\n              throw DatabaseError.queryFailed(\n                `UPSERT INTO ${this.tableName}`,\n                error,\n              );\n            }\n            throw error;\n          }\n        },\n        3,\n        500,\n      );\n\n      return this;\n    } catch (error) {\n      // Re-throw SMRT errors as-is, wrap others\n      if (error instanceof ValidationError || error instanceof DatabaseError) {\n        throw error;\n      }\n\n      throw RuntimeError.operationFailed(\n        'save',\n        `${this.constructor.name}#${this.id}`,\n        error instanceof Error ? error : new Error(String(error)),\n      );\n    }\n  }\n\n  /**\n   * Validates object state before saving\n   * Override in subclasses to add custom validation logic\n   */\n  protected async validateBeforeSave(): Promise<void> {\n    // Use cached validators from ObjectRegistry for efficient validation\n    const validators = ObjectRegistry.getValidators(this.constructor.name);\n\n    if (validators && validators.length > 0) {\n      // Execute all cached validators\n      const errors: ValidationError[] = [];\n\n      for (const validator of validators) {\n        const error = await validator(this);\n        if (error) {\n          errors.push(error);\n        }\n      }\n\n      // If there are validation errors, throw the first one\n      // (In the future, we could throw all errors as a ValidationReport)\n      if (errors.length > 0) {\n        throw errors[0];\n      }\n    } else {\n      // Fallback to old validation logic if no cached validators\n      // (for classes not registered with ObjectRegistry)\n      const fields = fieldsFromClass(this.constructor as any);\n\n      for (const [fieldName, field] of Object.entries(fields)) {\n        if (field instanceof Field && field.options.required) {\n          const value = this.getFieldValue(fieldName);\n          if (value === null || value === undefined || value === '') {\n            throw ValidationError.requiredField(\n              fieldName,\n              this.constructor.name,\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the value of a field on this object\n   */\n  protected getFieldValue(fieldName: string): any {\n    return (this as any)[fieldName];\n  }\n\n  /**\n   * Gets the actual value from a property, whether it's a plain value or a Field instance\n   *\n   * Handles both simple and advanced field patterns:\n   * - Simple: `name: string = ''` - returns the string directly\n   * - Advanced: `name = text()` - extracts and returns field.value\n   *\n   * @param key - Property name to extract value from\n   * @returns The actual value (unwrapped from Field if necessary)\n   */\n  protected getPropertyValue(key: string): any {\n    const prop = (this as any)[key];\n\n    // If it's a Field instance, return its value\n    if (prop && typeof prop === 'object' && 'value' in prop && 'type' in prop) {\n      return prop.value;\n    }\n\n    // Otherwise return the property directly\n    return prop;\n  }\n\n  /**\n   * Extracts field name from database constraint error messages\n   */\n  protected extractConstraintField(errorMessage: string): string {\n    // Try to extract field name from common SQLite constraint patterns\n    const patterns = [\n      /UNIQUE constraint failed: \\w+\\.(\\w+)/,\n      /NOT NULL constraint failed: \\w+\\.(\\w+)/,\n      /constraint failed: (\\w+)/i,\n    ];\n\n    for (const pattern of patterns) {\n      const match = errorMessage.match(pattern);\n      if (match?.[1]) {\n        return match[1];\n      }\n    }\n\n    return 'unknown_field';\n  }\n\n  /**\n   * Loads this object's data from the database using its ID\n   *\n   * @returns Promise that resolves when loading is complete\n   */\n  public async loadFromId() {\n    try {\n      if (!this._id) {\n        throw ValidationError.requiredField('id', this.constructor.name);\n      }\n\n      const sql = `SELECT * FROM ${this.tableName} WHERE id = ?`;\n\n      await ErrorUtils.withRetry(\n        async () => {\n          try {\n            const {\n              rows: [existing],\n            } = await this.db.query(sql, [this._id]);\n            if (existing) {\n              this.loadDataFromDb(existing);\n            }\n          } catch (error) {\n            throw DatabaseError.queryFailed(\n              sql,\n              error instanceof Error ? error : new Error(String(error)),\n            );\n          }\n        },\n        3,\n        250,\n      );\n    } catch (error) {\n      if (error instanceof ValidationError || error instanceof DatabaseError) {\n        throw error;\n      }\n\n      throw RuntimeError.operationFailed(\n        'loadFromId',\n        `${this.constructor.name}#${this._id}`,\n        error instanceof Error ? error : new Error(String(error)),\n      );\n    }\n  }\n\n  /**\n   * Loads this object's data from the database using its slug and context\n   *\n   * @returns Promise that resolves when loading is complete\n   */\n  public async loadFromSlug() {\n    const {\n      rows: [existing],\n    } = await this.db.query(\n      `SELECT * FROM ${this.tableName} WHERE slug = ? AND context = ?`,\n      [this._slug, this._context || ''],\n    );\n    if (existing) {\n      this.loadDataFromDb(existing);\n    }\n  }\n\n  /**\n   * Evaluates whether this object meets given criteria using AI\n   *\n   * @param criteria - Criteria to evaluate against\n   * @param options - AI message options\n   * @returns Promise resolving to true if criteria are met, false otherwise\n   * @throws Error if the AI response is invalid\n   */\n  public async is(criteria: string, options: any = {}) {\n    const prompt = `--- Beginning of criteria ---\\n${criteria}\\n--- End of criteria ---\\nDoes the content meet all the given criteria? Reply with a json object with a single boolean 'result' property`;\n\n    // Get available tools for AI function calling\n    const tools = this.getAvailableTools();\n\n    const message = await this.ai.message(prompt, {\n      ...(options as any),\n      responseFormat: { type: 'json_object' },\n      tools: tools.length > 0 ? tools : undefined,\n    });\n\n    try {\n      const { result } = JSON.parse(message);\n      if (result === true || result === false) {\n        return result;\n      }\n    } catch (_e) {\n      throw new Error(`Unexpected answer: ${message}`);\n    }\n  }\n\n  /**\n   * Performs actions on this object based on instructions using AI\n   *\n   * @param instructions - Instructions for the AI to follow\n   * @param options - AI message options\n   * @returns Promise resolving to the AI response\n   */\n  public async do(instructions: string, options: any = {}) {\n    const prompt = `--- Beginning of instructions ---\\n${instructions}\\n--- End of instructions ---\\nBased on the content body, please follow the instructions and provide a response. Never make use of codeblocks.`;\n\n    // Get available tools for AI function calling\n    const tools = this.getAvailableTools();\n\n    const result = await this.ai.message(prompt, {\n      ...options,\n      tools: tools.length > 0 ? tools : undefined,\n    });\n\n    return result;\n  }\n\n  /**\n   * Runs a lifecycle hook if it's defined in the object's configuration\n   *\n   * @param hookName - Name of the hook to run (e.g., 'beforeDelete', 'afterDelete')\n   * @returns Promise that resolves when the hook completes\n   */\n  protected async runHook(hookName: string): Promise<void> {\n    const config = ObjectRegistry.getConfig(this.constructor.name);\n    const hook = config.hooks?.[hookName as keyof typeof config.hooks];\n\n    if (!hook) {\n      return; // No hook defined, nothing to do\n    }\n\n    if (typeof hook === 'string') {\n      // Hook is a method name to call on this instance\n      const method = (this as any)[hook];\n      if (typeof method === 'function') {\n        await method.call(this);\n      } else {\n        console.warn(\n          `Hook method '${hook}' not found on ${this.constructor.name}`,\n        );\n      }\n    } else if (typeof hook === 'function') {\n      // Hook is a function to call with this instance as parameter\n      await hook(this);\n    }\n  }\n\n  /**\n   * Delete this object from the database\n   *\n   * @returns Promise that resolves when deletion is complete\n   */\n  public async delete(): Promise<void> {\n    await this.runHook('beforeDelete');\n\n    await this.db.query(`DELETE FROM ${this.tableName} WHERE id = ?`, [\n      this.id,\n    ]);\n\n    await this.runHook('afterDelete');\n  }\n\n  /**\n   * Check if a relationship has been loaded\n   *\n   * @param fieldName - Name of the relationship field\n   * @returns True if the relationship is loaded, false otherwise\n   * @example\n   * ```typescript\n   * if (order.isRelatedLoaded('customer')) {\n   *   console.log('Customer already loaded');\n   * }\n   * ```\n   */\n  public isRelatedLoaded(fieldName: string): boolean {\n    return this._loadedRelationships.has(fieldName);\n  }\n\n  /**\n   * Load a related object for a foreignKey field (lazy loading)\n   *\n   * Automatically loads the related object from the database using the\n   * foreign key value. The loaded object is cached to avoid repeated queries.\n   *\n   * @param fieldName - Name of the foreignKey field\n   * @returns Promise resolving to the related object or null if not found\n   * @throws {RuntimeError} If the field is not a foreignKey or target class not found\n   * @example\n   * ```typescript\n   * // Given: class Order with customerId = foreignKey(Customer)\n   * const customer = await order.loadRelated('customerId');\n   * console.log(customer.name); // Access customer properties\n   * ```\n   */\n  public async loadRelated(fieldName: string): Promise<any> {\n    // Check if already loaded\n    if (this._loadedRelationships.has(fieldName)) {\n      return this._loadedRelationships.get(fieldName);\n    }\n\n    // Get relationship metadata from ObjectRegistry\n    const relationships = ObjectRegistry.getRelationships(\n      this.constructor.name,\n    );\n    const relationship = relationships.find(\n      (r) => r.fieldName === fieldName && r.type === 'foreignKey',\n    );\n\n    if (!relationship) {\n      throw RuntimeError.invalidState(\n        `Field ${fieldName} is not a foreignKey relationship on ${this.constructor.name}`,\n        { fieldName, className: this.constructor.name },\n      );\n    }\n\n    // Get the foreign key value\n    const foreignKeyValue = this[fieldName as keyof this];\n    if (!foreignKeyValue) {\n      // No related object (foreign key is null)\n      this._loadedRelationships.set(fieldName, null);\n      return null;\n    }\n\n    // Get the target class constructor\n    const targetClassInfo = ObjectRegistry.getClass(relationship.targetClass);\n    if (!targetClassInfo) {\n      throw RuntimeError.invalidState(\n        `Target class ${relationship.targetClass} not found in ObjectRegistry`,\n        { targetClass: relationship.targetClass, fieldName },\n      );\n    }\n\n    // Create an instance and load by ID\n    const relatedInstance = new targetClassInfo.constructor(this.options);\n    await relatedInstance.initialize();\n    relatedInstance.id = foreignKeyValue as string;\n    await relatedInstance.loadFromId();\n\n    // Cache the loaded object\n    this._loadedRelationships.set(fieldName, relatedInstance);\n    return relatedInstance;\n  }\n\n  /**\n   * Load related objects for oneToMany or manyToMany fields (lazy loading)\n   *\n   * Loads all related objects from the database. For oneToMany, queries by\n   * the inverse foreign key. For manyToMany, queries through the join table.\n   *\n   * @param fieldName - Name of the oneToMany or manyToMany field\n   * @returns Promise resolving to array of related objects\n   * @throws {RuntimeError} If the field is not a relationship or not implemented\n   * @example\n   * ```typescript\n   * // Given: class Customer with orders = oneToMany(Order)\n   * const orders = await customer.loadRelatedMany('orders');\n   * console.log(`${orders.length} orders found`);\n   * ```\n   */\n  public async loadRelatedMany(fieldName: string): Promise<any[]> {\n    // Check if already loaded\n    if (this._loadedRelationships.has(fieldName)) {\n      return this._loadedRelationships.get(fieldName);\n    }\n\n    // Get relationship metadata from ObjectRegistry\n    const relationships = ObjectRegistry.getRelationships(\n      this.constructor.name,\n    );\n    const relationship = relationships.find((r) => r.fieldName === fieldName);\n\n    if (!relationship) {\n      throw RuntimeError.invalidState(\n        `Field ${fieldName} is not a relationship on ${this.constructor.name}`,\n        { fieldName, className: this.constructor.name },\n      );\n    }\n\n    if (relationship.type === 'oneToMany') {\n      // Find the inverse foreignKey field on the target class\n      const inverseRelationships = ObjectRegistry.getInverseRelationships(\n        this.constructor.name,\n      );\n      const inverseForeignKey = inverseRelationships.find(\n        (r) =>\n          r.sourceClass === relationship.targetClass &&\n          r.type === 'foreignKey' &&\n          r.targetClass === this.constructor.name,\n      );\n\n      if (!inverseForeignKey) {\n        throw RuntimeError.invalidState(\n          `Could not find inverse foreignKey on ${relationship.targetClass} for oneToMany relationship ${fieldName}`,\n          { fieldName, targetClass: relationship.targetClass },\n        );\n      }\n\n      // Get or create cached collection instance\n      const collection = await ObjectRegistry.getCollection(\n        relationship.targetClass,\n        this.options,\n      );\n\n      // Query using the inverse foreign key\n      const relatedObjects = await collection.list({\n        where: { [inverseForeignKey.fieldName]: this.id },\n      });\n\n      // Cache the loaded objects\n      this._loadedRelationships.set(fieldName, relatedObjects);\n      return relatedObjects;\n    }\n\n    if (relationship.type === 'manyToMany') {\n      // manyToMany requires a join table - not implemented yet\n      throw RuntimeError.invalidState(\n        `manyToMany relationship loading not yet implemented for ${fieldName}`,\n        { fieldName, type: 'manyToMany' },\n      );\n    }\n\n    throw RuntimeError.invalidState(\n      `Field ${fieldName} is not a oneToMany or manyToMany relationship`,\n      { fieldName, type: relationship.type },\n    );\n  }\n\n  /**\n   * Get a related object, loading it if not already loaded\n   *\n   * Convenience method that checks if the relationship is loaded and\n   * loads it if necessary. Automatically detects foreignKey vs oneToMany/manyToMany.\n   *\n   * @param fieldName - Name of the relationship field\n   * @returns Promise resolving to the related object(s)\n   * @example\n   * ```typescript\n   * // Loads customer if not already loaded\n   * const customer = await order.getRelated('customerId');\n   *\n   * // Loads orders if not already loaded\n   * const orders = await customer.getRelated('orders');\n   * ```\n   */\n  public async getRelated(fieldName: string): Promise<any> {\n    if (this._loadedRelationships.has(fieldName)) {\n      return this._loadedRelationships.get(fieldName);\n    }\n\n    // Determine relationship type\n    const relationships = ObjectRegistry.getRelationships(\n      this.constructor.name,\n    );\n    const relationship = relationships.find((r) => r.fieldName === fieldName);\n\n    if (!relationship) {\n      throw RuntimeError.invalidState(\n        `Field ${fieldName} is not a relationship on ${this.constructor.name}`,\n        { fieldName, className: this.constructor.name },\n      );\n    }\n\n    // Load based on relationship type\n    if (relationship.type === 'foreignKey') {\n      return this.loadRelated(fieldName);\n    }\n\n    return this.loadRelatedMany(fieldName);\n  }\n\n  /**\n   * Get available AI-callable tools for this object\n   *\n   * Returns the pre-generated tool definitions from the manifest.\n   * Tools are generated at build time based on the @smrt decorator's AI config.\n   *\n   * @returns Array of AITool definitions for LLM function calling\n   * @example\n   * ```typescript\n   * const tools = document.getAvailableTools();\n   * console.log(`${tools.length} AI-callable methods available`);\n   * ```\n   */\n  public getAvailableTools(): AITool[] {\n    const classInfo = ObjectRegistry.getClass(this.constructor.name);\n    return classInfo?.tools || [];\n  }\n\n  /**\n   * Execute a tool call from AI on this object instance\n   *\n   * Validates the tool call against allowed methods and executes it with\n   * proper error handling and timing.\n   *\n   * @param toolCall - Tool call from AI response\n   * @returns Promise resolving to the tool call result\n   * @example\n   * ```typescript\n   * const toolCall = {\n   *   id: 'call_123',\n   *   type: 'function',\n   *   function: {\n   *     name: 'analyze',\n   *     arguments: '{\"type\": \"detailed\"}'\n   *   }\n   * };\n   *\n   * const result = await document.executeToolCall(toolCall);\n   * console.log(result.success ? result.result : result.error);\n   * ```\n   */\n  public async executeToolCall(toolCall: ToolCall): Promise<ToolCallResult> {\n    const tools = this.getAvailableTools();\n    const allowedMethods = tools.map((tool) => tool.function.name);\n\n    return executeToolCallInternal(this, toolCall, allowedMethods);\n  }\n\n  /**\n   * Remember context about this object\n   *\n   * Stores hierarchical context with confidence tracking for learned patterns.\n   * Context is stored in the _smrt_contexts system table.\n   *\n   * @param options - Context options\n   * @returns Promise that resolves when context is stored\n   * @example\n   * ```typescript\n   * // Remember a discovered parsing strategy\n   * await agent.remember({\n   *   scope: 'discovery/parser/example.com',\n   *   key: normalizedUrl,\n   *   value: { patterns: ['regex1', 'regex2'] },\n   *   metadata: { aiProvider: 'openai' },\n   *   confidence: 0.9\n   * });\n   *\n   * // Update an existing context entry by specifying id\n   * await agent.remember({\n   *   id: 'existing-context-id',\n   *   scope: 'discovery/parser/example.com',\n   *   key: normalizedUrl,\n   *   value: { patterns: ['regex1', 'regex2', 'regex3'] },\n   *   confidence: 0.95\n   * });\n   * ```\n   */\n  public async remember(options: {\n    id?: string;\n    scope: string;\n    key: string;\n    value: any;\n    metadata?: any;\n    confidence?: number;\n    version?: number;\n    expiresAt?: Date;\n  }): Promise<void> {\n    if (!this.systemDb) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n\n    const id = options.id || crypto.randomUUID();\n    const now = new Date();\n\n    await this.systemDb.query(\n      `INSERT OR REPLACE INTO _smrt_contexts (\n        id, owner_class, owner_id, scope, key, value, metadata,\n        version, confidence, created_at, updated_at, last_used_at, expires_at\n      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,\n      id,\n      this._className,\n      this.id,\n      options.scope,\n      options.key,\n      JSON.stringify(options.value),\n      options.metadata ? JSON.stringify(options.metadata) : null,\n      options.version ?? 1,\n      options.confidence ?? 1.0,\n      now,\n      now,\n      now,\n      options.expiresAt ?? null,\n    );\n  }\n\n  /**\n   * Recall remembered context for this object\n   *\n   * Retrieves context values with hierarchical search and confidence filtering.\n   * Returns only the value (parsed from JSON if applicable).\n   *\n   * @param options - Recall options\n   * @returns Promise resolving to the context value or null if not found\n   * @example\n   * ```typescript\n   * // Recall a strategy with fallback to parent scopes\n   * const strategy = await agent.recall({\n   *   scope: 'discovery/parser/example.com/article',\n   *   key: normalizedUrl,\n   *   includeAncestors: true,\n   *   minConfidence: 0.6\n   * });\n   * ```\n   */\n  public async recall(options: {\n    scope: string;\n    key: string;\n    includeAncestors?: boolean;\n    minConfidence?: number;\n  }): Promise<any | null> {\n    if (!this.systemDb) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n\n    let query = `\n      SELECT value, confidence\n      FROM _smrt_contexts\n      WHERE owner_class = ? AND owner_id = ? AND scope = ? AND key = ?\n    `;\n    const params: any[] = [\n      this._className,\n      this.id,\n      options.scope,\n      options.key,\n    ];\n\n    if (options.minConfidence !== undefined) {\n      query += ` AND confidence >= ?`;\n      params.push(options.minConfidence);\n    }\n\n    query += ` ORDER BY confidence DESC, version DESC LIMIT 1`;\n\n    const result = await this.systemDb.get(query, params);\n\n    if (result) {\n      return JSON.parse(result.value);\n    }\n\n    // Hierarchical fallback to parent scopes\n    if (options.includeAncestors) {\n      const scopeParts = options.scope.split('/');\n      while (scopeParts.length > 0) {\n        scopeParts.pop();\n        const parentScope = scopeParts.join('/') || 'global';\n\n        const parentResult = await this.recall({\n          ...options,\n          scope: parentScope,\n          includeAncestors: false,\n        });\n\n        if (parentResult) return parentResult;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Recall all remembered context for this object in a scope\n   *\n   * Returns a Map of key -> value for all context matching the criteria.\n   * Useful for bulk retrieval of strategies or cached patterns.\n   *\n   * @param options - Recall options without key (returns all keys in scope)\n   * @returns Promise resolving to Map of key -> value pairs\n   * @example\n   * ```typescript\n   * // Get all strategies for a domain\n   * const strategies = await agent.recallAll({\n   *   scope: 'discovery/parser/example.com',\n   *   minConfidence: 0.5\n   * });\n   *\n   * for (const [url, pattern] of strategies) {\n   *   console.log(`Cached pattern for ${url}:`, pattern);\n   * }\n   * ```\n   */\n  public async recallAll(\n    options: {\n      scope?: string;\n      includeDescendants?: boolean;\n      minConfidence?: number;\n    } = {},\n  ): Promise<Map<string, any>> {\n    if (!this.systemDb) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n\n    const results = new Map<string, any>();\n\n    let query = `\n      SELECT key, value, confidence\n      FROM _smrt_contexts\n      WHERE owner_class = ? AND owner_id = ?\n    `;\n    const params: any[] = [this._className, this.id];\n\n    if (options.scope) {\n      if (options.includeDescendants) {\n        query += ` AND (scope = ? OR scope LIKE ?)`;\n        params.push(options.scope, `${options.scope}/%`);\n      } else {\n        query += ` AND scope = ?`;\n        params.push(options.scope);\n      }\n    }\n\n    if (options.minConfidence !== undefined) {\n      query += ` AND confidence >= ?`;\n      params.push(options.minConfidence);\n    }\n\n    query += ` ORDER BY confidence DESC`;\n\n    const { rows } = await this.systemDb.query(query, ...params);\n\n    for (const row of rows) {\n      results.set(row.key, JSON.parse(row.value));\n    }\n\n    return results;\n  }\n\n  /**\n   * Forget specific remembered context for this object\n   *\n   * Deletes context by scope and key. Use for invalidating cached strategies\n   * or removing outdated patterns.\n   *\n   * @param options - Context identification (scope and key required)\n   * @returns Promise that resolves when context is deleted\n   * @example\n   * ```typescript\n   * // Remove an outdated strategy\n   * await agent.forget({\n   *   scope: 'discovery/parser/example.com',\n   *   key: normalizedUrl\n   * });\n   * ```\n   */\n  public async forget(options: { scope: string; key: string }): Promise<void> {\n    if (!this.systemDb) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n\n    await this.systemDb.query(\n      `DELETE FROM _smrt_contexts\n       WHERE owner_class = ? AND owner_id = ? AND scope = ? AND key = ?`,\n      this._className,\n      this.id,\n      options.scope,\n      options.key,\n    );\n  }\n\n  /**\n   * Forget all remembered context in a scope for this object\n   *\n   * Deletes all context matching the scope pattern. Useful for clearing\n   * cached strategies for an entire domain or category.\n   *\n   * @param options - Scope options (scope required, includeDescendants optional)\n   * @returns Promise resolving to number of contexts deleted\n   * @example\n   * ```typescript\n   * // Clear all strategies for a domain\n   * const count = await agent.forgetScope({\n   *   scope: 'discovery/parser/example.com',\n   *   includeDescendants: true\n   * });\n   * console.log(`Cleared ${count} cached strategies`);\n   * ```\n   */\n  public async forgetScope(options: {\n    scope: string;\n    includeDescendants?: boolean;\n  }): Promise<number> {\n    if (!this.systemDb) {\n      throw new Error('Database not initialized. Call initialize() first.');\n    }\n\n    let query = `\n      DELETE FROM _smrt_contexts\n      WHERE owner_class = ? AND owner_id = ?\n    `;\n    const params: any[] = [this._className, this.id];\n\n    if (options.includeDescendants) {\n      query += ` AND (scope = ? OR scope LIKE ?)`;\n      params.push(options.scope, `${options.scope}/%`);\n    } else {\n      query += ` AND scope = ?`;\n      params.push(options.scope);\n    }\n\n    const { rowCount } = await this.systemDb.query(query, ...params);\n    return rowCount || 0;\n  }\n}\n","import type { SmrtObjectOptions } from './object';\nimport { SmrtObject } from './object';\n\n/**\n * Configuration options for Pleb objects\n *\n * @interface PlebOptions\n * @extends SmrtObjectOptions\n */\nexport interface PlebOptions extends SmrtObjectOptions {}\n\n/**\n * Basic implementation class extending SmrtObject\n *\n * Pleb provides a simple SmrtObject implementation for quick prototyping\n * and testing without requiring custom field definitions.\n *\n * @class Pleb\n * @extends SmrtObject\n * @example\n * ```typescript\n * const pleb = await Pleb.create({\n *   name: 'Test Object',\n *   db: { url: 'sqlite://test.db' }\n * });\n * ```\n */\nexport class Pleb extends SmrtObject {\n  /**\n   * Creates a new Pleb instance\n   *\n   * @param options - Configuration options for the Pleb object\n   */\n  constructor(options: PlebOptions = {}) {\n    super(options);\n  }\n\n  /**\n   * Creates and initializes a new Pleb instance\n   *\n   * @param options - Configuration options for the Pleb object\n   * @returns Promise resolving to the initialized Pleb instance\n   * @example\n   * ```typescript\n   * const pleb = await Pleb.create({\n   *   name: 'Sample Object',\n   *   db: { url: 'sqlite://data.db' }\n   * });\n   * ```\n   */\n  static async create(options: PlebOptions) {\n    const pleb = new Pleb(options);\n    await pleb.initialize();\n    return pleb;\n  }\n\n  /**\n   * Initializes the Pleb instance and sets up database connections\n   *\n   * @returns Promise that resolves to this instance for chaining\n   */\n  public async initialize(): Promise<this> {\n    return await super.initialize();\n  }\n}\n"],"names":["executeToolCallInternal"],"mappings":"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"}