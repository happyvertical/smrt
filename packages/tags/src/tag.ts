/**
 * Tag model - Core entity for tagging with hierarchy and context support
 *
 * Central table for tag definitions with optional parent-child relationships
 * for taxonomies and category trees.
 */

import { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';
import type { TagOptions, TagMetadata } from './types';

@smrt({
  api: { include: ['list', 'get', 'create', 'update', 'delete'] },
  mcp: { include: ['list', 'get', 'create', 'update'] },
  cli: true,
})
export class Tag extends SmrtObject {
  // id: UUID (auto-generated by SmrtObject)
  protected _slug = ''; // Unique identifier
  protected _context = 'global'; // Namespace/grouping

  // Override SmrtObject accessors
  override get slug(): string {
    return this._slug;
  }
  override set slug(value: string) {
    this._slug = value;
  }

  override get context(): string {
    return this._context;
  }
  override set context(value: string) {
    this._context = value;
  }

  name = ''; // Display name
  parentSlug = ''; // FK to parent tag for hierarchy (nullable)
  level = 0; // Hierarchy depth (0 = root)
  description = ''; // Optional description
  metadata = ''; // JSON metadata stored as text

  // Timestamps
  createdAt = new Date();
  updatedAt = new Date();

  constructor(options: TagOptions = {}) {
    super(options);
    if (options.slug) this._slug = options.slug;
    if (options.name) this.name = options.name;
    if (options.context !== undefined) this._context = options.context;
    if (options.parentSlug !== undefined) this.parentSlug = options.parentSlug;
    if (options.level !== undefined) this.level = options.level;
    if (options.description !== undefined)
      this.description = options.description;

    // Handle metadata - can be object or JSON string
    if (options.metadata !== undefined) {
      if (typeof options.metadata === 'string') {
        this.metadata = options.metadata;
      } else {
        this.metadata = JSON.stringify(options.metadata);
      }
    }
  }

  /**
   * Get metadata as parsed object
   *
   * @returns Parsed metadata object or empty object if no metadata
   */
  getMetadata(): TagMetadata {
    if (!this.metadata) return {};
    try {
      return JSON.parse(this.metadata);
    } catch {
      return {};
    }
  }

  /**
   * Set metadata from object
   *
   * @param data - Metadata object to store
   */
  setMetadata(data: TagMetadata): void {
    this.metadata = JSON.stringify(data);
  }

  /**
   * Update metadata by merging with existing values
   *
   * @param updates - Partial metadata to merge
   */
  updateMetadata(updates: Partial<TagMetadata>): void {
    const current = this.getMetadata();
    this.setMetadata({ ...current, ...updates });
  }

  /**
   * Get the parent tag
   *
   * @returns Parent Tag instance or null if no parent
   */
  async getParent(): Promise<Tag | null> {
    if (!this.parentSlug) return null;

    const { TagCollection } = await import('./tags');
    const collection = await TagCollection.create(this.options);

    return await collection.get({ slug: this.parentSlug });
  }

  /**
   * Get immediate child tags
   *
   * @returns Array of child Tag instances
   */
  async getChildren(): Promise<Tag[]> {
    const { TagCollection } = await import('./tags');
    const collection = await TagCollection.create(this.options);

    return await collection.list({ where: { parentSlug: this.slug } });
  }

  /**
   * Get all ancestor tags (recursive)
   *
   * @returns Array of ancestor tags from root to immediate parent
   */
  async getAncestors(): Promise<Tag[]> {
    const ancestors: Tag[] = [];
    let current: Tag = this;

    while (current.parentSlug) {
      const parent = await current.getParent();
      if (!parent) break;
      ancestors.unshift(parent); // Add to beginning
      current = parent;
    }

    return ancestors;
  }

  /**
   * Get all descendant tags (recursive)
   *
   * @returns Array of all descendant tags
   */
  async getDescendants(): Promise<Tag[]> {
    const children = await this.getChildren();
    const descendants: Tag[] = [...children];

    for (const child of children) {
      const childDescendants = await child.getDescendants();
      descendants.push(...childDescendants);
    }

    return descendants;
  }

  /**
   * Convenience method for slug-based lookup
   *
   * @param slug - The slug to search for
   * @param context - Optional context filter
   * @returns Tag instance or null if not found
   */
  static async getBySlug(slug: string, context?: string): Promise<Tag | null> {
    // Will be auto-implemented by SMRT
    return null;
  }

  /**
   * Get root tags (no parent) for a context
   *
   * @param context - The context to filter by
   * @returns Array of root tags
   */
  static async getRootTags(context: string = 'global'): Promise<Tag[]> {
    // Will be auto-implemented by SMRT
    return [];
  }
}
