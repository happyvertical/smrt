import { mkdir, writeFile } from "node:fs/promises";
import { resolve, dirname } from "node:path";
import { S as SmrtCollection } from "../chunks/collection-BrEr-bfz.js";
import { O as ObjectRegistry } from "../chunks/registry-CfuDpgvg.js";
function generateRuntimeBootstrap(options = {}) {
  const {
    name = "smrt-mcp-server",
    version = "1.0.0",
    description = "Auto-generated MCP server from SMRT objects",
    debug = false
  } = options;
  return `#!/usr/bin/env node
/**
 * Auto-generated MCP Server
 * Generated by @smrt/core MCPGenerator
 *
 * This server exposes SMRT objects as MCP tools for AI integration.
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  type CallToolRequest,
  type ListToolsRequest,
} from '@modelcontextprotocol/sdk/types.js';
import { MCPGenerator } from '@smrt/core/generators/mcp';
import { getDatabase } from '@have/sql';
import { getAI } from '@have/ai';

// Server configuration
const SERVER_NAME = ${JSON.stringify(name)};
const SERVER_VERSION = ${JSON.stringify(version)};
const SERVER_DESCRIPTION = ${JSON.stringify(description)};
const DEBUG = ${debug};

/**
 * Initialize MCP generator with context
 */
async function initializeGenerator() {
  // Setup database connection (optional)
  const db = process.env.DATABASE_URL
    ? await getDatabase({ url: process.env.DATABASE_URL })
    : undefined;

  // Setup AI client (optional)
  const ai = process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY
    ? await getAI({
        provider: process.env.OPENAI_API_KEY ? 'openai' : 'anthropic',
        apiKey: process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY,
      })
    : undefined;

  // Create generator with context
  const generator = new MCPGenerator(
    {
      name: SERVER_NAME,
      version: SERVER_VERSION,
      description: SERVER_DESCRIPTION,
    },
    {
      db,
      ai,
    }
  );

  return generator;
}

/**
 * Main server startup function
 */
async function main() {
  try {
    if (DEBUG) {
      console.error(\`[MCP] Starting server: \${SERVER_NAME} v\${SERVER_VERSION}\`);
    }

    // Initialize generator
    const generator = await initializeGenerator();

    // Generate tools from registered SMRT objects
    const tools = generator.generateTools();

    if (DEBUG) {
      console.error(\`[MCP] Generated \${tools.length} tools from SMRT objects\`);
      console.error(\`[MCP] Available tools:\`, tools.map(t => t.name).join(', '));
    }

    // Create MCP server
    const server = new Server(
      {
        name: SERVER_NAME,
        version: SERVER_VERSION,
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    // Register ListTools handler
    server.setRequestHandler(ListToolsRequestSchema, async (_request: ListToolsRequest) => {
      if (DEBUG) {
        console.error(\`[MCP] ListTools request received\`);
      }

      return {
        tools: tools.map(tool => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema,
        })),
      };
    });

    // Register CallTool handler
    server.setRequestHandler(CallToolRequestSchema, async (request: CallToolRequest) => {
      const { name: toolName, arguments: args } = request.params;

      if (DEBUG) {
        console.error(\`[MCP] CallTool request: \${toolName}\`);
        console.error(\`[MCP] Arguments:\`, JSON.stringify(args, null, 2));
      }

      try {
        // Execute tool via generator
        const result = await generator.handleToolCall({
          method: 'tools/call',
          params: {
            name: toolName,
            arguments: args || {},
          },
        });

        if (DEBUG) {
          console.error(\`[MCP] Tool executed successfully: \${toolName}\`);
        }

        return result;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error(\`[MCP] Tool execution failed: \${toolName}\`, error);

        return {
          content: [
            {
              type: 'text',
              text: \`Error executing tool \${toolName}: \${errorMessage}\`,
            },
          ],
          isError: true,
        };
      }
    });

    // Setup stdio transport
    const transport = new StdioServerTransport();

    // Connect server to transport
    await server.connect(transport);

    if (DEBUG) {
      console.error(\`[MCP] Server connected via stdio transport\`);
      console.error(\`[MCP] Ready to receive requests\`);
    }

    // Handle graceful shutdown
    process.on('SIGINT', async () => {
      if (DEBUG) {
        console.error(\`[MCP] Received SIGINT, shutting down gracefully\`);
      }
      await server.close();
      process.exit(0);
    });

    process.on('SIGTERM', async () => {
      if (DEBUG) {
        console.error(\`[MCP] Received SIGTERM, shutting down gracefully\`);
      }
      await server.close();
      process.exit(0);
    });
  } catch (error) {
    console.error('[MCP] Fatal error during server startup:', error);
    process.exit(1);
  }
}

// Start the server
main().catch((error) => {
  console.error('[MCP] Unhandled error:', error);
  process.exit(1);
});
`;
}
function generateMCPScript(serverPath = "dist/mcp-server.js") {
  return `node ${serverPath}`;
}
function generateClaudeConfig(serverName, serverPath) {
  return {
    mcpServers: {
      [serverName]: {
        command: "node",
        args: [serverPath]
      }
    }
  };
}
function generateMCPDocumentation(serverName, serverPath) {
  return `# MCP Server Setup

This project includes an auto-generated MCP (Model Context Protocol) server that exposes SMRT objects as tools for AI integration.

## Quick Start

### 1. Build the MCP Server

\`\`\`bash
npm run build
\`\`\`

This generates the MCP server at: \`${serverPath}\`

### 2. Configure Claude Desktop

Add the following to your Claude Desktop configuration file:

**macOS**: \`~/.config/Claude/claude_desktop_config.json\`
**Windows**: \`%APPDATA%\\Claude\\claude_desktop_config.json\`

\`\`\`json
{
  "mcpServers": {
    "${serverName}": {
      "command": "node",
      "args": ["/absolute/path/to/${serverPath}"]
    }
  }
}
\`\`\`

Replace \`/absolute/path/to/\` with the actual absolute path to your project directory.

### 3. Restart Claude Desktop

Close and reopen Claude Desktop to load the new MCP server.

### 4. Test the Integration

In Claude Code, you can now use the auto-generated tools. For example:

- \`list_products\` - List all products
- \`get_product\` - Get a specific product by ID
- \`create_product\` - Create a new product
- And more...

## Environment Variables

The MCP server supports optional environment variables:

- \`DATABASE_URL\` - Database connection string
- \`OPENAI_API_KEY\` or \`ANTHROPIC_API_KEY\` - AI provider API key

## Troubleshooting

### Server Not Appearing in Claude

1. Check that the path in \`claude_desktop_config.json\` is absolute
2. Verify the server file exists at the specified path
3. Check Claude Desktop logs for errors

### Tools Not Working

1. Ensure your database is accessible (if using one)
2. Check that SMRT objects are properly decorated with \`@smrt()\`
3. Look for errors in the MCP server output

### Debug Mode

To enable debug logging, set the \`DEBUG\` constant to \`true\` in the generated server file.

## Generated Tools

The following tools are automatically generated from your SMRT objects:

- **CRUD Operations**: \`list_\`, \`get_\`, \`create_\`, \`update_\`, \`delete_\` for each object type
- **Custom Actions**: Any custom methods included in the \`@smrt()\` decorator configuration

See the SMRT object definitions for the complete list of available tools and their parameters.
`;
}
class MCPGenerator {
  config;
  context;
  collections = /* @__PURE__ */ new Map();
  constructor(config = {}, context = {}) {
    this.config = {
      name: "smrt-mcp-server",
      version: "1.0.0",
      description: "Auto-generated MCP server from smrt objects",
      server: {
        name: "smrt-mcp",
        version: "1.0.0"
      },
      ...config
    };
    this.context = context;
  }
  /**
   * Generate all available tools from registered objects
   */
  generateTools() {
    const tools = [];
    const registeredClasses = ObjectRegistry.getAllClasses();
    for (const [name, _classInfo] of registeredClasses) {
      const config = ObjectRegistry.getConfig(name);
      const mcpConfig = config.mcp || {};
      const excluded = mcpConfig.exclude || [];
      const included = mcpConfig.include;
      const shouldInclude = (endpoint) => {
        if (included && !included.includes(endpoint)) return false;
        if (excluded.includes(endpoint)) return false;
        return true;
      };
      const objectTools = this.generateObjectTools(name, shouldInclude);
      tools.push(...objectTools);
    }
    return tools;
  }
  /**
   * Generate tools for a specific object
   */
  generateObjectTools(objectName, shouldInclude) {
    const tools = [];
    const fields = ObjectRegistry.getFields(objectName);
    const lowerName = objectName.toLowerCase();
    const classInfo = ObjectRegistry.getClass(objectName);
    if (shouldInclude("list")) {
      tools.push({
        name: `${lowerName}_list`,
        description: `List ${objectName} objects with optional filtering`,
        inputSchema: {
          type: "object",
          properties: {
            limit: {
              type: "integer",
              description: "Maximum number of items to return",
              default: 50,
              minimum: 1,
              maximum: 1e3
            },
            offset: {
              type: "integer",
              description: "Number of items to skip",
              default: 0,
              minimum: 0
            },
            orderBy: {
              type: "string",
              description: 'Field to order by (e.g., "created_at DESC")'
            },
            where: {
              type: "object",
              description: "Filter conditions as key-value pairs",
              additionalProperties: true
            }
          }
        }
      });
    }
    if (shouldInclude("get")) {
      tools.push({
        name: `${lowerName}_get`,
        description: `Get a specific ${objectName} by ID or slug`,
        inputSchema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "Unique identifier of the object"
            },
            slug: {
              type: "string",
              description: "URL-friendly identifier of the object"
            }
          },
          required: []
        }
      });
    }
    if (shouldInclude("create")) {
      const properties = {};
      const required = [];
      for (const [fieldName, field] of fields) {
        properties[fieldName] = this.fieldToMCPSchema(field);
        if (field.options?.required) {
          required.push(fieldName);
        }
      }
      tools.push({
        name: `${lowerName}_create`,
        description: `Create a new ${objectName}`,
        inputSchema: {
          type: "object",
          properties,
          required
        }
      });
    }
    if (shouldInclude("update")) {
      const properties = {
        id: {
          type: "string",
          description: "ID of the object to update"
        }
      };
      for (const [fieldName, field] of fields) {
        properties[fieldName] = this.fieldToMCPSchema(field);
      }
      tools.push({
        name: `${lowerName}_update`,
        description: `Update an existing ${objectName}`,
        inputSchema: {
          type: "object",
          properties,
          required: ["id"]
        }
      });
    }
    if (shouldInclude("delete")) {
      tools.push({
        name: `${lowerName}_delete`,
        description: `Delete a ${objectName} by ID`,
        inputSchema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "ID of the object to delete"
            }
          },
          required: ["id"]
        }
      });
    }
    if (classInfo) {
      const config = ObjectRegistry.getConfig(objectName);
      const mcpConfig = config.mcp || {};
      const included = mcpConfig.include;
      const excluded = mcpConfig.exclude || [];
      if (included) {
        for (const action of included) {
          if (["list", "get", "create", "update", "delete"].includes(action)) {
            continue;
          }
          if (excluded.includes(action)) {
            continue;
          }
          const isValid = this.validateCustomMethod(
            classInfo.constructor,
            action
          );
          if (isValid) {
            const toolName = `${lowerName}_${action}`;
            tools.push({
              name: toolName,
              description: `Execute ${action} action on ${objectName}`,
              inputSchema: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "ID of the object (optional for some actions)"
                  },
                  options: {
                    type: "object",
                    description: "Additional options for the custom action",
                    additionalProperties: true
                  }
                },
                required: []
              }
            });
          } else {
            console.warn(
              `Warning: Custom action '${action}' specified in MCP config for ${objectName}, but method ${action}() not found on class`
            );
          }
        }
      }
    }
    return tools;
  }
  /**
   * Convert field definition to MCP schema
   */
  fieldToMCPSchema(field) {
    const schema = {
      description: field.options?.description || `${field.type} field`
    };
    switch (field.type) {
      case "text":
        schema.type = "string";
        if (field.options?.maxLength)
          schema.maxLength = field.options.maxLength;
        if (field.options?.minLength)
          schema.minLength = field.options.minLength;
        break;
      case "integer":
        schema.type = "integer";
        if (field.options?.min !== void 0)
          schema.minimum = field.options.min;
        if (field.options?.max !== void 0)
          schema.maximum = field.options.max;
        break;
      case "decimal":
        schema.type = "number";
        if (field.options?.min !== void 0)
          schema.minimum = field.options.min;
        if (field.options?.max !== void 0)
          schema.maximum = field.options.max;
        break;
      case "boolean":
        schema.type = "boolean";
        break;
      case "datetime":
        schema.type = "string";
        schema.format = "date-time";
        break;
      case "json":
        schema.type = "object";
        break;
      case "foreignKey":
        schema.type = "string";
        schema.description = `ID of related ${field.options?.related || "object"}`;
        break;
      default:
        schema.type = "string";
    }
    if (field.options?.default !== void 0) {
      schema.default = field.options.default;
    }
    return schema;
  }
  /**
   * Validate that a custom method exists on a class
   */
  validateCustomMethod(classConstructor, methodName) {
    try {
      const prototype = classConstructor.prototype;
      if (typeof prototype[methodName] === "function") {
        return true;
      }
      if (typeof classConstructor[methodName] === "function") {
        return true;
      }
      return false;
    } catch (error) {
      console.warn(
        `Error validating method ${methodName} on class ${classConstructor.name}:`,
        error
      );
      return false;
    }
  }
  /**
   * Handle MCP tool calls
   */
  async handleToolCall(request) {
    const { name, arguments: args } = request.params;
    try {
      const [objectName, action] = name.split("_");
      if (!objectName || !action) {
        throw new Error(`Invalid tool name format: ${name}`);
      }
      const registeredClasses = ObjectRegistry.getAllClasses();
      let classInfo = null;
      let actualObjectName = "";
      for (const [registeredName, info] of registeredClasses) {
        if (registeredName.toLowerCase() === objectName.toLowerCase()) {
          classInfo = info;
          actualObjectName = registeredName;
          break;
        }
      }
      if (!classInfo) {
        throw new Error(`Object type '${objectName}' not found`);
      }
      const collection = this.getCollection(actualObjectName, classInfo);
      const result = await this.executeAction(collection, action, args);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error: ${error instanceof Error ? error.message : "Unknown error"}`
          }
        ]
      };
    }
  }
  /**
   * Get or create collection for an object
   */
  getCollection(objectName, classInfo) {
    if (!this.collections.has(objectName)) {
      if (!classInfo.collectionConstructor || typeof classInfo.collectionConstructor !== "function") {
        throw new Error(
          `No valid collection constructor found for ${objectName}`
        );
      }
      const collection2 = new classInfo.collectionConstructor({
        ai: this.context.ai,
        db: this.context.db
      });
      if (!(collection2 instanceof SmrtCollection)) {
        throw new Error(
          `Collection for ${objectName} must extend SmrtCollection`
        );
      }
      this.collections.set(objectName, collection2);
    }
    const collection = this.collections.get(objectName);
    if (!collection) {
      throw new Error(`Collection for ${objectName} not found`);
    }
    return collection;
  }
  /**
   * Execute action on collection
   */
  async executeAction(collection, action, args) {
    switch (action) {
      case "list": {
        const listOptions = {
          limit: Math.min(args.limit || 50, 1e3),
          offset: args.offset || 0
        };
        if (args.where) {
          listOptions.where = args.where;
        }
        if (args.orderBy) {
          listOptions.orderBy = args.orderBy;
        }
        const results = await collection.list(listOptions);
        const total = await collection.count({ where: args.where || {} });
        return {
          data: results,
          meta: {
            total,
            limit: listOptions.limit,
            offset: listOptions.offset,
            count: results.length
          }
        };
      }
      case "get": {
        if (!args.id && !args.slug) {
          throw new Error("Either id or slug is required");
        }
        const filter = args.id ? args.id : args.slug;
        const item = await collection.get(filter);
        if (!item) {
          throw new Error("Object not found");
        }
        return item;
      }
      case "create": {
        const createData = { ...args };
        if (this.context.user) {
          createData.created_by = this.context.user.id;
          createData.owner_id = this.context.user.id;
        }
        const newItem = await collection.create(createData);
        await newItem.save();
        return newItem;
      }
      case "update": {
        const { id, ...updateData } = args;
        if (!id) {
          throw new Error("ID is required for update");
        }
        const existing = await collection.get(id);
        if (!existing) {
          throw new Error("Object not found");
        }
        Object.assign(existing, updateData);
        if (this.context.user) {
          existing.updated_by = this.context.user.id;
        }
        await existing.save();
        return existing;
      }
      case "delete": {
        if (!args.id) {
          throw new Error("ID is required for delete");
        }
        const toDelete = await collection.get(args.id);
        if (!toDelete) {
          throw new Error("Object not found");
        }
        await toDelete.delete();
        return { success: true, message: "Object deleted successfully" };
      }
      default:
        return this.executeCustomAction(collection, action, args);
    }
  }
  /**
   * Execute a custom action on a collection/object
   */
  async executeCustomAction(collection, action, args) {
    const { id, options = {}, ...directArgs } = args;
    try {
      if (id) {
        const object = await collection.get(id);
        if (!object) {
          throw new Error("Object not found");
        }
        if (typeof object[action] === "function") {
          const methodArgs = Object.keys(options).length > 0 ? options : directArgs;
          const result = await object[action](methodArgs);
          return result;
        } else {
          throw new Error(`Method '${action}' not found on object instance`);
        }
      } else {
        if (typeof collection[action] === "function") {
          const methodArgs = Object.keys(options).length > 0 ? options : directArgs;
          const result = await collection[action](methodArgs);
          return result;
        } else {
          throw new Error(
            `Method '${action}' not found on collection. For object-specific actions, provide an 'id' parameter.`
          );
        }
      }
    } catch (error) {
      throw new Error(
        `Failed to execute custom action '${action}': ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Generate MCP server info
   */
  getServerInfo() {
    return {
      name: this.config.server?.name,
      version: this.config.server?.version,
      description: this.config.description
    };
  }
  /**
   * Generate complete MCP server with stdio transport
   *
   * Creates a runnable Node.js script that exposes SMRT objects as MCP tools.
   * The generated server includes:
   * - Stdio transport integration
   * - Tool registration from ObjectRegistry
   * - Error handling and logging
   * - Graceful shutdown
   *
   * @param options - Server generation options
   * @returns Promise that resolves when all files are written
   *
   * @example
   * ```typescript
   * const generator = new MCPGenerator({
   *   name: 'my-app',
   *   version: '1.0.0'
   * });
   *
   * await generator.generateServer({
   *   outputPath: 'dist/mcp-server.js',
   *   serverName: 'my-app-mcp',
   *   debug: true
   * });
   * ```
   */
  async generateServer(options = {}) {
    const {
      outputPath = "dist/mcp-server.js",
      serverName = this.config.name || "smrt-mcp-server",
      serverVersion = this.config.version || "1.0.0",
      debug = false,
      generateClaudeConfigFile = true,
      generateReadme = true
    } = options;
    const resolvedPath = resolve(process.cwd(), outputPath);
    const outputDir = dirname(resolvedPath);
    await mkdir(outputDir, { recursive: true });
    const runtimeOptions = {
      name: serverName,
      version: serverVersion,
      description: this.config.description,
      config: this.config,
      context: this.context,
      debug
    };
    const serverCode = generateRuntimeBootstrap(runtimeOptions);
    await writeFile(resolvedPath, serverCode, "utf-8");
    console.log(`✅ Generated MCP server: ${resolvedPath}`);
    if (generateClaudeConfigFile) {
      const claudeConfig = generateClaudeConfig(serverName, resolvedPath);
      const claudeConfigPath = resolve(outputDir, "claude-config.example.json");
      await writeFile(
        claudeConfigPath,
        JSON.stringify(claudeConfig, null, 2),
        "utf-8"
      );
      console.log(`✅ Generated Claude config example: ${claudeConfigPath}`);
    }
    if (generateReadme) {
      const readme = generateMCPDocumentation(serverName, outputPath);
      const readmePath = resolve(outputDir, "MCP-README.md");
      await writeFile(readmePath, readme, "utf-8");
      console.log(`✅ Generated MCP documentation: ${readmePath}`);
    }
    const mcpScript = generateMCPScript(outputPath);
    console.log(`
📝 Add this to your package.json scripts:`);
    console.log(`   "mcp": "${mcpScript}"
`);
  }
}
export {
  MCPGenerator
};
//# sourceMappingURL=mcp.js.map
