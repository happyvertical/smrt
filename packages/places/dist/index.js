var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _Place_decorators, _init, _a, _PlaceType_decorators, _init2, _b;
import { SmrtObject, smrt, SmrtCollection } from "@have/smrt";
import { getGeoAdapter } from "@have/geo";
_Place_decorators = [smrt({
  api: { include: ["list", "get", "create", "update", "delete"] },
  mcp: { include: ["list", "get", "create", "update"] },
  cli: true
})];
class Place extends (_a = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  // Core fields
  typeId = "";
  // FK to PlaceType
  parentId = "";
  // FK to parent Place for hierarchy (nullable)
  name = "";
  // Place name/title
  description = "";
  // Optional description
  // Optional geo fields (all nullable for abstract places)
  latitude = null;
  longitude = null;
  streetNumber = "";
  streetName = "";
  city = "";
  region = "";
  country = "";
  postalCode = "";
  countryCode = "";
  timezone = "";
  // Metadata
  externalId = "";
  // External system identifier
  source = "";
  // Where this place came from (e.g., 'google', 'osm')
  metadata = "";
  // JSON metadata stored as text
  // Timestamps
  createdAt = /* @__PURE__ */ new Date();
  updatedAt = /* @__PURE__ */ new Date();
  constructor(options = {}) {
    super(options);
    if (options.typeId) this.typeId = options.typeId;
    if (options.parentId !== void 0) this.parentId = options.parentId;
    if (options.name) this.name = options.name;
    if (options.description !== void 0)
      this.description = options.description;
    if (options.latitude !== void 0) this.latitude = options.latitude;
    if (options.longitude !== void 0) this.longitude = options.longitude;
    if (options.streetNumber !== void 0)
      this.streetNumber = options.streetNumber;
    if (options.streetName !== void 0) this.streetName = options.streetName;
    if (options.city !== void 0) this.city = options.city;
    if (options.region !== void 0) this.region = options.region;
    if (options.country !== void 0) this.country = options.country;
    if (options.postalCode !== void 0) this.postalCode = options.postalCode;
    if (options.countryCode !== void 0)
      this.countryCode = options.countryCode;
    if (options.timezone !== void 0) this.timezone = options.timezone;
    if (options.externalId !== void 0) this.externalId = options.externalId;
    if (options.source !== void 0) this.source = options.source;
    if (options.metadata !== void 0) {
      if (typeof options.metadata === "string") {
        this.metadata = options.metadata;
      } else {
        this.metadata = JSON.stringify(options.metadata);
      }
    }
    if (options.createdAt) this.createdAt = options.createdAt;
    if (options.updatedAt) this.updatedAt = options.updatedAt;
  }
  /**
   * Get geographic data for this place
   *
   * @returns GeoData object with all geo fields
   */
  getGeoData() {
    return {
      latitude: this.latitude,
      longitude: this.longitude,
      streetNumber: this.streetNumber || void 0,
      streetName: this.streetName || void 0,
      city: this.city || void 0,
      region: this.region || void 0,
      country: this.country || void 0,
      postalCode: this.postalCode || void 0,
      countryCode: this.countryCode || void 0,
      timezone: this.timezone || void 0
    };
  }
  /**
   * Check if this place has geographic coordinates
   *
   * @returns True if latitude and longitude are set
   */
  hasCoordinates() {
    return this.latitude !== null && this.longitude !== null;
  }
  /**
   * Get metadata as parsed object
   *
   * @returns Parsed metadata object or empty object if no metadata
   */
  getMetadata() {
    if (!this.metadata) return {};
    try {
      return JSON.parse(this.metadata);
    } catch {
      return {};
    }
  }
  /**
   * Set metadata from object
   *
   * @param data - Metadata object to store
   */
  setMetadata(data) {
    this.metadata = JSON.stringify(data);
  }
  /**
   * Update metadata by merging with existing values
   *
   * @param updates - Partial metadata to merge
   */
  updateMetadata(updates) {
    const current = this.getMetadata();
    this.setMetadata({ ...current, ...updates });
  }
  /**
   * Get the place type
   *
   * @returns PlaceType instance or null if not found
   */
  async getType() {
    if (!this.typeId) return null;
    const { PlaceTypeCollection: PlaceTypeCollection2 } = await Promise.resolve().then(() => PlaceTypeCollection$1);
    const collection = await PlaceTypeCollection2.create(this.options);
    return await collection.get({ id: this.typeId });
  }
  /**
   * Get the parent place
   *
   * @returns Parent Place instance or null if no parent
   */
  async getParent() {
    if (!this.parentId) return null;
    const { PlaceCollection: PlaceCollection2 } = await Promise.resolve().then(() => PlaceCollection$1);
    const collection = await PlaceCollection2.create(this.options);
    return await collection.get({ id: this.parentId });
  }
  /**
   * Get immediate child places
   *
   * @returns Array of child Place instances
   */
  async getChildren() {
    const { PlaceCollection: PlaceCollection2 } = await Promise.resolve().then(() => PlaceCollection$1);
    const collection = await PlaceCollection2.create(this.options);
    return await collection.list({ where: { parentId: this.id } });
  }
  /**
   * Get all ancestor places (recursive)
   *
   * @returns Array of ancestor places from root to immediate parent
   */
  async getAncestors() {
    const ancestors = [];
    let currentPlace = this;
    while (currentPlace && currentPlace.parentId) {
      const parent = await currentPlace.getParent();
      if (!parent) break;
      ancestors.unshift(parent);
      currentPlace = parent;
    }
    return ancestors;
  }
  /**
   * Get all descendant places (recursive)
   *
   * @returns Array of all descendant places
   */
  async getDescendants() {
    const children = await this.getChildren();
    const descendants = [...children];
    for (const child of children) {
      const childDescendants = await child.getDescendants();
      descendants.push(...childDescendants);
    }
    return descendants;
  }
  /**
   * Get full hierarchy for this place
   *
   * @returns PlaceHierarchy with ancestors, current, and descendants
   */
  async getHierarchy() {
    const [ancestors, descendants] = await Promise.all([
      this.getAncestors(),
      this.getDescendants()
    ]);
    return {
      ancestors,
      current: this,
      descendants
    };
  }
}
_init = __decoratorStart(_a);
Place = __decorateElement(_init, 0, "Place", _Place_decorators, Place);
__runInitializers(_init, 1, Place);
_PlaceType_decorators = [smrt({
  api: { include: ["list", "get", "create", "update", "delete"] },
  mcp: { include: ["list", "get", "create"] },
  cli: true
})];
class PlaceType extends (_b = SmrtObject) {
  // id and slug are inherited from SmrtObject
  // name is also inherited from SmrtObject
  description = "";
  // Optional description
  // Timestamps
  createdAt = /* @__PURE__ */ new Date();
  updatedAt = /* @__PURE__ */ new Date();
  constructor(options = {}) {
    super(options);
    if (options.description !== void 0)
      this.description = options.description;
    if (options.createdAt) this.createdAt = options.createdAt;
    if (options.updatedAt) this.updatedAt = options.updatedAt;
  }
  /**
   * Convenience method for slug-based lookup
   *
   * @param slug - The slug to search for
   * @returns PlaceType instance or null if not found
   */
  static async getBySlug(slug) {
    return null;
  }
}
_init2 = __decoratorStart(_b);
PlaceType = __decorateElement(_init2, 0, "PlaceType", _PlaceType_decorators, PlaceType);
__runInitializers(_init2, 1, PlaceType);
class PlaceTypeCollection extends SmrtCollection {
  static _itemClass = PlaceType;
  /**
   * Get or create a place type by slug
   *
   * @param slug - PlaceType slug (e.g., 'city', 'building')
   * @param name - Optional display name (defaults to capitalized slug)
   * @returns PlaceType instance
   */
  async getOrCreate(slug, name) {
    const existing = await this.get({ slug });
    if (existing) {
      return existing;
    }
    const displayName = name || slug.replace(/-/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
    return await this.create({
      slug,
      name: displayName
    });
  }
  /**
   * Get a place type by slug
   *
   * @param slug - PlaceType slug to search for
   * @returns PlaceType instance or null if not found
   */
  async getBySlug(slug) {
    return await this.get({ slug });
  }
  /**
   * Initialize default place types
   *
   * Creates standard types if they don't exist:
   * - country
   * - region (state/province)
   * - city
   * - address
   * - building
   * - room
   * - zone (for abstract/virtual places)
   *
   * @returns Array of created/existing place types
   */
  async initializeDefaults() {
    const defaults = [
      { slug: "country", name: "Country" },
      { slug: "region", name: "Region" },
      { slug: "city", name: "City" },
      { slug: "address", name: "Address" },
      { slug: "building", name: "Building" },
      { slug: "room", name: "Room" },
      { slug: "zone", name: "Zone" },
      { slug: "point_of_interest", name: "Point of Interest" }
    ];
    const types = [];
    for (const def of defaults) {
      const type = await this.getOrCreate(def.slug, def.name);
      types.push(type);
    }
    return types;
  }
}
const PlaceTypeCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PlaceTypeCollection
}, Symbol.toStringTag, { value: "Module" }));
class PlaceCollection extends SmrtCollection {
  static _itemClass = Place;
  /**
   * Look up a place by query or coordinates, creating it if not found
   *
   * This is the key method for organic database growth:
   * 1. Search local database first
   * 2. If not found, query @have/geo
   * 3. Create place from geocoding result
   * 4. Return place
   *
   * @param query - Address or location query string
   * @param options - Lookup options (provider, type, parent, etc.)
   * @returns Place instance
   */
  async lookupOrCreate(query, options = {}) {
    const {
      geoProvider = "openstreetmap",
      typeSlug,
      parentId,
      createIfNotFound = true,
      coords
    } = options;
    let existingPlace = null;
    if (coords) {
      existingPlace = await this.findByCoordinates(coords.lat, coords.lng);
    }
    if (!existingPlace) {
      existingPlace = await this.findByQuery(query);
    }
    if (existingPlace) {
      return existingPlace;
    }
    if (!createIfNotFound) {
      return null;
    }
    const locations = await this.geocode(
      query,
      coords,
      geoProvider
    );
    if (locations.length === 0) {
      return null;
    }
    const location = locations[0];
    return await this.createFromLocation(location, typeSlug, parentId);
  }
  /**
   * Find place by coordinates (within small threshold)
   *
   * @param latitude - Latitude to search
   * @param longitude - Longitude to search
   * @param threshold - Max distance in degrees (default: 0.0001 ~11m)
   * @returns Place instance or null
   */
  async findByCoordinates(latitude, longitude, threshold = 1e-4) {
    const places = await this.list({
      where: {
        latitude: { $ne: null },
        longitude: { $ne: null }
      }
    });
    for (const place of places) {
      if (place.latitude === null || place.longitude === null) continue;
      const latDiff = Math.abs(place.latitude - latitude);
      const lngDiff = Math.abs(place.longitude - longitude);
      if (latDiff < threshold && lngDiff < threshold) {
        return place;
      }
    }
    return null;
  }
  /**
   * Find place by query text (matches name, city, region, country)
   *
   * @param query - Search query
   * @returns Place instance or null
   */
  async findByQuery(query) {
    const normalizedQuery = query.toLowerCase().trim();
    const places = await this.list({});
    for (const place of places) {
      if (place.name.toLowerCase().includes(normalizedQuery)) {
        return place;
      }
      const addressParts = [
        place.streetNumber,
        place.streetName,
        place.city,
        place.region,
        place.country
      ].filter((p) => p).join(" ").toLowerCase();
      if (addressParts.includes(normalizedQuery)) {
        return place;
      }
    }
    return null;
  }
  /**
   * Geocode query or coordinates using @have/geo
   *
   * @param query - Address query
   * @param coords - Optional coordinates for reverse geocoding
   * @param provider - Geo provider to use
   * @returns Array of Location results
   */
  async geocode(query, coords, provider = "openstreetmap") {
    const geoOptions = provider === "google" ? {
      provider: "google",
      apiKey: process.env.GOOGLE_MAPS_API_KEY || ""
    } : {
      provider: "openstreetmap",
      userAgent: "@have/places"
    };
    const geo = await getGeoAdapter(geoOptions);
    if (coords) {
      return await geo.reverseGeocode(coords.lat, coords.lng);
    }
    return await geo.lookup(query);
  }
  /**
   * Create place from @have/geo Location data
   *
   * @param location - Location from geocoding
   * @param typeSlug - Optional type slug override
   * @param parentId - Optional parent place ID
   * @returns Created Place instance
   */
  async createFromLocation(location, typeSlug, parentId) {
    const typeCollection = await PlaceTypeCollection.create(this.options);
    const slug = typeSlug || location.type || "address";
    const placeType = await typeCollection.getOrCreate(slug);
    const components = location.addressComponents || {};
    return await this.create({
      typeId: placeType.id,
      parentId: parentId || "",
      name: location.name,
      description: "",
      // Geo fields from location
      latitude: location.latitude,
      longitude: location.longitude,
      streetNumber: components.streetNumber || "",
      streetName: components.streetName || "",
      city: components.city || "",
      region: components.region || "",
      country: components.country || "",
      postalCode: components.postalCode || "",
      countryCode: location.countryCode || "",
      timezone: location.timezone || "",
      // Metadata
      externalId: location.id,
      source: location.raw?.provider || "unknown",
      metadata: { raw: location.raw }
    });
  }
  /**
   * Get immediate children of a parent place
   *
   * @param parentId - The parent place ID
   * @returns Array of child places
   */
  async getChildren(parentId) {
    return await this.list({
      where: { parentId }
    });
  }
  /**
   * Get root places (no parent)
   *
   * @returns Array of root places
   */
  async getRootPlaces() {
    return await this.list({
      where: { parentId: "" }
    });
  }
  /**
   * Get places by type
   *
   * @param typeSlug - PlaceType slug
   * @returns Array of places of that type
   */
  async getByType(typeSlug) {
    const typeCollection = await PlaceTypeCollection.create(this.options);
    const placeType = await typeCollection.getBySlug(typeSlug);
    if (!placeType) return [];
    return await this.list({
      where: { typeId: placeType.id }
    });
  }
  /**
   * Get place hierarchy (all ancestors and descendants)
   *
   * @param placeId - The place ID
   * @returns Object with ancestors, current place, and descendants
   */
  async getHierarchy(placeId) {
    const place = await this.get({ id: placeId });
    if (!place) throw new Error(`Place '${placeId}' not found`);
    return await place.getHierarchy();
  }
  /**
   * Search places by proximity to coordinates
   *
   * @param latitude - Center latitude
   * @param longitude - Center longitude
   * @param radiusKm - Search radius in kilometers
   * @returns Array of places within radius, sorted by distance
   */
  async searchByProximity(latitude, longitude, radiusKm = 10) {
    const places = await this.list({
      where: {
        latitude: { $ne: null },
        longitude: { $ne: null }
      }
    });
    const placesWithDistance = places.map((place) => {
      if (place.latitude === null || place.longitude === null) return null;
      const distance = this.calculateDistance(
        latitude,
        longitude,
        place.latitude,
        place.longitude
      );
      return { place, distance };
    }).filter((p) => p !== null && p.distance <= radiusKm).sort((a, b) => a.distance - b.distance);
    return placesWithDistance.map((p) => p.place);
  }
  /**
   * Calculate distance between two coordinates using Haversine formula
   *
   * @param lat1 - First latitude
   * @param lng1 - First longitude
   * @param lat2 - Second latitude
   * @param lng2 - Second longitude
   * @returns Distance in kilometers
   */
  calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371;
    const dLat = this.toRad(lat2 - lat1);
    const dLng = this.toRad(lng2 - lng1);
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  /**
   * Convert degrees to radians
   */
  toRad(degrees) {
    return degrees * (Math.PI / 180);
  }
}
const PlaceCollection$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PlaceCollection
}, Symbol.toStringTag, { value: "Module" }));
function mapLocationTypeToPlaceType(locationType) {
  const typeMap = {
    // Standard types
    country: "country",
    region: "region",
    city: "city",
    address: "address",
    point_of_interest: "point_of_interest",
    // Additional mappings
    state: "region",
    province: "region",
    town: "city",
    village: "city",
    building: "building",
    room: "room",
    zone: "zone"
  };
  return typeMap[locationType.toLowerCase()] || "address";
}
function locationToGeoData(location) {
  const components = location.addressComponents || {};
  return {
    latitude: location.latitude,
    longitude: location.longitude,
    streetNumber: components.streetNumber,
    streetName: components.streetName,
    city: components.city,
    region: components.region,
    country: components.country,
    postalCode: components.postalCode,
    countryCode: location.countryCode,
    timezone: location.timezone
  };
}
function validateCoordinates(latitude, longitude) {
  if (latitude < -90 || latitude > 90) {
    return { valid: false, error: "Invalid latitude (must be -90 to 90)" };
  }
  if (longitude < -180 || longitude > 180) {
    return { valid: false, error: "Invalid longitude (must be -180 to 180)" };
  }
  return { valid: true };
}
function calculateDistance(lat1, lng1, lat2, lng2) {
  const R = 6371;
  const dLat = toRad(lat2 - lat1);
  const dLng = toRad(lng2 - lng1);
  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}
function toRad(degrees) {
  return degrees * (Math.PI / 180);
}
function formatCoordinates(latitude, longitude, precision = 6) {
  return `${latitude.toFixed(precision)}, ${longitude.toFixed(precision)}`;
}
function parseCoordinates(coordString) {
  const parts = coordString.trim().replace(/\s+/g, " ").replace(/,\s*/g, ",").split(/[,\s]+/);
  if (parts.length !== 2) return null;
  const lat = parseFloat(parts[0]);
  const lng = parseFloat(parts[1]);
  if (isNaN(lat) || isNaN(lng)) return null;
  const validation = validateCoordinates(lat, lng);
  if (!validation.valid) return null;
  return { lat, lng };
}
function normalizeAddressComponents(components) {
  const normalized = {};
  for (const [key, value] of Object.entries(components)) {
    if (value === null || value === void 0) continue;
    if (typeof value === "string") {
      const trimmed = value.trim();
      if (trimmed) {
        normalized[key] = trimmed;
      }
    } else {
      normalized[key] = value;
    }
  }
  return normalized;
}
function generateDisplayName(components) {
  const parts = [];
  if (components.streetNumber && components.streetName) {
    parts.push(`${components.streetNumber} ${components.streetName}`);
  } else if (components.streetName) {
    parts.push(components.streetName);
  }
  if (components.city) parts.push(components.city);
  if (components.region) parts.push(components.region);
  if (components.country) parts.push(components.country);
  return parts.join(", ");
}
function areCoordinatesNear(lat1, lng1, lat2, lng2, thresholdKm = 0.1) {
  const distance = calculateDistance(lat1, lng1, lat2, lng2);
  return distance <= thresholdKm;
}
export {
  Place,
  PlaceCollection,
  PlaceType,
  PlaceTypeCollection,
  areCoordinatesNear,
  calculateDistance,
  formatCoordinates,
  generateDisplayName,
  locationToGeoData,
  mapLocationTypeToPlaceType,
  normalizeAddressComponents,
  parseCoordinates,
  validateCoordinates
};
//# sourceMappingURL=index.js.map
