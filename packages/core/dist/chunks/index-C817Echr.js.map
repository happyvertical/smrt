{"version":3,"file":"index-C817Echr.js","sources":["../../../../node_modules/.pnpm/@isaacs+balanced-match@4.0.1/node_modules/@isaacs/balanced-match/dist/esm/index.js","../../../../node_modules/.pnpm/@isaacs+brace-expansion@5.0.0/node_modules/@isaacs/brace-expansion/dist/esm/index.js","../../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/assert-valid-pattern.js","../../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/brace-expressions.js","../../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/unescape.js","../../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/ast.js","../../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/escape.js","../../../../node_modules/.pnpm/minimatch@10.0.3/node_modules/minimatch/dist/esm/index.js"],"sourcesContent":["export const balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nexport const range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map","import { balanced } from '@isaacs/balanced-match';\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = balanced('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nexport function expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = balanced('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map","const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map","/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map","// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map","/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map","import { expand } from '@isaacs/brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map"],"names":["regExpEscape","qmark","star","i","acc","ext","start","final"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}