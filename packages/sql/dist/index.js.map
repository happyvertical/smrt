{"version":3,"file":"index.js","sources":["../src/shared/utils.ts","../src/schema-manager.ts","../src/index.ts"],"sourcesContent":["/**\n * Shared SQL utilities that work in both browser and Node.js environments\n */\n\n/**\n * Map of valid SQL operators for use in WHERE clauses\n */\nconst VALID_OPERATORS = {\n  '=': '=',\n  '>': '>',\n  '>=': '>=',\n  '<': '<',\n  '<=': '<=',\n  '!=': '!=',\n  like: 'LIKE',\n  in: 'IN',\n} as const;\n\n/**\n * Builds a SQL WHERE clause with parameterized values and flexible operators\n *\n * @param where - Record of conditions with optional operators in keys\n * @param startIndex - Starting index for parameter numbering (default: 1)\n * @returns Object containing the SQL clause and array of values\n *\n * @example Basic Usage:\n * ```typescript\n * buildWhere({\n *   'status': 'active',           // equals operator is default\n *   'price >': 100,              // greater than\n *   'stock <=': 5,               // less than or equal\n *   'category in': ['A', 'B'],   // IN clause for arrays\n *   'name like': '%shirt%'       // LIKE for pattern matching\n * });\n * ```\n *\n * @example NULL Handling:\n * ```typescript\n * buildWhere({\n *   'deleted_at': null,          // becomes \"deleted_at IS NULL\"\n *   'updated_at !=': null,       // becomes \"updated_at IS NOT NULL\"\n *   'status': 'active'           // regular comparison\n * });\n * ```\n *\n * @example Common Patterns:\n * ```typescript\n * // Price range\n * buildWhere({\n *   'price >=': 10,\n *   'price <': 100\n * });\n *\n * // Date filtering\n * buildWhere({\n *   'created_at >': startDate,\n *   'created_at <=': endDate,\n *   'deleted_at': null\n * });\n *\n * // Search with LIKE\n * buildWhere({\n *   'title like': '%search%',\n *   'description like': '%search%',\n *   'status': 'published'\n * });\n *\n * // Multiple values with IN\n * buildWhere({\n *   'role in': ['admin', 'editor'],\n *   'active': true,\n *   'last_login !=': null\n * });\n * ```\n *\n * The function handles:\n * - Standard comparisons (=, >, >=, <, <=, !=)\n * - NULL checks (IS NULL, IS NOT NULL)\n * - IN clauses for arrays\n * - LIKE for pattern matching\n * - Multiple conditions combined with AND\n */\nexport const buildWhere = (where: Record<string, any>, startIndex = 1) => {\n  let sql = '';\n  const values: any[] = [];\n  let currIndex = startIndex;\n\n  if (where && Object.keys(where).length > 0) {\n    sql = 'WHERE ';\n    for (const [fullKey, value] of Object.entries(where)) {\n      const [field, operator = '='] = fullKey.split(' ');\n      const sqlOperator =\n        VALID_OPERATORS[operator as keyof typeof VALID_OPERATORS] || '=';\n\n      if (sql !== 'WHERE ') {\n        sql += ' AND ';\n      }\n\n      if (value === null) {\n        sql += `${field} IS ${sqlOperator === '=' ? 'NULL' : 'NOT NULL'}`;\n      } else if (sqlOperator === 'IN' && Array.isArray(value)) {\n        const placeholders = value.map(() => `$${currIndex++}`).join(', ');\n        sql += `${field} IN (${placeholders})`;\n        values.push(...value);\n      } else {\n        sql += `${field} ${sqlOperator} $${currIndex++}`;\n        values.push(value);\n      }\n    }\n  }\n\n  return { sql, values };\n};\n","/**\n * Schema management and dependency resolution for JSON manifests\n * Moved from SMRT package to SQL package for proper separation of concerns\n */\n\nimport type {\n  DatabaseInterface,\n  SchemaDefinition,\n  SchemaManifest,\n  SchemaInitializationOptions,\n  ColumnDefinition,\n  IndexDefinition,\n  TriggerDefinition,\n  ForeignKeyDefinition,\n} from './shared/types.js';\n\nexport interface SchemaInitializationResult {\n  initialized: string[];\n  skipped: string[];\n  errors: Array<{ schema: string; error: string }>;\n  executionTime: number;\n}\n\nexport class DatabaseSchemaManager {\n  private static initializationLock = new Map<string, Promise<void>>();\n  private initializedSchemas = new Set<string>();\n  private schemaVersions = new Map<string, string>();\n\n  /**\n   * Initialize schemas with dependency resolution\n   */\n  async initializeSchemas(\n    db: DatabaseInterface,\n    options: SchemaInitializationOptions,\n  ): Promise<SchemaInitializationResult> {\n    const startTime = Date.now();\n    const result: SchemaInitializationResult = {\n      initialized: [],\n      skipped: [],\n      errors: [],\n      executionTime: 0,\n    };\n\n    try {\n      let schemas: Record<string, SchemaDefinition> = {};\n\n      // Handle legacy SQL schema format\n      if (options.schema) {\n        console.log(\n          '[schema] Legacy SQL schema provided, converting to manifest format',\n        );\n        // For legacy support, we'll still use the original syncSchema method\n        if (db.syncSchema) {\n          await db.syncSchema(options.schema);\n          result.initialized.push('legacy-sql');\n        }\n        result.executionTime = Date.now() - startTime;\n        return result;\n      }\n\n      // Handle JSON manifest format\n      if (options.manifest) {\n        schemas = { ...options.manifest.schemas };\n      }\n\n      // Apply schema overrides\n      if (options.overrides) {\n        schemas = { ...schemas, ...options.overrides };\n      }\n\n      if (Object.keys(schemas).length === 0) {\n        console.warn('[schema] No schemas provided for initialization');\n        result.executionTime = Date.now() - startTime;\n        return result;\n      }\n\n      // Build dependency graph\n      const dependencyGraph = this.buildDependencyGraph(schemas);\n\n      // Get initialization order\n      const initializationOrder = this.resolveDependencies(dependencyGraph);\n\n      if (options.debug) {\n        console.log('[schema] Initialization order:', initializationOrder);\n      }\n\n      // Initialize schemas in dependency order\n      for (const schemaName of initializationOrder) {\n        const schema = schemas[schemaName];\n        if (!schema) continue;\n\n        try {\n          await this.initializeSchema(db, schemaName, schema, {\n            force: options.force,\n            debug: options.debug,\n          });\n          result.initialized.push(schemaName);\n        } catch (error) {\n          const errorMessage =\n            error instanceof Error ? error.message : String(error);\n          result.errors.push({ schema: schemaName, error: errorMessage });\n\n          if (options.debug) {\n            console.error(\n              `[schema] Failed to initialize ${schemaName}:`,\n              error,\n            );\n          }\n        }\n      }\n\n      result.executionTime = Date.now() - startTime;\n\n      if (options.debug) {\n        console.log('[schema] Initialization complete:', result);\n      }\n\n      return result;\n    } catch (error) {\n      result.executionTime = Date.now() - startTime;\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      result.errors.push({\n        schema: 'dependency-resolution',\n        error: errorMessage,\n      });\n      return result;\n    }\n  }\n\n  /**\n   * Initialize a single schema\n   */\n  private async initializeSchema(\n    db: DatabaseInterface,\n    schemaName: string,\n    schema: SchemaDefinition,\n    options: { force?: boolean; debug?: boolean },\n  ): Promise<void> {\n    const { tableName, version } = schema;\n    const lockKey = `${schemaName}:${tableName}`;\n\n    // Check if already being initialized\n    if (DatabaseSchemaManager.initializationLock.has(lockKey)) {\n      await DatabaseSchemaManager.initializationLock.get(lockKey);\n      return;\n    }\n\n    // Check if already initialized and up to date\n    if (!options.force && this.isSchemaUpToDate(schemaName, version)) {\n      if (options.debug) {\n        console.log(`[schema] Skipping ${schemaName} - already up to date`);\n      }\n      return;\n    }\n\n    // Create initialization promise\n    const initPromise = this.performSchemaInitialization(\n      db,\n      schemaName,\n      schema,\n      options,\n    );\n    DatabaseSchemaManager.initializationLock.set(lockKey, initPromise);\n\n    try {\n      await initPromise;\n      this.markSchemaInitialized(schemaName, version);\n    } finally {\n      DatabaseSchemaManager.initializationLock.delete(lockKey);\n    }\n  }\n\n  /**\n   * Perform the actual schema initialization\n   */\n  private async performSchemaInitialization(\n    db: DatabaseInterface,\n    schemaName: string,\n    schema: SchemaDefinition,\n    options: { force?: boolean; debug?: boolean },\n  ): Promise<void> {\n    const { tableName, columns, indexes, triggers } = schema;\n\n    if (options.debug) {\n      console.log(`[schema] Initializing ${schemaName} (${tableName})`);\n    }\n\n    // Check if table exists\n    const tableExists = await db.tableExists(tableName);\n\n    if (!tableExists) {\n      // Create table\n      await this.createTable(db, schema);\n\n      // Create indexes\n      for (const index of indexes) {\n        await this.createIndex(db, tableName, index);\n      }\n\n      // Create triggers\n      for (const trigger of triggers) {\n        await this.createTrigger(db, trigger);\n      }\n    } else if (options.force) {\n      // Recreate table if forced\n      await db.query(`DROP TABLE IF EXISTS ${tableName}`);\n      await this.createTable(db, schema);\n\n      for (const index of indexes) {\n        await this.createIndex(db, tableName, index);\n      }\n\n      for (const trigger of triggers) {\n        await this.createTrigger(db, trigger);\n      }\n    } else {\n      // Table exists, check for schema changes\n      await this.updateSchemaIfNeeded(db, schema);\n    }\n  }\n\n  /**\n   * Create table from schema definition\n   */\n  private async createTable(\n    db: DatabaseInterface,\n    schema: SchemaDefinition,\n  ): Promise<void> {\n    const { tableName, columns, foreignKeys } = schema;\n\n    const columnDefinitions: string[] = [];\n\n    // Add column definitions\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      let def = `${columnName} ${columnDef.type}`;\n\n      if (columnDef.primaryKey) def += ' PRIMARY KEY';\n      if (columnDef.unique && !columnDef.primaryKey) def += ' UNIQUE';\n      if (columnDef.notNull) def += ' NOT NULL';\n      if (columnDef.defaultValue !== undefined) {\n        def += ` DEFAULT ${columnDef.defaultValue}`;\n      }\n      if (columnDef.check) def += ` CHECK (${columnDef.check})`;\n\n      columnDefinitions.push(def);\n    }\n\n    // Add foreign key constraints\n    for (const fk of foreignKeys) {\n      let fkDef = `FOREIGN KEY (${fk.column}) REFERENCES ${fk.referencesTable}(${fk.referencesColumn})`;\n      if (fk.onDelete) fkDef += ` ON DELETE ${fk.onDelete}`;\n      if (fk.onUpdate) fkDef += ` ON UPDATE ${fk.onUpdate}`;\n      columnDefinitions.push(fkDef);\n    }\n\n    const createTableSQL = `CREATE TABLE ${tableName} (\\n  ${columnDefinitions.join(',\\n  ')}\\n)`;\n    await db.query(createTableSQL);\n  }\n\n  /**\n   * Create index from definition\n   */\n  private async createIndex(\n    db: DatabaseInterface,\n    tableName: string,\n    index: IndexDefinition,\n  ): Promise<void> {\n    const uniqueClause = index.unique ? 'UNIQUE ' : '';\n    const whereClause = index.where ? ` WHERE ${index.where}` : '';\n    const createIndexSQL = `CREATE ${uniqueClause}INDEX ${index.name} ON ${tableName} (${index.columns.join(', ')})${whereClause}`;\n\n    await db.query(createIndexSQL);\n  }\n\n  /**\n   * Create trigger from definition\n   */\n  private async createTrigger(\n    db: DatabaseInterface,\n    trigger: TriggerDefinition,\n  ): Promise<void> {\n    const conditionClause = trigger.condition\n      ? ` WHEN ${trigger.condition}`\n      : '';\n    const createTriggerSQL = `CREATE TRIGGER ${trigger.name} ${trigger.when} ${trigger.event} ON ${trigger.table}${conditionClause} BEGIN ${trigger.body} END`;\n\n    await db.query(createTriggerSQL);\n  }\n\n  /**\n   * Update schema if changes are detected\n   */\n  private async updateSchemaIfNeeded(\n    db: DatabaseInterface,\n    schema: SchemaDefinition,\n  ): Promise<void> {\n    // For now, just log that update is needed\n    // In future, implement ALTER TABLE logic\n    console.log(\n      `[schema] Schema update logic not yet implemented for ${schema.tableName}`,\n    );\n  }\n\n  /**\n   * Build dependency graph from schemas\n   */\n  private buildDependencyGraph(\n    schemas: Record<string, SchemaDefinition>,\n  ): Map<string, string[]> {\n    const graph = new Map<string, string[]>();\n\n    for (const [schemaName, schema] of Object.entries(schemas)) {\n      const dependencies = schema.dependencies.filter((dep) =>\n        Object.values(schemas).some((s) => s.tableName === dep),\n      );\n      graph.set(\n        schemaName,\n        dependencies.map(\n          (dep) =>\n            Object.entries(schemas).find(\n              ([_, s]) => s.tableName === dep,\n            )?.[0] || dep,\n        ),\n      );\n    }\n\n    return graph;\n  }\n\n  /**\n   * Resolve dependencies using topological sort\n   */\n  private resolveDependencies(graph: Map<string, string[]>): string[] {\n    const resolved: string[] = [];\n    const visited = new Set<string>();\n    const visiting = new Set<string>();\n\n    const visit = (node: string) => {\n      if (visiting.has(node)) {\n        throw new Error(`Circular dependency detected involving ${node}`);\n      }\n      if (visited.has(node)) return;\n\n      visiting.add(node);\n      const dependencies = graph.get(node) || [];\n\n      for (const dep of dependencies) {\n        if (graph.has(dep)) {\n          visit(dep);\n        }\n      }\n\n      visiting.delete(node);\n      visited.add(node);\n      resolved.push(node);\n    };\n\n    for (const node of graph.keys()) {\n      if (!visited.has(node)) {\n        visit(node);\n      }\n    }\n\n    return resolved;\n  }\n\n  /**\n   * Check if schema is up to date\n   */\n  private isSchemaUpToDate(schemaName: string, version: string): boolean {\n    return (\n      this.initializedSchemas.has(schemaName) &&\n      this.schemaVersions.get(schemaName) === version\n    );\n  }\n\n  /**\n   * Mark schema as initialized\n   */\n  private markSchemaInitialized(schemaName: string, version: string): void {\n    this.initializedSchemas.add(schemaName);\n    this.schemaVersions.set(schemaName, version);\n  }\n\n  /**\n   * Reset initialization state (for testing)\n   */\n  reset(): void {\n    this.initializedSchemas.clear();\n    this.schemaVersions.clear();\n    DatabaseSchemaManager.initializationLock.clear();\n  }\n}\n","import type { PostgresOptions } from './postgres';\nimport type { DatabaseInterface, DuckDBOptions, JSONOptions } from './shared/types';\nimport type { SqliteOptions } from './sqlite';\n\n/**\n * Union type of options for creating different database types\n */\ntype GetDatabaseOptions =\n  | (PostgresOptions & { type?: 'postgres' })\n  | (SqliteOptions & { type?: 'sqlite' })\n  | (DuckDBOptions & { type?: 'duckdb' })\n  | JSONOptions;\n\n/**\n * Checks if the provided value is a database instance rather than configuration options\n *\n * @param value - Value to check\n * @returns True if the value appears to be a DatabaseInterface instance\n */\nfunction isDatabaseInstance(value: any): value is DatabaseInterface {\n  return (\n    value &&\n    typeof value === 'object' &&\n    typeof value.client !== 'undefined' &&\n    typeof value.insert === 'function' &&\n    typeof value.get === 'function' &&\n    typeof value.query === 'function'\n  );\n}\n\n/**\n * Creates a database connection based on the provided options, or returns an existing database instance\n *\n * @param options - Configuration options for the database connection or an existing database instance\n * @returns Promise resolving to a DatabaseInterface implementation\n * @throws Error if the database type is invalid\n */\nexport async function getDatabase(\n  options: GetDatabaseOptions | DatabaseInterface = {},\n): Promise<DatabaseInterface> {\n  // If a database instance is passed, return it directly\n  if (isDatabaseInstance(options)) {\n    return options;\n  }\n  // if no type but url starts with file:, set to sqlite\n  if (\n    !options.type &&\n    (options.url?.startsWith('file:') || options.url === ':memory:')\n  ) {\n    options.type = 'sqlite';\n  }\n\n  if (options.type === 'postgres') {\n    const postgres = await import('./postgres.js');\n    return postgres.getDatabase(options as PostgresOptions);\n  }\n  if (options.type === 'sqlite') {\n    const sqlite = await import('./sqlite.js');\n    return sqlite.getDatabase(options as SqliteOptions);\n  }\n  if (options.type === 'duckdb') {\n    const duckdb = await import('./duckdb.js');\n    return duckdb.getDatabase(options as DuckDBOptions);\n  }\n  if (options.type === 'json') {\n    const json = await import('./json.js');\n    return json.getDatabase(options as JSONOptions);\n  }\n  throw new Error('Invalid database type');\n}\n\n/**\n * Validates if a table name consists only of alphanumeric characters and underscores\n *\n * @param name - Table name to validate\n * @returns Boolean indicating if the name is valid\n */\nfunction _isValidTableName(name: string): boolean {\n  // Simple regex to allow only alphanumeric characters and underscores\n  return /^[a-zA-Z0-9_]+$/.test(name);\n}\n\n/**\n * Synchronizes a SQL schema definition with a database\n * Creates tables if they don't exist and adds missing columns to existing tables\n *\n * @param options - Object containing database and schema\n * @param options.db - Database interface to use\n * @param options.schema - SQL schema definition\n * @throws Error if db or schema are missing or if the database doesn't support syncSchema\n */\nexport async function syncSchema(options: {\n  db: DatabaseInterface;\n  schema: string;\n}) {\n  const { db, schema } = options;\n  if (!db || !schema) {\n    throw new Error('db and schema are required');\n  }\n\n  // Delegate to the database adapter's syncSchema implementation\n  if (db.syncSchema) {\n    await db.syncSchema(schema);\n  } else {\n    throw new Error('Database adapter does not support schema synchronization');\n  }\n}\n\n/**\n * Checks if a table exists in the database\n *\n * @param db - Database interface to use\n * @param tableName - Name of the table to check\n * @returns Promise resolving to boolean indicating if the table exists\n */\nexport async function tableExists(db: DatabaseInterface, tableName: string) {\n  return db.tableExists(tableName);\n}\n\n/**\n * Escapes and formats a value for use in SQL queries\n *\n * @param value - Value to escape\n * @returns String representation of the value safe for SQL use\n */\nexport function escapeSqlValue(value: any): string {\n  if (value === null) {\n    return 'NULL';\n  }\n  if (value instanceof Date) {\n    return `'${value.toISOString()}'`;\n  }\n  if (typeof value === 'number') {\n    return value.toString();\n  }\n  if (typeof value === 'boolean') {\n    return value ? '1' : '0';\n  }\n  // Escape single quotes and wrap in quotes\n  return `'${String(value).replace(/'/g, \"''\")}'`;\n}\n\n/**\n * Validates a column name for use in SQL queries\n *\n * @param column - Column name to validate\n * @returns The validated column name\n * @throws Error if the column name contains invalid characters\n */\nexport function validateColumnName(column: string): string {\n  // Only allow alphanumeric characters, underscores, and dots (for table.column notation)\n  if (!/^[a-zA-Z0-9_.]+$/.test(column)) {\n    throw new Error(`Invalid column name: ${column}`);\n  }\n  return column;\n}\n\n// Import buildWhere from shared utils\nimport { buildWhere } from './shared/utils';\nexport { buildWhere };\n\n// Export schema management\nexport { DatabaseSchemaManager } from './schema-manager';\nexport type { SchemaInitializationResult } from './schema-manager';\n\nexport * from './shared/types';\n\nexport default { getDatabase, syncSchema, tableExists, buildWhere };\n"],"names":["tableExists","index"],"mappings":"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"}