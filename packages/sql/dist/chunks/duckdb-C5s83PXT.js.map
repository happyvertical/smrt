{"version":3,"file":"duckdb-C5s83PXT.js","sources":["../../src/duckdb.ts"],"sourcesContent":["import { DatabaseError } from '@have/utils';\nimport type {\n  DatabaseInterface,\n  QueryResult,\n  TableInterface,\n  DuckDBOptions,\n  SchemaInitializationOptions,\n} from './shared/types';\nimport { buildWhere } from './shared/utils';\nimport { DatabaseSchemaManager } from './schema-manager';\nimport { readdir } from 'node:fs/promises';\nimport { join, basename, extname } from 'node:path';\n\n/**\n * Creates a DuckDB connection instance\n *\n * @param options - DuckDB connection options\n * @returns Promise resolving to a DuckDB connection\n */\nasync function createDuckDBConnection(options: DuckDBOptions) {\n  const {\n    url = ':memory:',\n    dataDir = './data',\n    autoRegisterJSON = true,\n  } = options;\n\n  try {\n    // Dynamic import to avoid bundling\n    const duckdbModule = '@duckdb/node-api';\n    const { DuckDBInstance } = await import(/* @vite-ignore */ duckdbModule);\n\n    // Create DuckDB instance\n    const instance = await DuckDBInstance.create(url);\n    const connection = await instance.connect();\n\n    // Auto-register JSON files if enabled\n    if (autoRegisterJSON && dataDir) {\n      await registerJSONFiles(connection, dataDir);\n    }\n\n    return connection;\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new DatabaseError(`Failed to create DuckDB connection: ${errorMessage}`, {\n      url,\n      originalError: errorMessage,\n    });\n  }\n}\n\n/**\n * Scans the data directory and registers JSON files as queryable tables\n *\n * @param connection - DuckDB connection\n * @param dataDir - Directory containing JSON files\n */\nasync function registerJSONFiles(connection: any, dataDir: string) {\n  try {\n    const files = await readdir(dataDir);\n    const jsonFiles = files.filter((file) => extname(file).toLowerCase() === '.json');\n\n    for (const file of jsonFiles) {\n      const filePath = join(dataDir, file);\n      const tableName = basename(file, '.json');\n\n      // Create view that reads from JSON file\n      // DuckDB automatically infers schema\n      await connection.run(\n        `CREATE OR REPLACE VIEW ${tableName} AS SELECT * FROM read_json('${filePath}', auto_detect=true, format='auto')`\n      );\n    }\n  } catch (error) {\n    // If directory doesn't exist, that's okay - user might not have JSON files yet\n    if ((error as any).code !== 'ENOENT') {\n      throw new DatabaseError(`Failed to register JSON files from ${dataDir}`, {\n        dataDir,\n        originalError: error instanceof Error ? error.message : String(error),\n      });\n    }\n  }\n}\n\n/**\n * Converts BigInt values to regular numbers in an object\n *\n * @param obj - Object that may contain BigInt values\n * @returns Object with BigInts converted to numbers\n */\nfunction convertBigInts(obj: any): any {\n  if (obj === null || obj === undefined) return obj;\n  if (typeof obj === 'bigint') return Number(obj);\n  if (Array.isArray(obj)) return obj.map(convertBigInts);\n  if (typeof obj === 'object') {\n    const result: any = {};\n    for (const key in obj) {\n      result[key] = convertBigInts(obj[key]);\n    }\n    return result;\n  }\n  return obj;\n}\n\n/**\n * Creates a DuckDB database adapter\n *\n * @param options - DuckDB connection options\n * @returns Database interface for DuckDB\n */\nexport async function getDatabase(\n  options: DuckDBOptions = {},\n): Promise<DatabaseInterface> {\n  const connection = await createDuckDBConnection(options);\n  const writeStrategy = options.writeStrategy || 'none';\n  const dataDir = options.dataDir || './data';\n\n  /**\n   * Inserts one or more records into a table\n   *\n   * @param table - Table name\n   * @param data - Single record or array of records to insert\n   * @returns Promise resolving to operation result\n   * @throws Error if the insert operation fails\n   */\n  const insert = async (\n    table: string,\n    data: Record<string, any> | Record<string, any>[],\n  ): Promise<QueryResult> => {\n    const records = Array.isArray(data) ? data : [data];\n\n    if (records.length === 0) {\n      return { operation: 'insert', affected: 0 };\n    }\n\n    const keys = Object.keys(records[0]);\n    const placeholders = records\n      .map((_, idx) => `(${keys.map((__, colIdx) => `$${idx * keys.length + colIdx + 1}`).join(', ')})`)\n      .join(', ');\n\n    const sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES ${placeholders}`;\n    const values = records.flatMap((record) => Object.values(record));\n\n    try {\n      await connection.run(sql, values);\n      const affected = records.length;\n\n      // Handle write-back strategy\n      if (writeStrategy === 'immediate') {\n        await exportTableToJSON(connection, table, dataDir);\n      }\n\n      return { operation: 'insert', affected };\n    } catch (e) {\n      throw new DatabaseError('Failed to insert records into table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Retrieves a single record matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to matching record or null if not found\n   * @throws Error if the query fails\n   */\n  const get = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any> | null> => {\n    const { sql: whereClause, values } = buildWhere(where, 1);\n    const sql = `SELECT * FROM ${table} ${whereClause} LIMIT 1`;\n\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      const rows = reader.getRowObjects();\n      return rows.length > 0 ? convertBigInts(rows[0]) : null;\n    } catch (e) {\n      throw new DatabaseError('Failed to retrieve record from table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Retrieves multiple records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to array of matching records\n   * @throws Error if the query fails\n   */\n  const list = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any>[]> => {\n    const { sql: whereClause, values } = buildWhere(where, 1);\n    const sql = `SELECT * FROM ${table} ${whereClause}`;\n\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      return convertBigInts(reader.getRowObjects());\n    } catch (e) {\n      throw new DatabaseError('Failed to list records from table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Updates records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records to update\n   * @param data - New data to set\n   * @returns Promise resolving to operation result\n   * @throws Error if the update operation fails\n   */\n  const update = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<QueryResult> => {\n    const keys = Object.keys(data);\n    const setClause = keys.map((key, idx) => `${key} = $${idx + 1}`).join(', ');\n    const { sql: whereClause, values: whereValues } = buildWhere(where, keys.length + 1);\n\n    const sql = `UPDATE ${table} SET ${setClause} ${whereClause}`;\n    const values = [...Object.values(data), ...whereValues];\n\n    try {\n      await connection.run(sql, values);\n\n      // Handle write-back strategy\n      if (writeStrategy === 'immediate') {\n        await exportTableToJSON(connection, table, dataDir);\n      }\n\n      // DuckDB doesn't return rowsAffected in the same way, estimate from where clause\n      return { operation: 'update', affected: 1 };\n    } catch (e) {\n      throw new DatabaseError('Failed to update records in table', {\n        table,\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Inserts a record or updates it if it already exists (UPSERT)\n   *\n   * @param table - Table name\n   * @param conflictColumns - Columns that define the uniqueness constraint\n   * @param data - Data to insert or update\n   * @returns Promise resolving to operation result\n   * @throws Error if the upsert operation fails\n   */\n  const upsert = async (\n    table: string,\n    conflictColumns: string[],\n    data: Record<string, any>,\n  ): Promise<QueryResult> => {\n    const keys = Object.keys(data);\n    const values = Object.values(data);\n    const placeholders = keys.map((_, idx) => `$${idx + 1}`).join(', ');\n    const updateSet = keys\n      .map((key, idx) => `${key} = $${idx + 1}`)\n      .join(', ');\n    const conflict = conflictColumns.join(', ');\n\n    const sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders}) ON CONFLICT(${conflict}) DO UPDATE SET ${updateSet}`;\n\n    try {\n      await connection.run(sql, values);\n\n      // Handle write-back strategy\n      if (writeStrategy === 'immediate') {\n        await exportTableToJSON(connection, table, dataDir);\n      }\n\n      return { operation: 'upsert', affected: 1 };\n    } catch (e) {\n      throw new DatabaseError('Failed to upsert record into table', {\n        table,\n        sql,\n        values,\n        conflictColumns,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Gets a record matching the where criteria or inserts it if not found\n   *\n   * @param table - Table name\n   * @param where - Criteria to match existing record\n   * @param data - Data to insert if no record found\n   * @returns Promise resolving to the record (either retrieved or newly inserted)\n   * @throws Error if the operation fails\n   */\n  const getOrInsert = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<Record<string, any>> => {\n    const result = await get(table, where);\n    if (result) return result;\n\n    await insert(table, data);\n    const inserted = await get(table, where);\n\n    if (!inserted) {\n      throw new DatabaseError('Failed to insert and retrieve record', {\n        table,\n        where,\n        data,\n      });\n    }\n\n    return inserted;\n  };\n\n  /**\n   * Checks if a table exists in the database\n   *\n   * @param tableName - Name of the table to check\n   * @returns Promise resolving to boolean indicating if the table exists\n   */\n  const tableExists = async (tableName: string): Promise<boolean> => {\n    try {\n      // Try to query the table - simpler and works for both tables and views\n      await connection.runAndReadAll(`SELECT * FROM ${tableName} LIMIT 1`);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  /**\n   * Exports a table to a JSON file (for write-back strategies)\n   *\n   * @param connection - DuckDB connection\n   * @param table - Table name\n   * @param dataDir - Directory to write JSON file\n   */\n  const exportTableToJSON = async (\n    connection: any,\n    table: string,\n    dataDir: string,\n  ): Promise<void> => {\n    const filePath = join(dataDir, `${table}.json`);\n    await connection.run(\n      `COPY (SELECT * FROM ${table}) TO '${filePath}' (FORMAT JSON, ARRAY true)`\n    );\n  };\n\n  /**\n   * Manual export method for 'manual' write strategy\n   *\n   * @param table - Table name to export\n   * @returns Promise that resolves when export completes\n   */\n  const exportTable = async (table: string): Promise<void> => {\n    if (writeStrategy === 'none') {\n      throw new DatabaseError(\n        'Cannot export table: write strategy is set to none',\n        { table, writeStrategy }\n      );\n    }\n    await exportTableToJSON(connection, table, dataDir);\n  };\n\n  /**\n   * Creates a table-specific interface for simplified table operations\n   *\n   * @param tableName - Table name\n   * @returns TableInterface for the specified table\n   */\n  const table = (tableName: string): TableInterface => ({\n    insert: (data) => insert(tableName, data),\n    get: (where) => get(tableName, where),\n    list: (where) => list(tableName, where),\n  });\n\n  /**\n   * Parses a tagged template literal into a SQL query and values\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Object with SQL query and values array\n   */\n  const parseTemplate = (strings: TemplateStringsArray, ...vars: any[]) => {\n    let sql = strings[0];\n    const values = [];\n    for (let i = 0; i < vars.length; i++) {\n      values.push(vars[i]);\n      sql += `$${i + 1}${strings[i + 1]}`;\n    }\n    return { sql, values };\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns multiple rows\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to array of result records\n   * @throws Error if the query fails\n   */\n  const many = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any>[]> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      return convertBigInts(reader.getRowObjects());\n    } catch (e) {\n      throw new DatabaseError('Failed to execute many query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single row\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single result record or null\n   * @throws Error if the query fails\n   */\n  const single = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any> | null> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      const rows = reader.getRowObjects();\n      return rows[0] ? convertBigInts(rows[0]) : null;\n    } catch (e) {\n      throw new DatabaseError('Failed to execute single query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single value\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single value (first column of first row)\n   * @throws Error if the query fails\n   */\n  const pluck = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<any> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const reader = await connection.runAndReadAll(sql, values);\n      const rows = reader.getRowObjects();\n      if (rows.length === 0) return null;\n      const firstRow = rows[0];\n      const firstKey = Object.keys(firstRow)[0];\n      return convertBigInts(firstRow[firstKey]);\n    } catch (e) {\n      throw new DatabaseError('Failed to execute pluck query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals without returning results\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise that resolves when the query completes\n   * @throws Error if the query fails\n   */\n  const execute = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<void> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      await connection.run(sql, values);\n    } catch (e) {\n      throw new DatabaseError('Failed to execute query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a raw SQL query with parameterized values\n   *\n   * @param str - SQL query string\n   * @param values - Variables to use as parameters\n   * @returns Promise resolving to query result with rows and metadata\n   * @throws Error if the query fails\n   */\n  const query = async (str: string, ...values: any[]) => {\n    const sql = str;\n    const args = Array.isArray(values[0]) ? values[0] : values;\n\n    try {\n      const reader = await connection.runAndReadAll(sql, args);\n      const rows = convertBigInts(reader.getRowObjects());\n\n      return {\n        command: sql.split(' ')[0].toUpperCase(),\n        rowCount: rows.length,\n        oid: null,\n        fields: rows.length > 0\n          ? Object.keys(rows[0]).map((name) => ({\n              name,\n              tableID: 0,\n              columnID: 0,\n              dataTypeID: 0,\n              dataTypeSize: -1,\n              dataTypeModifier: -1,\n              format: 'text',\n            }))\n          : [],\n        rows,\n      };\n    } catch (e) {\n      throw new DatabaseError('Failed to execute raw query', {\n        sql,\n        args,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  // Shorthand aliases for query methods\n  const oo = many; // (o)bjective-(o)bjects: returns multiple rows\n  const oO = single; // (o)bjective-(O)bject: returns a single row\n  const ox = pluck; // (o)bjective-(x): returns a single value\n  const xx = execute; // e(x)ecute-e(x)ecute: executes without returning\n\n  /**\n   * Synchronizes database schema with provided SQL DDL\n   * Note: DuckDB has different schema handling than SQLite\n   *\n   * @param schema - SQL schema definition with CREATE TABLE statements\n   * @returns Promise that resolves when schema is synchronized\n   */\n  const syncSchema = async (schema: string): Promise<void> => {\n    const commands = schema\n      .trim()\n      .split(';')\n      .filter((command) => command.trim() !== '');\n\n    for (const command of commands) {\n      try {\n        await connection.run(command);\n      } catch (e) {\n        // Log but don't fail on schema sync errors\n        console.error('Schema sync error:', e);\n      }\n    }\n  };\n\n  /**\n   * Initialize database schemas from JSON manifest\n   * Supports dependency resolution and schema overrides\n   *\n   * @param options - Schema initialization options\n   * @returns Promise that resolves when schemas are initialized\n   */\n  const initializeSchemas = async (\n    options: SchemaInitializationOptions,\n  ): Promise<void> => {\n    const schemaManager = new DatabaseSchemaManager();\n    const currentDb: DatabaseInterface = {\n      client: connection,\n      query,\n      insert,\n      update,\n      upsert,\n      get,\n      list,\n      getOrInsert,\n      table,\n      tableExists,\n      many,\n      single,\n      pluck,\n      execute,\n      oo,\n      oO,\n      ox,\n      xx,\n      syncSchema,\n    };\n\n    await schemaManager.initializeSchemas(currentDb, options);\n  };\n\n  /**\n   * Executes a callback within a database transaction\n   * Automatically commits on success or rolls back on error\n   *\n   * @param callback - Function to execute within transaction\n   * @returns Promise resolving to callback result\n   */\n  const transaction = async <T>(\n    callback: (tx: DatabaseInterface) => Promise<T>,\n  ): Promise<T> => {\n    try {\n      await connection.run('BEGIN TRANSACTION');\n\n      // Create a transaction-scoped database interface\n      const txDb: DatabaseInterface = {\n        client: connection,\n        insert,\n        get,\n        list,\n        update,\n        upsert,\n        getOrInsert,\n        table,\n        many,\n        single,\n        pluck,\n        execute,\n        query,\n        oo,\n        oO,\n        ox,\n        xx,\n        tableExists,\n        syncSchema,\n        transaction,\n      };\n\n      const result = await callback(txDb);\n      await connection.run('COMMIT');\n      return result;\n    } catch (error) {\n      await connection.run('ROLLBACK');\n      throw error;\n    }\n  };\n\n  return {\n    client: connection,\n    query,\n    insert,\n    update,\n    upsert,\n    get,\n    list,\n    getOrInsert,\n    table,\n    tableExists,\n    many,\n    single,\n    pluck,\n    execute,\n    oo,\n    oO,\n    ox,\n    xx,\n    syncSchema,\n    initializeSchemas,\n    transaction,\n    // DuckDB-specific export method\n    exportTable,\n  } as DatabaseInterface & { exportTable: (table: string) => Promise<void> };\n}\n"],"names":["table","connection","dataDir","options"],"mappings":"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"}