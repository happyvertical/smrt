{"version":3,"file":"index-Dequee6D.js","sources":["../../src/cli/commands/generate.ts","../../src/cli/loaders/git-loader.ts","../../src/cli/loaders/local-loader.ts","../../src/cli/loaders/npm-loader.ts","../../src/cli/loaders/template-loader.ts","../../src/cli/utils/generator.ts","../../src/cli/commands/gnode.ts"],"sourcesContent":["/**\n * Code Generation CLI Commands\n *\n * Commands for generating code, types, and other artifacts\n */\n\nimport type { CLICommand } from '../../generators/cli.js';\nimport { generateDeclarationsFromCLI } from '../../prebuild/index.js';\n\n/**\n * Code generation commands for CLI\n */\nexport const generateCommands: Record<string, CLICommand> = {\n  'generate-types': {\n    name: 'generate-types',\n    description: 'Generate TypeScript declarations from SMRT manifest',\n    aliases: ['generate-declarations'],\n    args: ['manifest-path'],\n    options: {\n      'output-dir': {\n        type: 'string',\n        description: 'Output directory for generated types',\n      },\n    },\n    handler: async (args: string[], options: any) => {\n      const manifestPath = args[0];\n      if (!manifestPath) {\n        throw new Error(\n          'Manifest path is required: smrt generate-types <manifest-path> [output-dir]',\n        );\n      }\n\n      const outputDir = options.outputDir || args[1];\n\n      try {\n        const cliArgs = outputDir ? [manifestPath, outputDir] : [manifestPath];\n        await generateDeclarationsFromCLI(cliArgs);\n      } catch (error) {\n        throw new Error(\n          `Failed to generate types: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        );\n      }\n    },\n  },\n};\n","/**\n * Git Repository Template Loader\n *\n * Downloads templates from git repositories without full git history.\n * Similar to degit - downloads tarball of latest commit.\n *\n * Supports:\n * - github:user/repo\n * - github:user/repo/subdir#ref\n * - gitlab:user/repo\n * - https://github.com/user/repo.git\n * - https://github.com/user/repo.git#ref:subdir\n * - git@github.com:user/repo.git#ref:subdir\n *\n * Subdirectory syntax:\n * - Shorthand: github:user/repo/path/to/subdir\n * - Full URL: https://github.com/user/repo.git#branch:path/to/subdir\n */\n\nimport { mkdir, rm } from 'node:fs/promises';\nimport https from 'node:https';\nimport { tmpdir } from 'node:os';\nimport { join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { extract } from 'tar';\nimport type { TemplateConfig } from './template-loader.js';\n\n// Track temp directories for cleanup on process exit\nconst tempDirectories = new Set<string>();\nlet cleanupHandlersRegistered = false;\n\n/**\n * Register cleanup handlers for temporary directories\n * Ensures temp directories are removed on process termination\n */\nfunction registerCleanupHandlers() {\n  if (cleanupHandlersRegistered) return;\n  cleanupHandlersRegistered = true;\n\n  const cleanup = async () => {\n    if (tempDirectories.size === 0) return;\n\n    const dirs = Array.from(tempDirectories);\n    await Promise.all(\n      dirs.map(async (dir) => {\n        try {\n          await rm(dir, { recursive: true, force: true });\n          tempDirectories.delete(dir);\n        } catch (_error) {\n          // Ignore cleanup errors - directory may already be removed\n        }\n      }),\n    );\n  };\n\n  // Clean up on normal exit\n  process.on('exit', () => {\n    // Synchronous cleanup not ideal, but exit is synchronous\n    // Most cleanup happens via other handlers\n  });\n\n  // Clean up on termination signals\n  process.on('SIGINT', async () => {\n    await cleanup();\n    process.exit(130); // Standard exit code for SIGINT\n  });\n\n  process.on('SIGTERM', async () => {\n    await cleanup();\n    process.exit(143); // Standard exit code for SIGTERM\n  });\n\n  // Clean up on uncaught exceptions\n  process.on('uncaughtException', async (error) => {\n    await cleanup();\n    throw error;\n  });\n}\n\ninterface GitRepo {\n  host: 'github' | 'gitlab' | 'bitbucket';\n  user: string;\n  repo: string;\n  ref: string; // branch, tag, or commit\n  subdir?: string; // subdirectory within repo\n}\n\n/**\n * Parse git URL to repository information\n *\n * Supports subdirectories via:\n * - github:user/repo/subdir#ref\n * - https://github.com/user/repo.git#ref:subdir\n * - git@github.com:user/repo.git#ref:subdir\n */\nfunction parseGitUrl(url: string): GitRepo {\n  let host: 'github' | 'gitlab' | 'bitbucket';\n  let user: string;\n  let repo: string;\n  let ref = 'HEAD'; // default to latest\n  let subdir: string | undefined;\n\n  // Handle shorthand: github:user/repo/subdir#ref\n  if (url.startsWith('github:')) {\n    host = 'github';\n    const parts = url.slice(7).split('/');\n    user = parts[0];\n\n    // Check for ref in second part\n    const repoAndRef = parts[1]?.split('#') || ['', ''];\n    repo = repoAndRef[0];\n    if (repoAndRef[1]) ref = repoAndRef[1];\n\n    // Remaining parts are subdirectory\n    if (parts.length > 2) {\n      subdir = parts.slice(2).join('/');\n    }\n  } else if (url.startsWith('gitlab:')) {\n    host = 'gitlab';\n    const parts = url.slice(7).split('/');\n    user = parts[0];\n\n    const repoAndRef = parts[1]?.split('#') || ['', ''];\n    repo = repoAndRef[0];\n    if (repoAndRef[1]) ref = repoAndRef[1];\n\n    if (parts.length > 2) {\n      subdir = parts.slice(2).join('/');\n    }\n  } else if (url.startsWith('bitbucket:')) {\n    host = 'bitbucket';\n    const parts = url.slice(10).split('/');\n    user = parts[0];\n\n    const repoAndRef = parts[1]?.split('#') || ['', ''];\n    repo = repoAndRef[0];\n    if (repoAndRef[1]) ref = repoAndRef[1];\n\n    if (parts.length > 2) {\n      subdir = parts.slice(2).join('/');\n    }\n  }\n  // Handle HTTPS URLs\n  else if (url.includes('github.com')) {\n    host = 'github';\n    const match = url.match(/github\\.com[:/]([^/]+)\\/([^/.]+)/);\n    if (!match) throw new Error(`Invalid GitHub URL: ${url}`);\n    user = match[1];\n    repo = match[2].replace(/\\.git$/, '');\n\n    // Extract ref and subdir from hash: #ref:subdir or #ref\n    const refMatch = url.match(/#(.+)$/);\n    if (refMatch) {\n      const refParts = refMatch[1].split(':');\n      ref = refParts[0];\n      if (refParts[1]) subdir = refParts[1];\n    }\n  } else if (url.includes('gitlab.com')) {\n    host = 'gitlab';\n    const match = url.match(/gitlab\\.com[:/]([^/]+)\\/([^/.]+)/);\n    if (!match) throw new Error(`Invalid GitLab URL: ${url}`);\n    user = match[1];\n    repo = match[2].replace(/\\.git$/, '');\n\n    const refMatch = url.match(/#(.+)$/);\n    if (refMatch) {\n      const refParts = refMatch[1].split(':');\n      ref = refParts[0];\n      if (refParts[1]) subdir = refParts[1];\n    }\n  } else if (url.includes('bitbucket.org')) {\n    host = 'bitbucket';\n    const match = url.match(/bitbucket\\.org[:/]([^/]+)\\/([^/.]+)/);\n    if (!match) throw new Error(`Invalid Bitbucket URL: ${url}`);\n    user = match[1];\n    repo = match[2].replace(/\\.git$/, '');\n\n    const refMatch = url.match(/#(.+)$/);\n    if (refMatch) {\n      const refParts = refMatch[1].split(':');\n      ref = refParts[0];\n      if (refParts[1]) subdir = refParts[1];\n    }\n  } else {\n    throw new Error(`Unsupported git URL: ${url}`);\n  }\n\n  return { host, user, repo, ref, subdir };\n}\n\n/**\n * Get tarball URL for repository\n */\nfunction getTarballUrl(repo: GitRepo): string {\n  switch (repo.host) {\n    case 'github':\n      return `https://github.com/${repo.user}/${repo.repo}/archive/${repo.ref}.tar.gz`;\n    case 'gitlab':\n      return `https://gitlab.com/${repo.user}/${repo.repo}/-/archive/${repo.ref}/${repo.repo}-${repo.ref}.tar.gz`;\n    case 'bitbucket':\n      return `https://bitbucket.org/${repo.user}/${repo.repo}/get/${repo.ref}.tar.gz`;\n    default:\n      throw new Error(`Unsupported git host: ${repo.host}`);\n  }\n}\n\n/**\n * Validate redirect URL to prevent SSRF attacks\n * Only allow redirects to trusted git hosting services\n */\nfunction validateRedirectUrl(redirectUrl: string): void {\n  try {\n    const url = new URL(redirectUrl);\n\n    // Only allow HTTPS protocol\n    if (url.protocol !== 'https:') {\n      throw new Error(\n        `Invalid redirect protocol: ${url.protocol} (only https: allowed)`,\n      );\n    }\n\n    // Only allow trusted git hosting services\n    const trustedHosts = [\n      'github.com',\n      'www.github.com',\n      'codeload.github.com',\n      'gitlab.com',\n      'www.gitlab.com',\n      'bitbucket.org',\n      'www.bitbucket.org',\n    ];\n\n    if (!trustedHosts.includes(url.hostname)) {\n      throw new Error(`Redirect to untrusted host: ${url.hostname}`);\n    }\n\n    // Reject redirects to localhost or internal IPs\n    if (\n      url.hostname === 'localhost' ||\n      url.hostname === '127.0.0.1' ||\n      url.hostname.startsWith('192.168.') ||\n      url.hostname.startsWith('10.') ||\n      url.hostname.startsWith('172.')\n    ) {\n      throw new Error(\n        `Redirect to internal/local address not allowed: ${url.hostname}`,\n      );\n    }\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw new Error(`Invalid redirect URL format: ${redirectUrl}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Download and extract git repository tarball\n */\nasync function downloadTarball(url: string, dest: string): Promise<string> {\n  const REQUEST_TIMEOUT = 30000; // 30 seconds\n  const MAX_TARBALL_SIZE = 100 * 1024 * 1024; // 100 MB\n\n  return new Promise((resolve, reject) => {\n    let timedOut = false;\n    let receivedBytes = 0;\n\n    const req = https.get(url, (response) => {\n      // Handle redirects\n      if (response.statusCode === 301 || response.statusCode === 302) {\n        const redirectUrl = response.headers.location;\n        if (!redirectUrl) {\n          return reject(new Error('Redirect without location header'));\n        }\n\n        // Validate redirect URL before following\n        try {\n          validateRedirectUrl(redirectUrl);\n        } catch (error) {\n          return reject(error);\n        }\n\n        return downloadTarball(redirectUrl, dest).then(resolve, reject);\n      }\n\n      if (response.statusCode !== 200) {\n        return reject(\n          new Error(`Failed to download tarball: HTTP ${response.statusCode}`),\n        );\n      }\n\n      // Monitor response size\n      response.on('data', (chunk) => {\n        receivedBytes += chunk.length;\n        if (receivedBytes > MAX_TARBALL_SIZE) {\n          response.destroy(new Error('Tarball size exceeds limit'));\n        }\n      });\n\n      // Extract tarball to destination\n      const extractStream = extract({\n        cwd: dest,\n        strip: 1, // Remove top-level directory from tarball\n      });\n\n      response.pipe(extractStream);\n\n      extractStream.on('finish', () => resolve(dest));\n      extractStream.on('error', (err) => {\n        response.destroy();\n        reject(err);\n      });\n    });\n\n    req.setTimeout(REQUEST_TIMEOUT, () => {\n      timedOut = true;\n      req.destroy(new Error('Request timed out'));\n    });\n\n    req.on('error', (err) => {\n      if (timedOut) {\n        reject(new Error('Request timed out'));\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n\n/**\n * Load template from git repository\n */\nexport async function loadGitTemplate(gitUrl: string): Promise<TemplateConfig> {\n  // Register cleanup handlers (only once)\n  registerCleanupHandlers();\n\n  // Parse git URL\n  const repo = parseGitUrl(gitUrl);\n\n  // Create temporary directory\n  const tempDir = join(\n    tmpdir(),\n    `smrt-template-${repo.user}-${repo.repo}-${Date.now()}`,\n  );\n  await mkdir(tempDir, { recursive: true });\n\n  // Track temp directory for cleanup\n  tempDirectories.add(tempDir);\n\n  try {\n    // Download and extract tarball\n    const tarballUrl = getTarballUrl(repo);\n    console.log(\n      `Downloading template from ${repo.host}:${repo.user}/${repo.repo}...`,\n    );\n    await downloadTarball(tarballUrl, tempDir);\n\n    // Load template config\n    const templateDir = repo.subdir ? join(tempDir, repo.subdir) : tempDir;\n    const configPath = join(templateDir, 'template.config.js');\n\n    // Try to load config\n    try {\n      const configUrl = pathToFileURL(configPath).href;\n      const module = await import(configUrl);\n      const config = module.default || module;\n\n      // Validate\n      validateTemplateConfig(config, configPath);\n\n      // Store temp directory in config for later cleanup\n      (config as any).__tempDir = tempDir;\n\n      return config;\n    } catch (_error) {\n      // Try .ts extension\n      try {\n        const tsConfigPath = join(templateDir, 'template.config.ts');\n        const configUrl = pathToFileURL(tsConfigPath).href;\n        const module = await import(configUrl);\n        const config = module.default || module;\n\n        validateTemplateConfig(config, tsConfigPath);\n        (config as any).__tempDir = tempDir;\n\n        return config;\n      } catch {\n        throw new Error(\n          `No template.config.js or template.config.ts found in ${gitUrl}`,\n        );\n      }\n    }\n  } catch (error) {\n    // Cleanup temp directory on error\n    await rm(tempDir, { recursive: true, force: true });\n    throw error;\n  }\n}\n\n/**\n * Get the template directory path (for copying overlay files)\n */\nexport function getGitTemplateDir(config: TemplateConfig): string {\n  const tempDir = (config as any).__tempDir;\n  if (!tempDir) {\n    throw new Error('Template was not loaded from git repository');\n  }\n  return tempDir;\n}\n\n/**\n * Cleanup temporary directory after template is used\n */\nexport async function cleanupGitTemplate(\n  config: TemplateConfig,\n): Promise<void> {\n  const tempDir = (config as any).__tempDir;\n  if (tempDir) {\n    await rm(tempDir, { recursive: true, force: true });\n  }\n}\n\n/**\n * Validate template configuration has required fields\n */\nfunction validateTemplateConfig(config: any, source: string): void {\n  const required = ['name', 'description', 'dependencies'];\n\n  for (const field of required) {\n    if (!config[field]) {\n      throw new Error(\n        `Invalid template config at ${source}: missing required field '${field}'`,\n      );\n    }\n  }\n\n  if (typeof config.dependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'dependencies' must be an object`,\n    );\n  }\n\n  if (config.devDependencies && typeof config.devDependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'devDependencies' must be an object`,\n    );\n  }\n}\n","/**\n * Local Filesystem Template Loader\n *\n * Loads templates from local directories.\n * Useful for development and testing.\n */\n\nimport { access } from 'node:fs/promises';\nimport { homedir } from 'node:os';\nimport { join, resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport type { TemplateConfig } from './template-loader.js';\n\n/**\n * Expand home directory (~) in paths\n * Handles both ~/ and ~ patterns\n */\nfunction expandHomeDirectory(path: string): string {\n  if (path.startsWith('~/')) {\n    return join(homedir(), path.slice(2));\n  }\n  if (path.startsWith('~')) {\n    return join(homedir(), path.slice(1));\n  }\n  return path;\n}\n\n/**\n * Validate resolved path to prevent path traversal attacks\n * Focuses on blocking access to sensitive system directories\n * while allowing legitimate parent directory navigation (e.g., ../sibling-dir)\n */\nfunction validateResolvedPath(\n  absolutePath: string,\n  originalPath: string,\n): void {\n  const home = homedir();\n\n  // Check if path contains null bytes (common path traversal technique)\n  if (absolutePath.includes('\\0') || originalPath.includes('\\0')) {\n    throw new Error(\n      'Path contains null bytes (potential path traversal attempt)',\n    );\n  }\n\n  // For home directory paths, ensure they stay within home directory\n  // This is stricter because ~ explicitly means \"home directory\"\n  if (originalPath.startsWith('~')) {\n    const normalizedPath = resolve(absolutePath);\n    const normalizedHome = resolve(home);\n\n    if (!normalizedPath.startsWith(normalizedHome)) {\n      throw new Error(\n        `Path traversal detected: resolved path \"${normalizedPath}\" escapes home directory \"${normalizedHome}\"`,\n      );\n    }\n  }\n\n  // Reject paths that resolve to sensitive system directories\n  // This is the primary defense against malicious path traversal\n  const sensitivePaths = [\n    '/etc',\n    '/proc',\n    '/sys',\n    '/dev',\n    '/boot',\n    '/root',\n    '/var/log',\n  ];\n  const normalizedPath = resolve(absolutePath);\n\n  for (const sensitivePath of sensitivePaths) {\n    if (\n      normalizedPath === sensitivePath ||\n      normalizedPath.startsWith(`${sensitivePath}/`)\n    ) {\n      throw new Error(\n        `Access to sensitive system directory not allowed: ${sensitivePath}`,\n      );\n    }\n  }\n\n  // Block paths that attempt to access system binaries\n  if (\n    normalizedPath.startsWith('/bin/') ||\n    normalizedPath.startsWith('/sbin/') ||\n    normalizedPath.startsWith('/usr/bin/') ||\n    normalizedPath.startsWith('/usr/sbin/')\n  ) {\n    throw new Error('Access to system binary directories not allowed');\n  }\n}\n\n/**\n * Resolve local path to absolute path\n *\n * Handles:\n * - Relative paths (./path, ../path)\n * - Absolute paths (/path)\n * - Home directory (~/)\n *\n * Includes path traversal protection to prevent malicious paths\n */\nexport async function resolveLocalPath(localPath: string): Promise<string> {\n  let absolutePath: string;\n\n  // Expand home directory (~) if present\n  if (localPath.startsWith('~')) {\n    absolutePath = expandHomeDirectory(localPath);\n  } else if (localPath.startsWith('/')) {\n    // Already absolute\n    absolutePath = localPath;\n  } else {\n    // Relative to current working directory\n    absolutePath = resolve(process.cwd(), localPath);\n  }\n\n  // Validate path for traversal attacks\n  validateResolvedPath(absolutePath, localPath);\n\n  // Verify directory exists\n  try {\n    await access(absolutePath);\n  } catch {\n    throw new Error(`Local template path does not exist: ${absolutePath}`);\n  }\n\n  return absolutePath;\n}\n\n/**\n * Load template configuration from local directory\n */\nexport async function loadLocalTemplate(\n  resolvedPath: string,\n): Promise<TemplateConfig> {\n  // Look for template.config.{js,ts}\n  let configPath: string | null = null;\n\n  for (const ext of ['js', 'ts']) {\n    const testPath = join(resolvedPath, `template.config.${ext}`);\n    try {\n      await access(testPath);\n      configPath = testPath;\n      break;\n    } catch {\n      // Try next extension\n    }\n  }\n\n  if (!configPath) {\n    throw new Error(\n      `No template.config.js or template.config.ts found in ${resolvedPath}`,\n    );\n  }\n\n  // Load the configuration\n  try {\n    const configUrl = pathToFileURL(configPath).href;\n    const module = await import(configUrl);\n    const config = module.default || module;\n\n    // Validate required fields\n    validateTemplateConfig(config, configPath);\n\n    return config;\n  } catch (error) {\n    throw new Error(\n      `Failed to load template config from ${configPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\n/**\n * Validate template configuration has required fields\n */\nfunction validateTemplateConfig(config: any, source: string): void {\n  const required = ['name', 'description', 'dependencies'];\n\n  for (const field of required) {\n    if (!config[field]) {\n      throw new Error(\n        `Invalid template config at ${source}: missing required field '${field}'`,\n      );\n    }\n  }\n\n  if (typeof config.dependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'dependencies' must be an object`,\n    );\n  }\n\n  if (config.devDependencies && typeof config.devDependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'devDependencies' must be an object`,\n    );\n  }\n}\n","/**\n * NPM Package Template Loader\n *\n * Loads templates from installed npm packages.\n * Supports package exports for template discovery.\n */\n\nimport { access, readFile } from 'node:fs/promises';\nimport { dirname, join, resolve } from 'node:path';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport glob from 'fast-glob';\nimport type { TemplateConfig } from './template-loader.js';\n\n/**\n * Resolve npm package path to template configuration\n *\n * Examples:\n * - @happyvertical/praeco/templates/sveltekit\n * - @org/templates\n * - my-template-package\n */\nexport async function resolveNpmPackage(packagePath: string): Promise<string> {\n  // Try to resolve as module\n  try {\n    const resolved = require.resolve(packagePath, {\n      paths: [process.cwd(), ...module.paths],\n    });\n    return resolved;\n  } catch {\n    // If not found, try looking in node_modules directly\n    const nodeModulesPath = join(process.cwd(), 'node_modules', packagePath);\n    try {\n      await access(nodeModulesPath);\n      return nodeModulesPath;\n    } catch {\n      throw new Error(\n        `npm package '${packagePath}' not found. Install with: npm install ${packagePath.split('/')[0]}`,\n      );\n    }\n  }\n}\n\n/**\n * Load template configuration from npm package\n */\nexport async function loadNpmTemplate(\n  resolvedPath: string,\n): Promise<TemplateConfig> {\n  let configPath: string;\n\n  // Check if resolved path is a template.config.js/ts file\n  if (\n    resolvedPath.endsWith('template.config.js') ||\n    resolvedPath.endsWith('template.config.ts')\n  ) {\n    configPath = resolvedPath;\n  } else {\n    // Look for template.config.{js,ts} in the resolved directory\n    const dir = resolvedPath.endsWith('.js')\n      ? dirname(resolvedPath)\n      : resolvedPath;\n\n    try {\n      configPath = join(dir, 'template.config.js');\n      await access(configPath);\n    } catch {\n      try {\n        configPath = join(dir, 'template.config.ts');\n        await access(configPath);\n      } catch {\n        throw new Error(\n          `No template.config.js or template.config.ts found in ${dir}`,\n        );\n      }\n    }\n  }\n\n  // Load the configuration\n  try {\n    const configUrl = pathToFileURL(configPath).href;\n    const module = await import(configUrl);\n    const config = module.default || module;\n\n    // Validate required fields\n    validateTemplateConfig(config, configPath);\n\n    return config;\n  } catch (error) {\n    throw new Error(\n      `Failed to load template config from ${configPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\n/**\n * Find template by short name in installed packages\n *\n * Searches for:\n * - Scoped packages with templates directory\n * - Scoped packages direct\n * - Unscoped packages\n */\nexport async function findTemplateInPackages(\n  shortName: string,\n): Promise<string | null> {\n  const nodeModulesPath = join(process.cwd(), 'node_modules');\n\n  // Search patterns\n  const patterns = [\n    // Scoped packages with templates directory\n    `${nodeModulesPath}/@*/templates/${shortName}/template.config.{js,ts}`,\n    // Scoped packages direct\n    `${nodeModulesPath}/@*/${shortName}/template.config.{js,ts}`,\n    // Unscoped packages\n    `${nodeModulesPath}/${shortName}/template.config.{js,ts}`,\n    // Templates subdirectory in any package\n    `${nodeModulesPath}/*/templates/${shortName}/template.config.{js,ts}`,\n  ];\n\n  for (const pattern of patterns) {\n    const matches = await glob(pattern, { absolute: true });\n    if (matches.length > 0) {\n      // Return the package path, not the template.config path\n      const configPath = matches[0];\n      return dirname(configPath);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Discover all templates in installed packages\n *\n * Useful for `smrt gnode list-templates` command\n */\nexport async function discoverInstalledTemplates(): Promise<\n  Array<{ name: string; source: string; config: TemplateConfig }>\n> {\n  const nodeModulesPath = join(process.cwd(), 'node_modules');\n\n  const patterns = [\n    `${nodeModulesPath}/@*/templates/*/template.config.{js,ts}`,\n    `${nodeModulesPath}/*/template.config.{js,ts}`,\n  ];\n\n  const templates: Array<{\n    name: string;\n    source: string;\n    config: TemplateConfig;\n  }> = [];\n\n  for (const pattern of patterns) {\n    const matches = await glob(pattern, { absolute: true });\n\n    for (const configPath of matches) {\n      try {\n        const configUrl = pathToFileURL(configPath).href;\n        const module = await import(configUrl);\n        const config = module.default || module;\n\n        // Extract package name from path\n        const relativePath = configPath.replace(nodeModulesPath + '/', '');\n        const source = relativePath.substring(\n          0,\n          relativePath.indexOf('/template.config'),\n        );\n\n        templates.push({\n          name: config.name || 'unknown',\n          source,\n          config,\n        });\n      } catch (error) {\n        // Skip templates that fail to load\n        console.warn(`Failed to load template at ${configPath}:`, error);\n      }\n    }\n  }\n\n  return templates;\n}\n\n/**\n * Validate template configuration has required fields\n */\nfunction validateTemplateConfig(config: any, source: string): void {\n  const required = ['name', 'description', 'dependencies'];\n\n  for (const field of required) {\n    if (!config[field]) {\n      throw new Error(\n        `Invalid template config at ${source}: missing required field '${field}'`,\n      );\n    }\n  }\n\n  if (typeof config.dependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'dependencies' must be an object`,\n    );\n  }\n\n  if (config.devDependencies && typeof config.devDependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'devDependencies' must be an object`,\n    );\n  }\n}\n","/**\n * Template Loader - Resolves and loads templates from various sources\n *\n * Supports:\n * - npm packages (@org/pkg/templates/name)\n * - Git repositories (github:user/repo, https://github.com/user/repo.git)\n * - Local filesystem paths (../path/to/template, /absolute/path)\n */\n\nimport { loadGitTemplate } from './git-loader.js';\nimport { loadLocalTemplate, resolveLocalPath } from './local-loader.js';\nimport {\n  findTemplateInPackages,\n  loadNpmTemplate,\n  resolveNpmPackage,\n} from './npm-loader.js';\n\nexport interface TemplateConfig {\n  name: string;\n  description: string;\n  framework: string;\n  baseGenerator?: {\n    command: string;\n    args: string[];\n    skipPrompts?: boolean;\n  };\n  dependencies: Record<string, string>;\n  devDependencies: Record<string, string>;\n}\n\nexport interface TemplateSource {\n  type: 'npm' | 'git' | 'local';\n  location: string;\n  resolved: string;\n}\n\n/**\n * Resolve a template name to a specific source\n *\n * @param name - Template name or path\n *   - @org/pkg/templates/name (npm package)\n *   - github:user/repo (git shorthand)\n *   - https://github.com/user/repo.git (git URL)\n *   - ../path/to/template (local path)\n *   - short-name (searches installed packages)\n *\n * @returns Template source information\n */\nexport async function resolveTemplate(name: string): Promise<TemplateSource> {\n  // Check for git repository first (most specific)\n  if (\n    name.startsWith('github:') ||\n    name.startsWith('gitlab:') ||\n    name.startsWith('git@') ||\n    name.endsWith('.git') ||\n    name.startsWith('https://github.com') ||\n    name.startsWith('https://gitlab.com')\n  ) {\n    return {\n      type: 'git',\n      location: name,\n      resolved: name,\n    };\n  }\n\n  // Check for local filesystem path (before npm to avoid matching ./ and ~/)\n  if (name.startsWith('/') || name.startsWith('.') || name.startsWith('~')) {\n    return {\n      type: 'local',\n      location: name,\n      resolved: await resolveLocalPath(name),\n    };\n  }\n\n  // Check for npm package (contains @ or /)\n  if (name.includes('@') || name.includes('/')) {\n    return {\n      type: 'npm',\n      location: name,\n      resolved: await resolveNpmPackage(name),\n    };\n  }\n\n  // Short name - search installed packages\n  const npmPath = await findTemplateInPackages(name);\n  if (npmPath) {\n    return {\n      type: 'npm',\n      location: npmPath,\n      resolved: await resolveNpmPackage(npmPath),\n    };\n  }\n\n  throw new Error(\n    `Template '${name}' not found. Tried:\\n` +\n      `  - npm package: @*/${name}, @*/templates/${name}\\n` +\n      `  - local path: ./${name}, ../${name}\\n` +\n      `\\n` +\n      `Use one of:\\n` +\n      `  - npm package: @org/pkg/templates/name\\n` +\n      `  - git repo: github:user/repo\\n` +\n      `  - local path: ../path/to/template`,\n  );\n}\n\n/**\n * Load template configuration from resolved source\n */\nexport async function loadTemplate(\n  source: TemplateSource,\n): Promise<TemplateConfig> {\n  switch (source.type) {\n    case 'npm':\n      return loadNpmTemplate(source.resolved);\n    case 'git':\n      return loadGitTemplate(source.resolved);\n    case 'local':\n      return loadLocalTemplate(source.resolved);\n    default:\n      throw new Error(`Unknown template type: ${source.type}`);\n  }\n}\n","/**\n * Template Generator Utilities\n *\n * Handles template instantiation:\n * - Run base generators (SvelteKit, Next.js, etc.)\n * - Overlay template files\n * - Merge package.json dependencies\n */\n\nimport { spawn } from 'node:child_process';\nimport { cp, mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport glob from 'fast-glob';\nimport type { TemplateConfig, TemplateSource } from '../loaders/index.js';\n\nexport interface GeneratorOptions {\n  template: string;\n  name: string;\n  outputDir: string;\n}\n\n/**\n * Generate project from template\n */\nexport async function generate(\n  source: TemplateSource,\n  config: TemplateConfig,\n  options: GeneratorOptions,\n): Promise<void> {\n  console.log(`\\nüèóÔ∏è  Creating gnode: ${options.name}`);\n  console.log(`üì¶ Using template: ${config.name} (${config.description})\\n`);\n\n  // Step 1: Run base generator if specified\n  if (config.baseGenerator) {\n    console.log(`üìù Running base generator (${config.framework})...`);\n    await runBaseGenerator(config.baseGenerator, options.outputDir);\n  } else {\n    // Create directory if no base generator\n    await mkdir(options.outputDir, { recursive: true });\n  }\n\n  // Step 2: Overlay template files\n  console.log('üìã Copying template files...');\n  await overlayTemplate(source, config, options.outputDir);\n\n  // Step 3: Merge package.json\n  console.log('üîß Configuring package.json...');\n  await mergePackageJson(options.outputDir, config, options.name);\n\n  console.log('\\n‚úÖ Gnode created successfully!');\n  console.log(`\\nüìç Next steps:`);\n  console.log(`   cd ${options.name}`);\n  console.log(`   pnpm install`);\n  console.log(`   pnpm dev\\n`);\n}\n\n/**\n * Validate base generator configuration to prevent command injection\n */\nfunction validateBaseGenerator(\n  baseGen: NonNullable<TemplateConfig['baseGenerator']>,\n  outputDir: string,\n): void {\n  // Whitelist of allowed base generator commands\n  const allowedCommands = ['npm', 'npx', 'pnpm', 'yarn', 'bun', 'bunx'];\n\n  if (!allowedCommands.includes(baseGen.command)) {\n    throw new Error(\n      `Base generator command \"${baseGen.command}\" not allowed. ` +\n        `Allowed commands: ${allowedCommands.join(', ')}`,\n    );\n  }\n\n  // Validate outputDir doesn't contain shell metacharacters\n  const dangerousChars = /[;&|`$(){}[\\]<>'\"\\\\]/;\n  if (dangerousChars.test(outputDir)) {\n    throw new Error(\n      `Output directory contains dangerous characters: ${outputDir}. ` +\n        `Only alphanumeric, dash, underscore, dot, and forward slash are allowed.`,\n    );\n  }\n\n  // Validate all arguments after {DIR} replacement\n  for (const arg of baseGen.args) {\n    // Replace {DIR} placeholder first\n    const replacedArg = arg.replace('{DIR}', outputDir);\n\n    // Then check for command injection patterns in the replaced argument\n    if (dangerousChars.test(replacedArg)) {\n      throw new Error(\n        `Base generator argument contains dangerous characters after placeholder replacement: ${replacedArg}`,\n      );\n    }\n  }\n}\n\n/**\n * Run base project generator (e.g., create-svelte, create-next-app)\n *\n * Security: Command and arguments are validated to prevent injection attacks.\n * shell: true is NOT used to avoid command injection vulnerabilities.\n */\nasync function runBaseGenerator(\n  baseGen: NonNullable<TemplateConfig['baseGenerator']>,\n  outputDir: string,\n): Promise<void> {\n  // Validate configuration before executing\n  validateBaseGenerator(baseGen, outputDir);\n\n  // Replace {DIR} placeholder in arguments\n  const args = baseGen.args.map((arg) => arg.replace('{DIR}', outputDir));\n\n  return new Promise((resolve, reject) => {\n    // Do NOT use shell: true to prevent command injection\n    const proc = spawn(baseGen.command, args, {\n      stdio: 'inherit',\n      shell: false,\n    });\n\n    proc.on('close', (code) => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject(new Error(`Base generator exited with code ${code}`));\n      }\n    });\n\n    proc.on('error', reject);\n  });\n}\n\n/**\n * Overlay template files onto generated project\n */\nasync function overlayTemplate(\n  source: TemplateSource,\n  config: TemplateConfig,\n  outputDir: string,\n): Promise<void> {\n  // Determine overlay directory based on source type\n  let overlayDir: string;\n\n  switch (source.type) {\n    case 'npm':\n      overlayDir = join(dirname(source.resolved), 'overlay');\n      break;\n    case 'git': {\n      // For git templates, the temp directory is stored in config\n      const tempDir = (config as any).__tempDir;\n      if (!tempDir) {\n        throw new Error('Git template temp directory not found');\n      }\n      overlayDir = join(tempDir, 'overlay');\n      break;\n    }\n    case 'local':\n      overlayDir = join(source.resolved, 'overlay');\n      break;\n    default:\n      throw new Error(`Unknown source type: ${source.type}`);\n  }\n\n  // Find all files in overlay directory\n  const files = await glob('**/*', {\n    cwd: overlayDir,\n    dot: true,\n    onlyFiles: true,\n  });\n\n  // Copy each file\n  for (const file of files) {\n    const src = join(overlayDir, file);\n    const dest = join(outputDir, file);\n\n    // Ensure directory exists\n    await mkdir(dirname(dest), { recursive: true });\n\n    // Copy file\n    await cp(src, dest);\n  }\n}\n\n/**\n * Merge template dependencies into package.json\n */\nasync function mergePackageJson(\n  outputDir: string,\n  config: TemplateConfig,\n  projectName: string,\n): Promise<void> {\n  const pkgPath = join(outputDir, 'package.json');\n\n  let pkg: any;\n  try {\n    const content = await readFile(pkgPath, 'utf-8');\n    pkg = JSON.parse(content);\n  } catch {\n    // If no package.json exists, create one\n    pkg = {\n      name: projectName,\n      version: '0.1.0',\n      private: true,\n      scripts: {},\n      dependencies: {},\n      devDependencies: {},\n    };\n  }\n\n  // Update name\n  pkg.name = projectName;\n\n  // Merge dependencies\n  pkg.dependencies = {\n    ...pkg.dependencies,\n    ...config.dependencies,\n  };\n\n  pkg.devDependencies = {\n    ...pkg.devDependencies,\n    ...config.devDependencies,\n  };\n\n  // Add gnode-specific scripts if not present\n  if (!pkg.scripts['workflow:research']) {\n    pkg.scripts = {\n      ...pkg.scripts,\n      'workflow:research': 'tsx src/workflows/research.ts',\n      'workflow:report': 'tsx src/workflows/report.ts',\n    };\n  }\n\n  // Write back\n  await writeFile(pkgPath, JSON.stringify(pkg, null, 2) + '\\n');\n}\n","/**\n * Gnode CLI Commands\n *\n * Commands for creating and managing gnodes (federated local knowledge bases)\n */\n\nimport type { CLICommand } from '../../generators/cli.js';\nimport {\n  cleanupGitTemplate,\n  discoverInstalledTemplates,\n  loadTemplate,\n  resolveTemplate,\n} from '../loaders/index.js';\nimport { generate } from '../utils/generator.js';\n\n/**\n * Gnode commands for CLI\n */\nexport const gnodeCommands: Record<string, CLICommand> = {\n  'gnode create': {\n    name: 'gnode create',\n    description: 'Create a new gnode from template',\n    args: ['name'],\n    options: {\n      template: {\n        type: 'string',\n        description: 'Template to use (npm package, git repo, or local path)',\n        default: 'sveltekit',\n      },\n      'output-dir': {\n        type: 'string',\n        description: 'Output directory (defaults to ./<name>)',\n      },\n    },\n    handler: async (args: string[], options: any) => {\n      const name = args[0];\n      if (!name) {\n        throw new Error('Project name is required: smrt gnode create <name>');\n      }\n\n      const outputDir = options.outputDir || `./${name}`;\n      const templateName = options.template || 'sveltekit';\n\n      try {\n        // Resolve template source\n        console.log(`üîç Resolving template: ${templateName}...`);\n        const source = await resolveTemplate(templateName);\n        console.log(`‚úì Found template: ${source.type}:${source.location}\\n`);\n\n        // Load template configuration\n        const config = await loadTemplate(source);\n\n        // Generate project\n        await generate(source, config, {\n          name,\n          template: templateName,\n          outputDir,\n        });\n\n        // Cleanup git template if needed\n        if (source.type === 'git') {\n          await cleanupGitTemplate(config);\n        }\n      } catch (error) {\n        throw new Error(\n          `Failed to create gnode: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          { cause: error },\n        );\n      }\n    },\n  },\n\n  'gnode list-templates': {\n    name: 'gnode list-templates',\n    description: 'List available gnode templates',\n    aliases: ['gnode ls'],\n    handler: async (_args: string[], _options: any) => {\n      console.log('üì¶ Discovering installed templates...\\n');\n\n      const templates = await discoverInstalledTemplates();\n\n      if (templates.length === 0) {\n        console.log('No templates found in node_modules.');\n        console.log(\n          '\\nTo use a template, install a package that provides one:',\n        );\n        console.log('  npm install @happyvertical/praeco');\n        console.log('\\nOr use a git repository:');\n        console.log('  smrt gnode create my-town --template=github:user/repo');\n        return;\n      }\n\n      console.log('Available templates:\\n');\n\n      for (const t of templates) {\n        console.log(`  ${t.name}`);\n        console.log(`    ${t.config.description}`);\n        console.log(`    Source: ${t.source}`);\n        console.log(`    Framework: ${t.config.framework || 'unknown'}`);\n        console.log();\n      }\n\n      console.log(`Found ${templates.length} template(s)\\n`);\n      console.log('Usage:');\n      console.log('  smrt gnode create <name> --template=<template-name>');\n      console.log('  smrt gnode create my-town --template=sveltekit');\n    },\n  },\n};\n"],"names":["resolve","module","validateTemplateConfig","normalizedPath"],"mappings":"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"}