{"version":3,"file":"index-CEGpQ-x1.js","sources":["../../src/cli/commands/generate.ts","../../../../node_modules/.pnpm/minipass@7.1.2/node_modules/minipass/dist/esm/index.js","../../../../node_modules/.pnpm/@isaacs+fs-minipass@4.0.1/node_modules/@isaacs/fs-minipass/dist/esm/index.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/options.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/make-command.js","../../../../node_modules/.pnpm/minizlib@3.1.0/node_modules/minizlib/dist/esm/constants.js","../../../../node_modules/.pnpm/minizlib@3.1.0/node_modules/minizlib/dist/esm/index.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/large-numbers.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/types.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/header.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/pax.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/normalize-windows-path.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/read-entry.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/warn-method.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/parse.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/strip-trailing-slashes.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/list.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/mode-fix.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/strip-absolute-path.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/winchars.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/write-entry.js","../../../../node_modules/.pnpm/yallist@5.0.0/node_modules/yallist/dist/esm/index.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/pack.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/create.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/get-write-flag.js","../../../../node_modules/.pnpm/chownr@3.0.0/node_modules/chownr/dist/esm/index.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/cwd-error.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/symlink-error.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/mkdir.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/normalize-unicode.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/path-reservations.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/unpack.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/extract.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/replace.js","../../../../node_modules/.pnpm/tar@7.5.1/node_modules/tar/dist/esm/update.js","../../src/cli/loaders/git-loader.ts","../../src/cli/loaders/local-loader.ts","../../src/cli/loaders/npm-loader.ts","../../src/cli/loaders/template-loader.ts","../../src/cli/utils/generator.ts","../../src/cli/commands/gnode.ts"],"sourcesContent":["/**\n * Code Generation CLI Commands\n *\n * Commands for generating code, types, and other artifacts\n */\n\nimport type { CLICommand } from '../../generators/cli.js';\nimport { generateDeclarationsFromCLI } from '../../prebuild/index.js';\n\n/**\n * Code generation commands for CLI\n */\nexport const generateCommands: Record<string, CLICommand> = {\n  'generate-types': {\n    name: 'generate-types',\n    description: 'Generate TypeScript declarations from SMRT manifest',\n    aliases: ['generate-declarations'],\n    args: ['manifest-path'],\n    options: {\n      'output-dir': {\n        type: 'string',\n        description: 'Output directory for generated types',\n      },\n    },\n    handler: async (args: string[], options: any) => {\n      const manifestPath = args[0];\n      if (!manifestPath) {\n        throw new Error(\n          'Manifest path is required: smrt generate-types <manifest-path> [output-dir]',\n        );\n      }\n\n      const outputDir = options.outputDir || args[1];\n\n      try {\n        const cliArgs = outputDir ? [manifestPath, outputDir] : [manifestPath];\n        await generateDeclarationsFromCLI(cliArgs);\n      } catch (error) {\n        throw new Error(\n          `Failed to generate types: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        );\n      }\n    },\n  },\n};\n","const proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nimport { EventEmitter } from 'node:events';\nimport Stream from 'node:stream';\nimport { StringDecoder } from 'node:string_decoder';\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof Stream ||\n        isReadable(s) ||\n        isWritable(s));\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== Stream.Writable.prototype.pipe;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass extends EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return isStream;\n    }\n}\n//# sourceMappingURL=index.js.map","import EE from 'events';\nimport fs from 'fs';\nimport { Minipass } from 'minipass';\nconst writev = fs.writev;\nconst _autoClose = Symbol('_autoClose');\nconst _close = Symbol('_close');\nconst _ended = Symbol('_ended');\nconst _fd = Symbol('_fd');\nconst _finished = Symbol('_finished');\nconst _flags = Symbol('_flags');\nconst _flush = Symbol('_flush');\nconst _handleChunk = Symbol('_handleChunk');\nconst _makeBuf = Symbol('_makeBuf');\nconst _mode = Symbol('_mode');\nconst _needDrain = Symbol('_needDrain');\nconst _onerror = Symbol('_onerror');\nconst _onopen = Symbol('_onopen');\nconst _onread = Symbol('_onread');\nconst _onwrite = Symbol('_onwrite');\nconst _open = Symbol('_open');\nconst _path = Symbol('_path');\nconst _pos = Symbol('_pos');\nconst _queue = Symbol('_queue');\nconst _read = Symbol('_read');\nconst _readSize = Symbol('_readSize');\nconst _reading = Symbol('_reading');\nconst _remain = Symbol('_remain');\nconst _size = Symbol('_size');\nconst _write = Symbol('_write');\nconst _writing = Symbol('_writing');\nconst _defaultFlag = Symbol('_defaultFlag');\nconst _errored = Symbol('_errored');\nexport class ReadStream extends Minipass {\n    [_errored] = false;\n    [_fd];\n    [_path];\n    [_readSize];\n    [_reading] = false;\n    [_size];\n    [_remain];\n    [_autoClose];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this.readable = true;\n        this.writable = false;\n        if (typeof path !== 'string') {\n            throw new TypeError('path must be a string');\n        }\n        this[_errored] = false;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_path] = path;\n        this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n        this[_reading] = false;\n        this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n        this[_remain] = this[_size];\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        if (typeof this[_fd] === 'number') {\n            this[_read]();\n        }\n        else {\n            this[_open]();\n        }\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    //@ts-ignore\n    write() {\n        throw new TypeError('this is a readable stream');\n    }\n    //@ts-ignore\n    end() {\n        throw new TypeError('this is a readable stream');\n    }\n    [_open]() {\n        fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            this[_read]();\n        }\n    }\n    [_makeBuf]() {\n        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n    }\n    [_read]() {\n        if (!this[_reading]) {\n            this[_reading] = true;\n            const buf = this[_makeBuf]();\n            /* c8 ignore start */\n            if (buf.length === 0) {\n                return process.nextTick(() => this[_onread](null, 0, buf));\n            }\n            /* c8 ignore stop */\n            fs.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));\n        }\n    }\n    [_onread](er, br, buf) {\n        this[_reading] = false;\n        if (er) {\n            this[_onerror](er);\n        }\n        else if (this[_handleChunk](br, buf)) {\n            this[_read]();\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n    [_onerror](er) {\n        this[_reading] = true;\n        this[_close]();\n        this.emit('error', er);\n    }\n    [_handleChunk](br, buf) {\n        let ret = false;\n        // no effect if infinite\n        this[_remain] -= br;\n        if (br > 0) {\n            ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);\n        }\n        if (br === 0 || this[_remain] <= 0) {\n            ret = false;\n            this[_close]();\n            super.end();\n        }\n        return ret;\n    }\n    emit(ev, ...args) {\n        switch (ev) {\n            case 'prefinish':\n            case 'finish':\n                return false;\n            case 'drain':\n                if (typeof this[_fd] === 'number') {\n                    this[_read]();\n                }\n                return false;\n            case 'error':\n                if (this[_errored]) {\n                    return false;\n                }\n                this[_errored] = true;\n                return super.emit(ev, ...args);\n            default:\n                return super.emit(ev, ...args);\n        }\n    }\n}\nexport class ReadStreamSync extends ReadStream {\n    [_open]() {\n        let threw = true;\n        try {\n            this[_onopen](null, fs.openSync(this[_path], 'r'));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_read]() {\n        let threw = true;\n        try {\n            if (!this[_reading]) {\n                this[_reading] = true;\n                do {\n                    const buf = this[_makeBuf]();\n                    /* c8 ignore start */\n                    const br = buf.length === 0\n                        ? 0\n                        : fs.readSync(this[_fd], buf, 0, buf.length, null);\n                    /* c8 ignore stop */\n                    if (!this[_handleChunk](br, buf)) {\n                        break;\n                    }\n                } while (true);\n                this[_reading] = false;\n            }\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs.closeSync(fd);\n            this.emit('close');\n        }\n    }\n}\nexport class WriteStream extends EE {\n    readable = false;\n    writable = true;\n    [_errored] = false;\n    [_writing] = false;\n    [_ended] = false;\n    [_queue] = [];\n    [_needDrain] = false;\n    [_path];\n    [_mode];\n    [_autoClose];\n    [_fd];\n    [_defaultFlag];\n    [_flags];\n    [_finished] = false;\n    [_pos];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this[_path] = path;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;\n        this[_pos] = typeof opt.start === 'number' ? opt.start : undefined;\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        // truncating makes no sense when writing into the middle\n        const defaultFlag = this[_pos] !== undefined ? 'r+' : 'w';\n        this[_defaultFlag] = opt.flags === undefined;\n        this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;\n        if (this[_fd] === undefined) {\n            this[_open]();\n        }\n    }\n    emit(ev, ...args) {\n        if (ev === 'error') {\n            if (this[_errored]) {\n                return false;\n            }\n            this[_errored] = true;\n        }\n        return super.emit(ev, ...args);\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    [_onerror](er) {\n        this[_close]();\n        this[_writing] = true;\n        this.emit('error', er);\n    }\n    [_open]() {\n        fs.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (this[_defaultFlag] &&\n            this[_flags] === 'r+' &&\n            er &&\n            er.code === 'ENOENT') {\n            this[_flags] = 'w';\n            this[_open]();\n        }\n        else if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            if (!this[_writing]) {\n                this[_flush]();\n            }\n        }\n    }\n    end(buf, enc) {\n        if (buf) {\n            //@ts-ignore\n            this.write(buf, enc);\n        }\n        this[_ended] = true;\n        // synthetic after-write logic, where drain/finish live\n        if (!this[_writing] &&\n            !this[_queue].length &&\n            typeof this[_fd] === 'number') {\n            this[_onwrite](null, 0);\n        }\n        return this;\n    }\n    write(buf, enc) {\n        if (typeof buf === 'string') {\n            buf = Buffer.from(buf, enc);\n        }\n        if (this[_ended]) {\n            this.emit('error', new Error('write() after end()'));\n            return false;\n        }\n        if (this[_fd] === undefined || this[_writing] || this[_queue].length) {\n            this[_queue].push(buf);\n            this[_needDrain] = true;\n            return false;\n        }\n        this[_writing] = true;\n        this[_write](buf);\n        return true;\n    }\n    [_write](buf) {\n        fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));\n    }\n    [_onwrite](er, bw) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            if (this[_pos] !== undefined && typeof bw === 'number') {\n                this[_pos] += bw;\n            }\n            if (this[_queue].length) {\n                this[_flush]();\n            }\n            else {\n                this[_writing] = false;\n                if (this[_ended] && !this[_finished]) {\n                    this[_finished] = true;\n                    this[_close]();\n                    this.emit('finish');\n                }\n                else if (this[_needDrain]) {\n                    this[_needDrain] = false;\n                    this.emit('drain');\n                }\n            }\n        }\n    }\n    [_flush]() {\n        if (this[_queue].length === 0) {\n            if (this[_ended]) {\n                this[_onwrite](null, 0);\n            }\n        }\n        else if (this[_queue].length === 1) {\n            this[_write](this[_queue].pop());\n        }\n        else {\n            const iovec = this[_queue];\n            this[_queue] = [];\n            writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n}\nexport class WriteStreamSync extends WriteStream {\n    [_open]() {\n        let fd;\n        // only wrap in a try{} block if we know we'll retry, to avoid\n        // the rethrow obscuring the error's source frame in most cases.\n        if (this[_defaultFlag] && this[_flags] === 'r+') {\n            try {\n                fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n            }\n            catch (er) {\n                if (er?.code === 'ENOENT') {\n                    this[_flags] = 'w';\n                    return this[_open]();\n                }\n                else {\n                    throw er;\n                }\n            }\n        }\n        else {\n            fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n        }\n        this[_onopen](null, fd);\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs.closeSync(fd);\n            this.emit('close');\n        }\n    }\n    [_write](buf) {\n        // throw the original, but try to close if it fails\n        let threw = true;\n        try {\n            this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                try {\n                    this[_close]();\n                }\n                catch {\n                    // ok error\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","// turn tar(1) style args like `C` into the more verbose things like `cwd`\nconst argmap = new Map([\n    ['C', 'cwd'],\n    ['f', 'file'],\n    ['z', 'gzip'],\n    ['P', 'preservePaths'],\n    ['U', 'unlink'],\n    ['strip-components', 'strip'],\n    ['stripComponents', 'strip'],\n    ['keep-newer', 'newer'],\n    ['keepNewer', 'newer'],\n    ['keep-newer-files', 'newer'],\n    ['keepNewerFiles', 'newer'],\n    ['k', 'keep'],\n    ['keep-existing', 'keep'],\n    ['keepExisting', 'keep'],\n    ['m', 'noMtime'],\n    ['no-mtime', 'noMtime'],\n    ['p', 'preserveOwner'],\n    ['L', 'follow'],\n    ['h', 'follow'],\n    ['onentry', 'onReadEntry'],\n]);\nexport const isSyncFile = (o) => !!o.sync && !!o.file;\nexport const isAsyncFile = (o) => !o.sync && !!o.file;\nexport const isSyncNoFile = (o) => !!o.sync && !o.file;\nexport const isAsyncNoFile = (o) => !o.sync && !o.file;\nexport const isSync = (o) => !!o.sync;\nexport const isAsync = (o) => !o.sync;\nexport const isFile = (o) => !!o.file;\nexport const isNoFile = (o) => !o.file;\nconst dealiasKey = (k) => {\n    const d = argmap.get(k);\n    if (d)\n        return d;\n    return k;\n};\nexport const dealias = (opt = {}) => {\n    if (!opt)\n        return {};\n    const result = {};\n    for (const [key, v] of Object.entries(opt)) {\n        // TS doesn't know that aliases are going to always be the same type\n        const k = dealiasKey(key);\n        result[k] = v;\n    }\n    // affordance for deprecated noChmod -> chmod\n    if (result.chmod === undefined && result.noChmod === false) {\n        result.chmod = true;\n    }\n    delete result.noChmod;\n    return result;\n};\n//# sourceMappingURL=options.js.map","import { dealias, isAsyncFile, isAsyncNoFile, isSyncFile, isSyncNoFile, } from './options.js';\nexport const makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => {\n    return Object.assign((opt_ = [], entries, cb) => {\n        if (Array.isArray(opt_)) {\n            entries = opt_;\n            opt_ = {};\n        }\n        if (typeof entries === 'function') {\n            cb = entries;\n            entries = undefined;\n        }\n        if (!entries) {\n            entries = [];\n        }\n        else {\n            entries = Array.from(entries);\n        }\n        const opt = dealias(opt_);\n        validate?.(opt, entries);\n        if (isSyncFile(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncFile(opt, entries);\n        }\n        else if (isAsyncFile(opt)) {\n            const p = asyncFile(opt, entries);\n            // weirdness to make TS happy\n            const c = cb ? cb : undefined;\n            return c ? p.then(() => c(), c) : p;\n        }\n        else if (isSyncNoFile(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncNoFile(opt, entries);\n        }\n        else if (isAsyncNoFile(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback only supported with file option');\n            }\n            return asyncNoFile(opt, entries);\n            /* c8 ignore start */\n        }\n        else {\n            throw new Error('impossible options??');\n        }\n        /* c8 ignore stop */\n    }, {\n        syncFile,\n        asyncFile,\n        syncNoFile,\n        asyncNoFile,\n        validate,\n    });\n};\n//# sourceMappingURL=make-command.js.map","// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nimport realZlib from 'zlib';\n/* c8 ignore start */\nconst realZlibConstants = realZlib.constants || { ZLIB_VERNUM: 4736 };\n/* c8 ignore stop */\nexport const constants = Object.freeze(Object.assign(Object.create(null), {\n    Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    Z_MEM_ERROR: -4,\n    Z_BUF_ERROR: -5,\n    Z_VERSION_ERROR: -6,\n    Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    DEFLATE: 1,\n    INFLATE: 2,\n    GZIP: 3,\n    GUNZIP: 4,\n    DEFLATERAW: 5,\n    INFLATERAW: 6,\n    UNZIP: 7,\n    BROTLI_DECODE: 8,\n    BROTLI_ENCODE: 9,\n    Z_MIN_WINDOWBITS: 8,\n    Z_MAX_WINDOWBITS: 15,\n    Z_DEFAULT_WINDOWBITS: 15,\n    Z_MIN_CHUNK: 64,\n    Z_MAX_CHUNK: Infinity,\n    Z_DEFAULT_CHUNK: 16384,\n    Z_MIN_MEMLEVEL: 1,\n    Z_MAX_MEMLEVEL: 9,\n    Z_DEFAULT_MEMLEVEL: 8,\n    Z_MIN_LEVEL: -1,\n    Z_MAX_LEVEL: 9,\n    Z_DEFAULT_LEVEL: -1,\n    BROTLI_OPERATION_PROCESS: 0,\n    BROTLI_OPERATION_FLUSH: 1,\n    BROTLI_OPERATION_FINISH: 2,\n    BROTLI_OPERATION_EMIT_METADATA: 3,\n    BROTLI_MODE_GENERIC: 0,\n    BROTLI_MODE_TEXT: 1,\n    BROTLI_MODE_FONT: 2,\n    BROTLI_DEFAULT_MODE: 0,\n    BROTLI_MIN_QUALITY: 0,\n    BROTLI_MAX_QUALITY: 11,\n    BROTLI_DEFAULT_QUALITY: 11,\n    BROTLI_MIN_WINDOW_BITS: 10,\n    BROTLI_MAX_WINDOW_BITS: 24,\n    BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n    BROTLI_DEFAULT_WINDOW: 22,\n    BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n    BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n    BROTLI_PARAM_MODE: 0,\n    BROTLI_PARAM_QUALITY: 1,\n    BROTLI_PARAM_LGWIN: 2,\n    BROTLI_PARAM_LGBLOCK: 3,\n    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n    BROTLI_PARAM_SIZE_HINT: 5,\n    BROTLI_PARAM_LARGE_WINDOW: 6,\n    BROTLI_PARAM_NPOSTFIX: 7,\n    BROTLI_PARAM_NDIRECT: 8,\n    BROTLI_DECODER_RESULT_ERROR: 0,\n    BROTLI_DECODER_RESULT_SUCCESS: 1,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n    BROTLI_DECODER_NO_ERROR: 0,\n    BROTLI_DECODER_SUCCESS: 1,\n    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n    BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants));\n//# sourceMappingURL=constants.js.map","import assert from 'assert';\nimport { Buffer } from 'buffer';\nimport { Minipass } from 'minipass';\nimport * as realZlib from 'zlib';\nimport { constants } from './constants.js';\nexport { constants } from './constants.js';\nconst OriginalBufferConcat = Buffer.concat;\nconst desc = Object.getOwnPropertyDescriptor(Buffer, 'concat');\nconst noop = (args) => args;\nconst passthroughBufferConcat = desc?.writable === true || desc?.set !== undefined\n    ? (makeNoOp) => {\n        Buffer.concat = makeNoOp ? noop : OriginalBufferConcat;\n    }\n    : (_) => { };\nconst _superWrite = Symbol('_superWrite');\nexport class ZlibError extends Error {\n    code;\n    errno;\n    constructor(err, origin) {\n        super('zlib: ' + err.message, { cause: err });\n        this.code = err.code;\n        this.errno = err.errno;\n        /* c8 ignore next */\n        if (!this.code)\n            this.code = 'ZLIB_ERROR';\n        this.message = 'zlib: ' + err.message;\n        Error.captureStackTrace(this, origin ?? this.constructor);\n    }\n    get name() {\n        return 'ZlibError';\n    }\n}\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _flushFlag = Symbol('flushFlag');\nclass ZlibBase extends Minipass {\n    #sawError = false;\n    #ended = false;\n    #flushFlag;\n    #finishFlushFlag;\n    #fullFlushFlag;\n    #handle;\n    #onError;\n    get sawError() {\n        return this.#sawError;\n    }\n    get handle() {\n        return this.#handle;\n    }\n    /* c8 ignore start */\n    get flushFlag() {\n        return this.#flushFlag;\n    }\n    /* c8 ignore stop */\n    constructor(opts, mode) {\n        if (!opts || typeof opts !== 'object')\n            throw new TypeError('invalid options for ZlibBase constructor');\n        //@ts-ignore\n        super(opts);\n        /* c8 ignore start */\n        this.#flushFlag = opts.flush ?? 0;\n        this.#finishFlushFlag = opts.finishFlush ?? 0;\n        this.#fullFlushFlag = opts.fullFlushFlag ?? 0;\n        /* c8 ignore stop */\n        //@ts-ignore\n        if (typeof realZlib[mode] !== 'function') {\n            throw new TypeError('Compression method not supported: ' + mode);\n        }\n        // this will throw if any options are invalid for the class selected\n        try {\n            // @types/node doesn't know that it exports the classes, but they're there\n            //@ts-ignore\n            this.#handle = new realZlib[mode](opts);\n        }\n        catch (er) {\n            // make sure that all errors get decorated properly\n            throw new ZlibError(er, this.constructor);\n        }\n        this.#onError = err => {\n            // no sense raising multiple errors, since we abort on the first one.\n            if (this.#sawError)\n                return;\n            this.#sawError = true;\n            // there is no way to cleanly recover.\n            // continuing only obscures problems.\n            this.close();\n            this.emit('error', err);\n        };\n        this.#handle?.on('error', er => this.#onError(new ZlibError(er)));\n        this.once('end', () => this.close);\n    }\n    close() {\n        if (this.#handle) {\n            this.#handle.close();\n            this.#handle = undefined;\n            this.emit('close');\n        }\n    }\n    reset() {\n        if (!this.#sawError) {\n            assert(this.#handle, 'zlib binding closed');\n            //@ts-ignore\n            return this.#handle.reset?.();\n        }\n    }\n    flush(flushFlag) {\n        if (this.ended)\n            return;\n        if (typeof flushFlag !== 'number')\n            flushFlag = this.#fullFlushFlag;\n        this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }));\n    }\n    end(chunk, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (chunk) {\n            if (encoding)\n                this.write(chunk, encoding);\n            else\n                this.write(chunk);\n        }\n        this.flush(this.#finishFlushFlag);\n        this.#ended = true;\n        return super.end(cb);\n    }\n    get ended() {\n        return this.#ended;\n    }\n    // overridden in the gzip classes to do portable writes\n    [_superWrite](data) {\n        return super.write(data);\n    }\n    write(chunk, encoding, cb) {\n        // process the chunk using the sync process\n        // then super.write() all the outputted chunks\n        if (typeof encoding === 'function')\n            (cb = encoding), (encoding = 'utf8');\n        if (typeof chunk === 'string')\n            chunk = Buffer.from(chunk, encoding);\n        if (this.#sawError)\n            return;\n        assert(this.#handle, 'zlib binding closed');\n        // _processChunk tries to .close() the native handle after it's done, so we\n        // intercept that by temporarily making it a no-op.\n        // diving into the node:zlib internals a bit here\n        const nativeHandle = this.#handle\n            ._handle;\n        const originalNativeClose = nativeHandle.close;\n        nativeHandle.close = () => { };\n        const originalClose = this.#handle.close;\n        this.#handle.close = () => { };\n        // It also calls `Buffer.concat()` at the end, which may be convenient\n        // for some, but which we are not interested in as it slows us down.\n        passthroughBufferConcat(true);\n        let result = undefined;\n        try {\n            const flushFlag = typeof chunk[_flushFlag] === 'number'\n                ? chunk[_flushFlag]\n                : this.#flushFlag;\n            result = this.#handle._processChunk(chunk, flushFlag);\n            // if we don't throw, reset it back how it was\n            passthroughBufferConcat(false);\n        }\n        catch (err) {\n            // or if we do, put Buffer.concat() back before we emit error\n            // Error events call into user code, which may call Buffer.concat()\n            passthroughBufferConcat(false);\n            this.#onError(new ZlibError(err, this.write));\n        }\n        finally {\n            if (this.#handle) {\n                // Core zlib resets `_handle` to null after attempting to close the\n                // native handle. Our no-op handler prevented actual closure, but we\n                // need to restore the `._handle` property.\n                ;\n                this.#handle._handle =\n                    nativeHandle;\n                nativeHandle.close = originalNativeClose;\n                this.#handle.close = originalClose;\n                // `_processChunk()` adds an 'error' listener. If we don't remove it\n                // after each call, these handlers start piling up.\n                this.#handle.removeAllListeners('error');\n                // make sure OUR error listener is still attached tho\n            }\n        }\n        if (this.#handle)\n            this.#handle.on('error', er => this.#onError(new ZlibError(er, this.write)));\n        let writeReturn;\n        if (result) {\n            if (Array.isArray(result) && result.length > 0) {\n                const r = result[0];\n                // The first buffer is always `handle._outBuffer`, which would be\n                // re-used for later invocations; so, we always have to copy that one.\n                writeReturn = this[_superWrite](Buffer.from(r));\n                for (let i = 1; i < result.length; i++) {\n                    writeReturn = this[_superWrite](result[i]);\n                }\n            }\n            else {\n                // either a single Buffer or an empty array\n                writeReturn = this[_superWrite](Buffer.from(result));\n            }\n        }\n        if (cb)\n            cb();\n        return writeReturn;\n    }\n}\nexport class Zlib extends ZlibBase {\n    #level;\n    #strategy;\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || constants.Z_NO_FLUSH;\n        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;\n        opts.fullFlushFlag = constants.Z_FULL_FLUSH;\n        super(opts, mode);\n        this.#level = opts.level;\n        this.#strategy = opts.strategy;\n    }\n    params(level, strategy) {\n        if (this.sawError)\n            return;\n        if (!this.handle)\n            throw new Error('cannot switch params when binding is closed');\n        // no way to test this without also not supporting params at all\n        /* c8 ignore start */\n        if (!this.handle.params)\n            throw new Error('not supported in this implementation');\n        /* c8 ignore stop */\n        if (this.#level !== level || this.#strategy !== strategy) {\n            this.flush(constants.Z_SYNC_FLUSH);\n            assert(this.handle, 'zlib binding closed');\n            // .params() calls .flush(), but the latter is always async in the\n            // core zlib. We override .flush() temporarily to intercept that and\n            // flush synchronously.\n            const origFlush = this.handle.flush;\n            this.handle.flush = (flushFlag, cb) => {\n                /* c8 ignore start */\n                if (typeof flushFlag === 'function') {\n                    cb = flushFlag;\n                    flushFlag = this.flushFlag;\n                }\n                /* c8 ignore stop */\n                this.flush(flushFlag);\n                cb?.();\n            };\n            try {\n                ;\n                this.handle.params(level, strategy);\n            }\n            finally {\n                this.handle.flush = origFlush;\n            }\n            /* c8 ignore start */\n            if (this.handle) {\n                this.#level = level;\n                this.#strategy = strategy;\n            }\n            /* c8 ignore stop */\n        }\n    }\n}\n// minimal 2-byte header\nexport class Deflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Deflate');\n    }\n}\nexport class Inflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Inflate');\n    }\n}\nexport class Gzip extends Zlib {\n    #portable;\n    constructor(opts) {\n        super(opts, 'Gzip');\n        this.#portable = opts && !!opts.portable;\n    }\n    [_superWrite](data) {\n        if (!this.#portable)\n            return super[_superWrite](data);\n        // we'll always get the header emitted in one first chunk\n        // overwrite the OS indicator byte with 0xFF\n        this.#portable = false;\n        data[9] = 255;\n        return super[_superWrite](data);\n    }\n}\nexport class Gunzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Gunzip');\n    }\n}\n// raw - no header\nexport class DeflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'DeflateRaw');\n    }\n}\nexport class InflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'InflateRaw');\n    }\n}\n// auto-detect header.\nexport class Unzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Unzip');\n    }\n}\nclass Brotli extends ZlibBase {\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;\n        opts.finishFlush =\n            opts.finishFlush || constants.BROTLI_OPERATION_FINISH;\n        opts.fullFlushFlag = constants.BROTLI_OPERATION_FLUSH;\n        super(opts, mode);\n    }\n}\nexport class BrotliCompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliCompress');\n    }\n}\nexport class BrotliDecompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliDecompress');\n    }\n}\nclass Zstd extends ZlibBase {\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || constants.ZSTD_e_continue;\n        opts.finishFlush = opts.finishFlush || constants.ZSTD_e_end;\n        opts.fullFlushFlag = constants.ZSTD_e_flush;\n        super(opts, mode);\n    }\n}\nexport class ZstdCompress extends Zstd {\n    constructor(opts) {\n        super(opts, 'ZstdCompress');\n    }\n}\nexport class ZstdDecompress extends Zstd {\n    constructor(opts) {\n        super(opts, 'ZstdDecompress');\n    }\n}\n//# sourceMappingURL=index.js.map","// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\nexport const encode = (num, buf) => {\n    if (!Number.isSafeInteger(num)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('cannot encode number outside of javascript safe integer range');\n    }\n    else if (num < 0) {\n        encodeNegative(num, buf);\n    }\n    else {\n        encodePositive(num, buf);\n    }\n    return buf;\n};\nconst encodePositive = (num, buf) => {\n    buf[0] = 0x80;\n    for (var i = buf.length; i > 1; i--) {\n        buf[i - 1] = num & 0xff;\n        num = Math.floor(num / 0x100);\n    }\n};\nconst encodeNegative = (num, buf) => {\n    buf[0] = 0xff;\n    var flipped = false;\n    num = num * -1;\n    for (var i = buf.length; i > 1; i--) {\n        var byte = num & 0xff;\n        num = Math.floor(num / 0x100);\n        if (flipped) {\n            buf[i - 1] = onesComp(byte);\n        }\n        else if (byte === 0) {\n            buf[i - 1] = 0;\n        }\n        else {\n            flipped = true;\n            buf[i - 1] = twosComp(byte);\n        }\n    }\n};\nexport const parse = (buf) => {\n    const pre = buf[0];\n    const value = pre === 0x80 ? pos(buf.subarray(1, buf.length))\n        : pre === 0xff ? twos(buf)\n            : null;\n    if (value === null) {\n        throw Error('invalid base256 encoding');\n    }\n    if (!Number.isSafeInteger(value)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('parsed number outside of javascript safe integer range');\n    }\n    return value;\n};\nconst twos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    var flipped = false;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        var f;\n        if (flipped) {\n            f = onesComp(byte);\n        }\n        else if (byte === 0) {\n            f = byte;\n        }\n        else {\n            flipped = true;\n            f = twosComp(byte);\n        }\n        if (f !== 0) {\n            sum -= f * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst pos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        if (byte !== 0) {\n            sum += byte * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst onesComp = (byte) => (0xff ^ byte) & 0xff;\nconst twosComp = (byte) => ((0xff ^ byte) + 1) & 0xff;\n//# sourceMappingURL=large-numbers.js.map","export const isCode = (c) => name.has(c);\nexport const isName = (c) => code.has(c);\n// map types from key to human-friendly name\nexport const name = new Map([\n    ['0', 'File'],\n    // same as File\n    ['', 'OldFile'],\n    ['1', 'Link'],\n    ['2', 'SymbolicLink'],\n    // Devices and FIFOs aren't fully supported\n    // they are parsed, but skipped when unpacking\n    ['3', 'CharacterDevice'],\n    ['4', 'BlockDevice'],\n    ['5', 'Directory'],\n    ['6', 'FIFO'],\n    // same as File\n    ['7', 'ContiguousFile'],\n    // pax headers\n    ['g', 'GlobalExtendedHeader'],\n    ['x', 'ExtendedHeader'],\n    // vendor-specific stuff\n    // skip\n    ['A', 'SolarisACL'],\n    // like 5, but with data, which should be skipped\n    ['D', 'GNUDumpDir'],\n    // metadata only, skip\n    ['I', 'Inode'],\n    // data = link path of next file\n    ['K', 'NextFileHasLongLinkpath'],\n    // data = path of next file\n    ['L', 'NextFileHasLongPath'],\n    // skip\n    ['M', 'ContinuationFile'],\n    // like L\n    ['N', 'OldGnuLongPath'],\n    // skip\n    ['S', 'SparseFile'],\n    // skip\n    ['V', 'TapeVolumeHeader'],\n    // like x\n    ['X', 'OldExtendedHeader'],\n]);\n// map the other direction\nexport const code = new Map(Array.from(name).map(kv => [kv[1], kv[0]]));\n//# sourceMappingURL=types.js.map","// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\nimport { posix as pathModule } from 'node:path';\nimport * as large from './large-numbers.js';\nimport * as types from './types.js';\nexport class Header {\n    cksumValid = false;\n    needPax = false;\n    nullBlock = false;\n    block;\n    path;\n    mode;\n    uid;\n    gid;\n    size;\n    cksum;\n    #type = 'Unsupported';\n    linkpath;\n    uname;\n    gname;\n    devmaj = 0;\n    devmin = 0;\n    atime;\n    ctime;\n    mtime;\n    charset;\n    comment;\n    constructor(data, off = 0, ex, gex) {\n        if (Buffer.isBuffer(data)) {\n            this.decode(data, off || 0, ex, gex);\n        }\n        else if (data) {\n            this.#slurp(data);\n        }\n    }\n    decode(buf, off, ex, gex) {\n        if (!off) {\n            off = 0;\n        }\n        if (!buf || !(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        this.path = decString(buf, off, 100);\n        this.mode = decNumber(buf, off + 100, 8);\n        this.uid = decNumber(buf, off + 108, 8);\n        this.gid = decNumber(buf, off + 116, 8);\n        this.size = decNumber(buf, off + 124, 12);\n        this.mtime = decDate(buf, off + 136, 12);\n        this.cksum = decNumber(buf, off + 148, 12);\n        // if we have extended or global extended headers, apply them now\n        // See https://github.com/npm/node-tar/pull/187\n        // Apply global before local, so it overrides\n        if (gex)\n            this.#slurp(gex, true);\n        if (ex)\n            this.#slurp(ex);\n        // old tar versions marked dirs as a file with a trailing /\n        const t = decString(buf, off + 156, 1);\n        if (types.isCode(t)) {\n            this.#type = t || '0';\n        }\n        if (this.#type === '0' && this.path.slice(-1) === '/') {\n            this.#type = '5';\n        }\n        // tar implementations sometimes incorrectly put the stat(dir).size\n        // as the size in the tarball, even though Directory entries are\n        // not able to have any body at all.  In the very rare chance that\n        // it actually DOES have a body, we weren't going to do anything with\n        // it anyway, and it'll just be a warning about an invalid header.\n        if (this.#type === '5') {\n            this.size = 0;\n        }\n        this.linkpath = decString(buf, off + 157, 100);\n        if (buf.subarray(off + 257, off + 265).toString() ===\n            'ustar\\u000000') {\n            this.uname = decString(buf, off + 265, 32);\n            this.gname = decString(buf, off + 297, 32);\n            /* c8 ignore start */\n            this.devmaj = decNumber(buf, off + 329, 8) ?? 0;\n            this.devmin = decNumber(buf, off + 337, 8) ?? 0;\n            /* c8 ignore stop */\n            if (buf[off + 475] !== 0) {\n                // definitely a prefix, definitely >130 chars.\n                const prefix = decString(buf, off + 345, 155);\n                this.path = prefix + '/' + this.path;\n            }\n            else {\n                const prefix = decString(buf, off + 345, 130);\n                if (prefix) {\n                    this.path = prefix + '/' + this.path;\n                }\n                this.atime = decDate(buf, off + 476, 12);\n                this.ctime = decDate(buf, off + 488, 12);\n            }\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksumValid = sum === this.cksum;\n        if (this.cksum === undefined && sum === 8 * 0x20) {\n            this.nullBlock = true;\n        }\n    }\n    #slurp(ex, gex = false) {\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex) ||\n                (k === 'linkpath' && gex) ||\n                k === 'global');\n        })));\n    }\n    encode(buf, off = 0) {\n        if (!buf) {\n            buf = this.block = Buffer.alloc(512);\n        }\n        if (this.#type === 'Unsupported') {\n            this.#type = '0';\n        }\n        if (!(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        const prefixSize = this.ctime || this.atime ? 130 : 155;\n        const split = splitPrefix(this.path || '', prefixSize);\n        const path = split[0];\n        const prefix = split[1];\n        this.needPax = !!split[2];\n        this.needPax = encString(buf, off, 100, path) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 100, 8, this.mode) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 108, 8, this.uid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 116, 8, this.gid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 124, 12, this.size) || this.needPax;\n        this.needPax =\n            encDate(buf, off + 136, 12, this.mtime) || this.needPax;\n        buf[off + 156] = this.#type.charCodeAt(0);\n        this.needPax =\n            encString(buf, off + 157, 100, this.linkpath) || this.needPax;\n        buf.write('ustar\\u000000', off + 257, 8);\n        this.needPax =\n            encString(buf, off + 265, 32, this.uname) || this.needPax;\n        this.needPax =\n            encString(buf, off + 297, 32, this.gname) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 337, 8, this.devmin) || this.needPax;\n        this.needPax =\n            encString(buf, off + 345, prefixSize, prefix) || this.needPax;\n        if (buf[off + 475] !== 0) {\n            this.needPax =\n                encString(buf, off + 345, 155, prefix) || this.needPax;\n        }\n        else {\n            this.needPax =\n                encString(buf, off + 345, 130, prefix) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 476, 12, this.atime) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 488, 12, this.ctime) || this.needPax;\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksum = sum;\n        encNumber(buf, off + 148, 8, this.cksum);\n        this.cksumValid = true;\n        return this.needPax;\n    }\n    get type() {\n        return (this.#type === 'Unsupported' ?\n            this.#type\n            : types.name.get(this.#type));\n    }\n    get typeKey() {\n        return this.#type;\n    }\n    set type(type) {\n        const c = String(types.code.get(type));\n        if (types.isCode(c) || c === 'Unsupported') {\n            this.#type = c;\n        }\n        else if (types.isCode(type)) {\n            this.#type = type;\n        }\n        else {\n            throw new TypeError('invalid entry type: ' + type);\n        }\n    }\n}\nconst splitPrefix = (p, prefixSize) => {\n    const pathSize = 100;\n    let pp = p;\n    let prefix = '';\n    let ret = undefined;\n    const root = pathModule.parse(p).root || '.';\n    if (Buffer.byteLength(pp) < pathSize) {\n        ret = [pp, prefix, false];\n    }\n    else {\n        // first set prefix to the dir, and path to the base\n        prefix = pathModule.dirname(pp);\n        pp = pathModule.basename(pp);\n        do {\n            if (Buffer.byteLength(pp) <= pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // both fit!\n                ret = [pp, prefix, false];\n            }\n            else if (Buffer.byteLength(pp) > pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // prefix fits in prefix, but path doesn't fit in path\n                ret = [pp.slice(0, pathSize - 1), prefix, true];\n            }\n            else {\n                // make path take a bit from prefix\n                pp = pathModule.join(pathModule.basename(prefix), pp);\n                prefix = pathModule.dirname(prefix);\n            }\n        } while (prefix !== root && ret === undefined);\n        // at this point, found no resolution, just truncate\n        if (!ret) {\n            ret = [p.slice(0, pathSize - 1), '', true];\n        }\n    }\n    return ret;\n};\nconst decString = (buf, off, size) => buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*/, '');\nconst decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));\nconst numToDate = (num) => num === undefined ? undefined : new Date(num * 1000);\nconst decNumber = (buf, off, size) => Number(buf[off]) & 0x80 ?\n    large.parse(buf.subarray(off, off + size))\n    : decSmallNumber(buf, off, size);\nconst nanUndef = (value) => (isNaN(value) ? undefined : value);\nconst decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*$/, '')\n    .trim(), 8));\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n    12: 0o77777777777,\n    8: 0o7777777,\n};\nconst encNumber = (buf, off, size, num) => num === undefined ? false\n    : num > MAXNUM[size] || num < 0 ?\n        (large.encode(num, buf.subarray(off, off + size)), true)\n        : (encSmallNumber(buf, off, size, num), false);\nconst encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, 'ascii');\nconst octalString = (num, size) => padOctal(Math.floor(num).toString(8), size);\nconst padOctal = (str, size) => (str.length === size - 1 ?\n    str\n    : new Array(size - str.length - 1).join('0') + str + ' ') + '\\0';\nconst encDate = (buf, off, size, date) => date === undefined ? false : (encNumber(buf, off, size, date.getTime() / 1000));\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0');\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, str) => str === undefined ? false : ((buf.write(str + NULLS, off, size, 'utf8'),\n    str.length !== Buffer.byteLength(str) || str.length > size));\n//# sourceMappingURL=header.js.map","import { basename } from 'node:path';\nimport { Header } from './header.js';\nexport class Pax {\n    atime;\n    mtime;\n    ctime;\n    charset;\n    comment;\n    gid;\n    uid;\n    gname;\n    uname;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    path;\n    size;\n    mode;\n    global;\n    constructor(obj, global = false) {\n        this.atime = obj.atime;\n        this.charset = obj.charset;\n        this.comment = obj.comment;\n        this.ctime = obj.ctime;\n        this.dev = obj.dev;\n        this.gid = obj.gid;\n        this.global = global;\n        this.gname = obj.gname;\n        this.ino = obj.ino;\n        this.linkpath = obj.linkpath;\n        this.mtime = obj.mtime;\n        this.nlink = obj.nlink;\n        this.path = obj.path;\n        this.size = obj.size;\n        this.uid = obj.uid;\n        this.uname = obj.uname;\n    }\n    encode() {\n        const body = this.encodeBody();\n        if (body === '') {\n            return Buffer.allocUnsafe(0);\n        }\n        const bodyLen = Buffer.byteLength(body);\n        // round up to 512 bytes\n        // add 512 for header\n        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);\n        const buf = Buffer.allocUnsafe(bufLen);\n        // 0-fill the header section, it might not hit every field\n        for (let i = 0; i < 512; i++) {\n            buf[i] = 0;\n        }\n        new Header({\n            // XXX split the path\n            // then the path should be PaxHeader + basename, but less than 99,\n            // prepend with the dirname\n            /* c8 ignore start */\n            path: ('PaxHeader/' + basename(this.path ?? '')).slice(0, 99),\n            /* c8 ignore stop */\n            mode: this.mode || 0o644,\n            uid: this.uid,\n            gid: this.gid,\n            size: bodyLen,\n            mtime: this.mtime,\n            type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n            linkpath: '',\n            uname: this.uname || '',\n            gname: this.gname || '',\n            devmaj: 0,\n            devmin: 0,\n            atime: this.atime,\n            ctime: this.ctime,\n        }).encode(buf);\n        buf.write(body, 512, bodyLen, 'utf8');\n        // null pad after the body\n        for (let i = bodyLen + 512; i < buf.length; i++) {\n            buf[i] = 0;\n        }\n        return buf;\n    }\n    encodeBody() {\n        return (this.encodeField('path') +\n            this.encodeField('ctime') +\n            this.encodeField('atime') +\n            this.encodeField('dev') +\n            this.encodeField('ino') +\n            this.encodeField('nlink') +\n            this.encodeField('charset') +\n            this.encodeField('comment') +\n            this.encodeField('gid') +\n            this.encodeField('gname') +\n            this.encodeField('linkpath') +\n            this.encodeField('mtime') +\n            this.encodeField('size') +\n            this.encodeField('uid') +\n            this.encodeField('uname'));\n    }\n    encodeField(field) {\n        if (this[field] === undefined) {\n            return '';\n        }\n        const r = this[field];\n        const v = r instanceof Date ? r.getTime() / 1000 : r;\n        const s = ' ' +\n            (field === 'dev' || field === 'ino' || field === 'nlink' ?\n                'SCHILY.'\n                : '') +\n            field +\n            '=' +\n            v +\n            '\\n';\n        const byteLen = Buffer.byteLength(s);\n        // the digits includes the length of the digits in ascii base-10\n        // so if it's 9 characters, then adding 1 for the 9 makes it 10\n        // which makes it 11 chars.\n        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;\n        if (byteLen + digits >= Math.pow(10, digits)) {\n            digits += 1;\n        }\n        const len = digits + byteLen;\n        return len + s;\n    }\n    static parse(str, ex, g = false) {\n        return new Pax(merge(parseKV(str), ex), g);\n    }\n}\nconst merge = (a, b) => b ? Object.assign({}, b, a) : a;\nconst parseKV = (str) => str\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null));\nconst parseKVLine = (set, line) => {\n    const n = parseInt(line, 10);\n    // XXX Values with \\n in them will fail this.\n    // Refactor to not be a naive line-by-line parse.\n    if (n !== Buffer.byteLength(line) + 1) {\n        return set;\n    }\n    line = line.slice((n + ' ').length);\n    const kv = line.split('=');\n    const r = kv.shift();\n    if (!r) {\n        return set;\n    }\n    const k = r.replace(/^SCHILY\\.(dev|ino|nlink)/, '$1');\n    const v = kv.join('=');\n    set[k] =\n        /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k) ?\n            new Date(Number(v) * 1000)\n            : /^[0-9]+$/.test(v) ? +v\n                : v;\n    return set;\n};\n//# sourceMappingURL=pax.js.map","// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nexport const normalizeWindowsPath = platform !== 'win32' ?\n    (p) => p\n    : (p) => p && p.replace(/\\\\/g, '/');\n//# sourceMappingURL=normalize-windows-path.js.map","import { Minipass } from 'minipass';\nimport { normalizeWindowsPath } from './normalize-windows-path.js';\nexport class ReadEntry extends Minipass {\n    extended;\n    globalExtended;\n    header;\n    startBlockSize;\n    blockRemain;\n    remain;\n    type;\n    meta = false;\n    ignore = false;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    size = 0;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    invalid = false;\n    absolute;\n    unsupported = false;\n    constructor(header, ex, gex) {\n        super({});\n        // read entries always start life paused.  this is to avoid the\n        // situation where Minipass's auto-ending empty streams results\n        // in an entry ending before we're ready for it.\n        this.pause();\n        this.extended = ex;\n        this.globalExtended = gex;\n        this.header = header;\n        /* c8 ignore start */\n        this.remain = header.size ?? 0;\n        /* c8 ignore stop */\n        this.startBlockSize = 512 * Math.ceil(this.remain / 512);\n        this.blockRemain = this.startBlockSize;\n        this.type = header.type;\n        switch (this.type) {\n            case 'File':\n            case 'OldFile':\n            case 'Link':\n            case 'SymbolicLink':\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'Directory':\n            case 'FIFO':\n            case 'ContiguousFile':\n            case 'GNUDumpDir':\n                break;\n            case 'NextFileHasLongLinkpath':\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath':\n            case 'GlobalExtendedHeader':\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this.meta = true;\n                break;\n            // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n            // it may be worth doing the same, but with a warning.\n            default:\n                this.ignore = true;\n        }\n        /* c8 ignore start */\n        if (!header.path) {\n            throw new Error('no path provided for tar.ReadEntry');\n        }\n        /* c8 ignore stop */\n        this.path = normalizeWindowsPath(header.path);\n        this.mode = header.mode;\n        if (this.mode) {\n            this.mode = this.mode & 0o7777;\n        }\n        this.uid = header.uid;\n        this.gid = header.gid;\n        this.uname = header.uname;\n        this.gname = header.gname;\n        this.size = this.remain;\n        this.mtime = header.mtime;\n        this.atime = header.atime;\n        this.ctime = header.ctime;\n        /* c8 ignore start */\n        this.linkpath =\n            header.linkpath ?\n                normalizeWindowsPath(header.linkpath)\n                : undefined;\n        /* c8 ignore stop */\n        this.uname = header.uname;\n        this.gname = header.gname;\n        if (ex) {\n            this.#slurp(ex);\n        }\n        if (gex) {\n            this.#slurp(gex, true);\n        }\n    }\n    write(data) {\n        const writeLen = data.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        const r = this.remain;\n        const br = this.blockRemain;\n        this.remain = Math.max(0, r - writeLen);\n        this.blockRemain = Math.max(0, br - writeLen);\n        if (this.ignore) {\n            return true;\n        }\n        if (r >= writeLen) {\n            return super.write(data);\n        }\n        // r < writeLen\n        return super.write(data.subarray(0, r));\n    }\n    #slurp(ex, gex = false) {\n        if (ex.path)\n            ex.path = normalizeWindowsPath(ex.path);\n        if (ex.linkpath)\n            ex.linkpath = normalizeWindowsPath(ex.linkpath);\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex));\n        })));\n    }\n}\n//# sourceMappingURL=read-entry.js.map","export const warnMethod = (self, code, message, data = {}) => {\n    if (self.file) {\n        data.file = self.file;\n    }\n    if (self.cwd) {\n        data.cwd = self.cwd;\n    }\n    data.code =\n        (message instanceof Error &&\n            message.code) ||\n            code;\n    data.tarCode = code;\n    if (!self.strict && data.recoverable !== false) {\n        if (message instanceof Error) {\n            data = Object.assign(message, data);\n            message = message.message;\n        }\n        self.emit('warn', code, message, data);\n    }\n    else if (message instanceof Error) {\n        self.emit('error', Object.assign(message, data));\n    }\n    else {\n        self.emit('error', Object.assign(new Error(`${code}: ${message}`), data));\n    }\n};\n//# sourceMappingURL=warn-method.js.map","// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a list of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\nimport { EventEmitter as EE } from 'events';\nimport { BrotliDecompress, Unzip, ZstdDecompress } from 'minizlib';\nimport { Header } from './header.js';\nimport { Pax } from './pax.js';\nimport { ReadEntry } from './read-entry.js';\nimport { warnMethod, } from './warn-method.js';\nconst maxMetaEntrySize = 1024 * 1024;\nconst gzipHeader = Buffer.from([0x1f, 0x8b]);\nconst zstdHeader = Buffer.from([0x28, 0xb5, 0x2f, 0xfd]);\nconst ZIP_HEADER_LEN = Math.max(gzipHeader.length, zstdHeader.length);\nconst STATE = Symbol('state');\nconst WRITEENTRY = Symbol('writeEntry');\nconst READENTRY = Symbol('readEntry');\nconst NEXTENTRY = Symbol('nextEntry');\nconst PROCESSENTRY = Symbol('processEntry');\nconst EX = Symbol('extendedHeader');\nconst GEX = Symbol('globalExtendedHeader');\nconst META = Symbol('meta');\nconst EMITMETA = Symbol('emitMeta');\nconst BUFFER = Symbol('buffer');\nconst QUEUE = Symbol('queue');\nconst ENDED = Symbol('ended');\nconst EMITTEDEND = Symbol('emittedEnd');\nconst EMIT = Symbol('emit');\nconst UNZIP = Symbol('unzip');\nconst CONSUMECHUNK = Symbol('consumeChunk');\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nconst CONSUMEBODY = Symbol('consumeBody');\nconst CONSUMEMETA = Symbol('consumeMeta');\nconst CONSUMEHEADER = Symbol('consumeHeader');\nconst CONSUMING = Symbol('consuming');\nconst BUFFERCONCAT = Symbol('bufferConcat');\nconst MAYBEEND = Symbol('maybeEnd');\nconst WRITING = Symbol('writing');\nconst ABORTED = Symbol('aborted');\nconst DONE = Symbol('onDone');\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry');\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock');\nconst SAW_EOF = Symbol('sawEOF');\nconst CLOSESTREAM = Symbol('closeStream');\nconst noop = () => true;\nexport class Parser extends EE {\n    file;\n    strict;\n    maxMetaEntrySize;\n    filter;\n    brotli;\n    zstd;\n    writable = true;\n    readable = false;\n    [QUEUE] = [];\n    [BUFFER];\n    [READENTRY];\n    [WRITEENTRY];\n    [STATE] = 'begin';\n    [META] = '';\n    [EX];\n    [GEX];\n    [ENDED] = false;\n    [UNZIP];\n    [ABORTED] = false;\n    [SAW_VALID_ENTRY];\n    [SAW_NULL_BLOCK] = false;\n    [SAW_EOF] = false;\n    [WRITING] = false;\n    [CONSUMING] = false;\n    [EMITTEDEND] = false;\n    constructor(opt = {}) {\n        super();\n        this.file = opt.file || '';\n        // these BADARCHIVE errors can't be detected early. listen on DONE.\n        this.on(DONE, () => {\n            if (this[STATE] === 'begin' ||\n                this[SAW_VALID_ENTRY] === false) {\n                // either less than 1 block of data, or all entries were invalid.\n                // Either way, probably not even a tarball.\n                this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');\n            }\n        });\n        if (opt.ondone) {\n            this.on(DONE, opt.ondone);\n        }\n        else {\n            this.on(DONE, () => {\n                this.emit('prefinish');\n                this.emit('finish');\n                this.emit('end');\n            });\n        }\n        this.strict = !!opt.strict;\n        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n        this.filter = typeof opt.filter === 'function' ? opt.filter : noop;\n        // Unlike gzip, brotli doesn't have any magic bytes to identify it\n        // Users need to explicitly tell us they're extracting a brotli file\n        // Or we infer from the file extension\n        const isTBR = opt.file &&\n            (opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr'));\n        // if it's a tbr file it MIGHT be brotli, but we don't know until\n        // we look at it and verify it's not a valid tar file.\n        this.brotli =\n            !(opt.gzip || opt.zstd) && opt.brotli !== undefined ? opt.brotli\n                : isTBR ? undefined\n                    : false;\n        // zstd has magic bytes to identify it, but we also support explicit options\n        // and file extension detection\n        const isTZST = opt.file &&\n            (opt.file.endsWith('.tar.zst') || opt.file.endsWith('.tzst'));\n        this.zstd =\n            !(opt.gzip || opt.brotli) && opt.zstd !== undefined ? opt.zstd\n                : isTZST ? true\n                    : undefined;\n        // have to set this so that streams are ok piping into it\n        this.on('end', () => this[CLOSESTREAM]());\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        if (typeof opt.onReadEntry === 'function') {\n            this.on('entry', opt.onReadEntry);\n        }\n    }\n    warn(code, message, data = {}) {\n        warnMethod(this, code, message, data);\n    }\n    [CONSUMEHEADER](chunk, position) {\n        if (this[SAW_VALID_ENTRY] === undefined) {\n            this[SAW_VALID_ENTRY] = false;\n        }\n        let header;\n        try {\n            header = new Header(chunk, position, this[EX], this[GEX]);\n        }\n        catch (er) {\n            return this.warn('TAR_ENTRY_INVALID', er);\n        }\n        if (header.nullBlock) {\n            if (this[SAW_NULL_BLOCK]) {\n                this[SAW_EOF] = true;\n                // ending an archive with no entries.  pointless, but legal.\n                if (this[STATE] === 'begin') {\n                    this[STATE] = 'header';\n                }\n                this[EMIT]('eof');\n            }\n            else {\n                this[SAW_NULL_BLOCK] = true;\n                this[EMIT]('nullBlock');\n            }\n        }\n        else {\n            this[SAW_NULL_BLOCK] = false;\n            if (!header.cksumValid) {\n                this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header });\n            }\n            else if (!header.path) {\n                this.warn('TAR_ENTRY_INVALID', 'path is required', { header });\n            }\n            else {\n                const type = header.type;\n                if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n                        header,\n                    });\n                }\n                else if (!/^(Symbolic)?Link$/.test(type) &&\n                    !/^(Global)?ExtendedHeader$/.test(type) &&\n                    header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n                        header,\n                    });\n                }\n                else {\n                    const entry = (this[WRITEENTRY] = new ReadEntry(header, this[EX], this[GEX]));\n                    // we do this for meta & ignored entries as well, because they\n                    // are still valid tar, or else we wouldn't know to ignore them\n                    if (!this[SAW_VALID_ENTRY]) {\n                        if (entry.remain) {\n                            // this might be the one!\n                            const onend = () => {\n                                if (!entry.invalid) {\n                                    this[SAW_VALID_ENTRY] = true;\n                                }\n                            };\n                            entry.on('end', onend);\n                        }\n                        else {\n                            this[SAW_VALID_ENTRY] = true;\n                        }\n                    }\n                    if (entry.meta) {\n                        if (entry.size > this.maxMetaEntrySize) {\n                            entry.ignore = true;\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = 'ignore';\n                            entry.resume();\n                        }\n                        else if (entry.size > 0) {\n                            this[META] = '';\n                            entry.on('data', c => (this[META] += c));\n                            this[STATE] = 'meta';\n                        }\n                    }\n                    else {\n                        this[EX] = undefined;\n                        entry.ignore =\n                            entry.ignore || !this.filter(entry.path, entry);\n                        if (entry.ignore) {\n                            // probably valid, just not something we care about\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = entry.remain ? 'ignore' : 'header';\n                            entry.resume();\n                        }\n                        else {\n                            if (entry.remain) {\n                                this[STATE] = 'body';\n                            }\n                            else {\n                                this[STATE] = 'header';\n                                entry.end();\n                            }\n                            if (!this[READENTRY]) {\n                                this[QUEUE].push(entry);\n                                this[NEXTENTRY]();\n                            }\n                            else {\n                                this[QUEUE].push(entry);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    [CLOSESTREAM]() {\n        queueMicrotask(() => this.emit('close'));\n    }\n    [PROCESSENTRY](entry) {\n        let go = true;\n        if (!entry) {\n            this[READENTRY] = undefined;\n            go = false;\n        }\n        else if (Array.isArray(entry)) {\n            const [ev, ...args] = entry;\n            this.emit(ev, ...args);\n        }\n        else {\n            this[READENTRY] = entry;\n            this.emit('entry', entry);\n            if (!entry.emittedEnd) {\n                entry.on('end', () => this[NEXTENTRY]());\n                go = false;\n            }\n        }\n        return go;\n    }\n    [NEXTENTRY]() {\n        do { } while (this[PROCESSENTRY](this[QUEUE].shift()));\n        if (!this[QUEUE].length) {\n            // At this point, there's nothing in the queue, but we may have an\n            // entry which is being consumed (readEntry).\n            // If we don't, then we definitely can handle more data.\n            // If we do, and either it's flowing, or it has never had any data\n            // written to it, then it needs more.\n            // The only other possibility is that it has returned false from a\n            // write() call, so we wait for the next drain to continue.\n            const re = this[READENTRY];\n            const drainNow = !re || re.flowing || re.size === re.remain;\n            if (drainNow) {\n                if (!this[WRITING]) {\n                    this.emit('drain');\n                }\n            }\n            else {\n                re.once('drain', () => this.emit('drain'));\n            }\n        }\n    }\n    [CONSUMEBODY](chunk, position) {\n        // write up to but no  more than writeEntry.blockRemain\n        const entry = this[WRITEENTRY];\n        /* c8 ignore start */\n        if (!entry) {\n            throw new Error('attempt to consume body without entry??');\n        }\n        const br = entry.blockRemain ?? 0;\n        /* c8 ignore stop */\n        const c = br >= chunk.length && position === 0 ?\n            chunk\n            : chunk.subarray(position, position + br);\n        entry.write(c);\n        if (!entry.blockRemain) {\n            this[STATE] = 'header';\n            this[WRITEENTRY] = undefined;\n            entry.end();\n        }\n        return c.length;\n    }\n    [CONSUMEMETA](chunk, position) {\n        const entry = this[WRITEENTRY];\n        const ret = this[CONSUMEBODY](chunk, position);\n        // if we finished, then the entry is reset\n        if (!this[WRITEENTRY] && entry) {\n            this[EMITMETA](entry);\n        }\n        return ret;\n    }\n    [EMIT](ev, data, extra) {\n        if (!this[QUEUE].length && !this[READENTRY]) {\n            this.emit(ev, data, extra);\n        }\n        else {\n            this[QUEUE].push([ev, data, extra]);\n        }\n    }\n    [EMITMETA](entry) {\n        this[EMIT]('meta', this[META]);\n        switch (entry.type) {\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this[EX] = Pax.parse(this[META], this[EX], false);\n                break;\n            case 'GlobalExtendedHeader':\n                this[GEX] = Pax.parse(this[META], this[GEX], true);\n                break;\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath': {\n                const ex = this[EX] ?? Object.create(null);\n                this[EX] = ex;\n                ex.path = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            case 'NextFileHasLongLinkpath': {\n                const ex = this[EX] || Object.create(null);\n                this[EX] = ex;\n                ex.linkpath = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            /* c8 ignore start */\n            default:\n                throw new Error('unknown meta: ' + entry.type);\n            /* c8 ignore stop */\n        }\n    }\n    abort(error) {\n        this[ABORTED] = true;\n        this.emit('abort', error);\n        // always throws, even in non-strict mode\n        this.warn('TAR_ABORT', error, { recoverable: false });\n    }\n    write(chunk, encoding, cb) {\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, \n            /* c8 ignore next */\n            typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        if (this[ABORTED]) {\n            /* c8 ignore next */\n            cb?.();\n            return false;\n        }\n        // first write, might be gzipped, zstd, or brotli compressed\n        const needSniff = this[UNZIP] === undefined ||\n            (this.brotli === undefined && this[UNZIP] === false);\n        if (needSniff && chunk) {\n            if (this[BUFFER]) {\n                chunk = Buffer.concat([this[BUFFER], chunk]);\n                this[BUFFER] = undefined;\n            }\n            if (chunk.length < ZIP_HEADER_LEN) {\n                this[BUFFER] = chunk;\n                /* c8 ignore next */\n                cb?.();\n                return true;\n            }\n            // look for gzip header\n            for (let i = 0; this[UNZIP] === undefined && i < gzipHeader.length; i++) {\n                if (chunk[i] !== gzipHeader[i]) {\n                    this[UNZIP] = false;\n                }\n            }\n            // look for zstd header if gzip header not found\n            let isZstd = false;\n            if (this[UNZIP] === false && this.zstd !== false) {\n                isZstd = true;\n                for (let i = 0; i < zstdHeader.length; i++) {\n                    if (chunk[i] !== zstdHeader[i]) {\n                        isZstd = false;\n                        break;\n                    }\n                }\n            }\n            const maybeBrotli = this.brotli === undefined && !isZstd;\n            if (this[UNZIP] === false && maybeBrotli) {\n                // read the first header to see if it's a valid tar file. If so,\n                // we can safely assume that it's not actually brotli, despite the\n                // .tbr or .tar.br file extension.\n                // if we ended before getting a full chunk, yes, def brotli\n                if (chunk.length < 512) {\n                    if (this[ENDED]) {\n                        this.brotli = true;\n                    }\n                    else {\n                        this[BUFFER] = chunk;\n                        /* c8 ignore next */\n                        cb?.();\n                        return true;\n                    }\n                }\n                else {\n                    // if it's tar, it's pretty reliably not brotli, chances of\n                    // that happening are astronomical.\n                    try {\n                        new Header(chunk.subarray(0, 512));\n                        this.brotli = false;\n                    }\n                    catch (_) {\n                        this.brotli = true;\n                    }\n                }\n            }\n            if (this[UNZIP] === undefined ||\n                (this[UNZIP] === false && (this.brotli || isZstd))) {\n                const ended = this[ENDED];\n                this[ENDED] = false;\n                this[UNZIP] =\n                    this[UNZIP] === undefined ?\n                        new Unzip({})\n                        : isZstd ?\n                            new ZstdDecompress({})\n                            : new BrotliDecompress({});\n                this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));\n                this[UNZIP].on('error', er => this.abort(er));\n                this[UNZIP].on('end', () => {\n                    this[ENDED] = true;\n                    this[CONSUMECHUNK]();\n                });\n                this[WRITING] = true;\n                const ret = !!this[UNZIP][ended ? 'end' : 'write'](chunk);\n                this[WRITING] = false;\n                cb?.();\n                return ret;\n            }\n        }\n        this[WRITING] = true;\n        if (this[UNZIP]) {\n            this[UNZIP].write(chunk);\n        }\n        else {\n            this[CONSUMECHUNK](chunk);\n        }\n        this[WRITING] = false;\n        // return false if there's a queue, or if the current entry isn't flowing\n        const ret = this[QUEUE].length ? false\n            : this[READENTRY] ? this[READENTRY].flowing\n                : true;\n        // if we have no queue, then that means a clogged READENTRY\n        if (!ret && !this[QUEUE].length) {\n            this[READENTRY]?.once('drain', () => this.emit('drain'));\n        }\n        /* c8 ignore next */\n        cb?.();\n        return ret;\n    }\n    [BUFFERCONCAT](c) {\n        if (c && !this[ABORTED]) {\n            this[BUFFER] =\n                this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n        }\n    }\n    [MAYBEEND]() {\n        if (this[ENDED] &&\n            !this[EMITTEDEND] &&\n            !this[ABORTED] &&\n            !this[CONSUMING]) {\n            this[EMITTEDEND] = true;\n            const entry = this[WRITEENTRY];\n            if (entry && entry.blockRemain) {\n                // truncated, likely a damaged file\n                const have = this[BUFFER] ? this[BUFFER].length : 0;\n                this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });\n                if (this[BUFFER]) {\n                    entry.write(this[BUFFER]);\n                }\n                entry.end();\n            }\n            this[EMIT](DONE);\n        }\n    }\n    [CONSUMECHUNK](chunk) {\n        if (this[CONSUMING] && chunk) {\n            this[BUFFERCONCAT](chunk);\n        }\n        else if (!chunk && !this[BUFFER]) {\n            this[MAYBEEND]();\n        }\n        else if (chunk) {\n            this[CONSUMING] = true;\n            if (this[BUFFER]) {\n                this[BUFFERCONCAT](chunk);\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            else {\n                this[CONSUMECHUNKSUB](chunk);\n            }\n            while (this[BUFFER] &&\n                this[BUFFER]?.length >= 512 &&\n                !this[ABORTED] &&\n                !this[SAW_EOF]) {\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            this[CONSUMING] = false;\n        }\n        if (!this[BUFFER] || this[ENDED]) {\n            this[MAYBEEND]();\n        }\n    }\n    [CONSUMECHUNKSUB](chunk) {\n        // we know that we are in CONSUMING mode, so anything written goes into\n        // the buffer.  Advance the position and put any remainder in the buffer.\n        let position = 0;\n        const length = chunk.length;\n        while (position + 512 <= length &&\n            !this[ABORTED] &&\n            !this[SAW_EOF]) {\n            switch (this[STATE]) {\n                case 'begin':\n                case 'header':\n                    this[CONSUMEHEADER](chunk, position);\n                    position += 512;\n                    break;\n                case 'ignore':\n                case 'body':\n                    position += this[CONSUMEBODY](chunk, position);\n                    break;\n                case 'meta':\n                    position += this[CONSUMEMETA](chunk, position);\n                    break;\n                /* c8 ignore start */\n                default:\n                    throw new Error('invalid state: ' + this[STATE]);\n                /* c8 ignore stop */\n            }\n        }\n        if (position < length) {\n            if (this[BUFFER]) {\n                this[BUFFER] = Buffer.concat([\n                    chunk.subarray(position),\n                    this[BUFFER],\n                ]);\n            }\n            else {\n                this[BUFFER] = chunk.subarray(position);\n            }\n        }\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (cb)\n            this.once('finish', cb);\n        if (!this[ABORTED]) {\n            if (this[UNZIP]) {\n                /* c8 ignore start */\n                if (chunk)\n                    this[UNZIP].write(chunk);\n                /* c8 ignore stop */\n                this[UNZIP].end();\n            }\n            else {\n                this[ENDED] = true;\n                if (this.brotli === undefined || this.zstd === undefined)\n                    chunk = chunk || Buffer.alloc(0);\n                if (chunk)\n                    this.write(chunk);\n                this[MAYBEEND]();\n            }\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=parse.js.map","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nexport const stripTrailingSlashes = (str) => {\n    let i = str.length - 1;\n    let slashesStart = -1;\n    while (i > -1 && str.charAt(i) === '/') {\n        slashesStart = i;\n        i--;\n    }\n    return slashesStart === -1 ? str : str.slice(0, slashesStart);\n};\n//# sourceMappingURL=strip-trailing-slashes.js.map","// tar -t\nimport * as fsm from '@isaacs/fs-minipass';\nimport fs from 'node:fs';\nimport { dirname, parse } from 'path';\nimport { makeCommand } from './make-command.js';\nimport { Parser } from './parse.js';\nimport { stripTrailingSlashes } from './strip-trailing-slashes.js';\nconst onReadEntryFunction = (opt) => {\n    const onReadEntry = opt.onReadEntry;\n    opt.onReadEntry =\n        onReadEntry ?\n            e => {\n                onReadEntry(e);\n                e.resume();\n            }\n            : e => e.resume();\n};\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nexport const filesFilter = (opt, files) => {\n    const map = new Map(files.map(f => [stripTrailingSlashes(f), true]));\n    const filter = opt.filter;\n    const mapHas = (file, r = '') => {\n        const root = r || parse(file).root || '.';\n        let ret;\n        if (file === root)\n            ret = false;\n        else {\n            const m = map.get(file);\n            if (m !== undefined) {\n                ret = m;\n            }\n            else {\n                ret = mapHas(dirname(file), root);\n            }\n        }\n        map.set(file, ret);\n        return ret;\n    };\n    opt.filter =\n        filter ?\n            (file, entry) => filter(file, entry) && mapHas(stripTrailingSlashes(file))\n            : file => mapHas(stripTrailingSlashes(file));\n};\nconst listFileSync = (opt) => {\n    const p = new Parser(opt);\n    const file = opt.file;\n    let fd;\n    try {\n        fd = fs.openSync(file, 'r');\n        const stat = fs.fstatSync(fd);\n        const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n        if (stat.size < readSize) {\n            const buf = Buffer.allocUnsafe(stat.size);\n            fs.readSync(fd, buf, 0, stat.size, 0);\n            p.end(buf);\n        }\n        else {\n            let pos = 0;\n            const buf = Buffer.allocUnsafe(readSize);\n            while (pos < stat.size) {\n                const bytesRead = fs.readSync(fd, buf, 0, readSize, pos);\n                pos += bytesRead;\n                p.write(buf.subarray(0, bytesRead));\n            }\n            p.end();\n        }\n    }\n    finally {\n        if (typeof fd === 'number') {\n            try {\n                fs.closeSync(fd);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n    }\n};\nconst listFile = (opt, _files) => {\n    const parse = new Parser(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        parse.on('error', reject);\n        parse.on('end', resolve);\n        fs.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new fsm.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(parse);\n            }\n        });\n    });\n    return p;\n};\nexport const list = makeCommand(listFileSync, listFile, opt => new Parser(opt), opt => new Parser(opt), (opt, files) => {\n    if (files?.length)\n        filesFilter(opt, files);\n    if (!opt.noResume)\n        onReadEntryFunction(opt);\n});\n//# sourceMappingURL=list.js.map","export const modeFix = (mode, isDir, portable) => {\n    mode &= 0o7777;\n    // in portable mode, use the minimum reasonable umask\n    // if this system creates files with 0o664 by default\n    // (as some linux distros do), then we'll write the\n    // archive with 0o644 instead.  Also, don't ever create\n    // a file that is not readable/writable by the owner.\n    if (portable) {\n        mode = (mode | 0o600) & ~0o22;\n    }\n    // if dirs are readable, then they should be listable\n    if (isDir) {\n        if (mode & 0o400) {\n            mode |= 0o100;\n        }\n        if (mode & 0o40) {\n            mode |= 0o10;\n        }\n        if (mode & 0o4) {\n            mode |= 0o1;\n        }\n    }\n    return mode;\n};\n//# sourceMappingURL=mode-fix.js.map","// unix absolute paths are also absolute on win32, so we use this for both\nimport { win32 } from 'node:path';\nconst { isAbsolute, parse } = win32;\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nexport const stripAbsolutePath = (path) => {\n    let r = '';\n    let parsed = parse(path);\n    while (isAbsolute(path) || parsed.root) {\n        // windows will think that //x/y/z has a \"root\" of //x/y/\n        // but strip the //?/C:/ off of //?/C:/path\n        const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ?\n            '/'\n            : parsed.root;\n        path = path.slice(root.length);\n        r += root;\n        parsed = parse(path);\n    }\n    return [r, path];\n};\n//# sourceMappingURL=strip-absolute-path.js.map","// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\nconst raw = ['|', '<', '>', '?', ':'];\nconst win = raw.map(char => String.fromCharCode(0xf000 + char.charCodeAt(0)));\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]));\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]));\nexport const encode = (s) => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s);\nexport const decode = (s) => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s);\n//# sourceMappingURL=winchars.js.map","import fs from 'fs';\nimport { Minipass } from 'minipass';\nimport path from 'path';\nimport { Header } from './header.js';\nimport { modeFix } from './mode-fix.js';\nimport { normalizeWindowsPath } from './normalize-windows-path.js';\nimport { dealias, } from './options.js';\nimport { Pax } from './pax.js';\nimport { stripAbsolutePath } from './strip-absolute-path.js';\nimport { stripTrailingSlashes } from './strip-trailing-slashes.js';\nimport { warnMethod, } from './warn-method.js';\nimport * as winchars from './winchars.js';\nconst prefixPath = (path, prefix) => {\n    if (!prefix) {\n        return normalizeWindowsPath(path);\n    }\n    path = normalizeWindowsPath(path).replace(/^\\.(\\/|$)/, '');\n    return stripTrailingSlashes(prefix) + '/' + path;\n};\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\nconst AWAITDRAIN = Symbol('awaitDrain');\nconst ONDRAIN = Symbol('ondrain');\nconst PREFIX = Symbol('prefix');\nexport class WriteEntry extends Minipass {\n    path;\n    portable;\n    myuid = (process.getuid && process.getuid()) || 0;\n    // until node has builtin pwnam functions, this'll have to do\n    myuser = process.env.USER || '';\n    maxReadSize;\n    linkCache;\n    statCache;\n    preservePaths;\n    cwd;\n    strict;\n    mtime;\n    noPax;\n    noMtime;\n    prefix;\n    fd;\n    blockLen = 0;\n    blockRemain = 0;\n    buf;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    offset = 0;\n    win32;\n    absolute;\n    header;\n    type;\n    linkpath;\n    stat;\n    onWriteEntry;\n    #hadError = false;\n    constructor(p, opt_ = {}) {\n        const opt = dealias(opt_);\n        super();\n        this.path = normalizeWindowsPath(p);\n        // suppress atime, ctime, uid, gid, uname, gname\n        this.portable = !!opt.portable;\n        this.maxReadSize = opt.maxReadSize || maxReadSize;\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.preservePaths = !!opt.preservePaths;\n        this.cwd = normalizeWindowsPath(opt.cwd || process.cwd());\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.mtime = opt.mtime;\n        this.prefix =\n            opt.prefix ? normalizeWindowsPath(opt.prefix) : undefined;\n        this.onWriteEntry = opt.onWriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = stripAbsolutePath(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.win32 = !!opt.win32 || process.platform === 'win32';\n        if (this.win32) {\n            // force the \\ to / normalization, since we might not *actually*\n            // be on windows, but want \\ to be considered a path separator.\n            this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n            p = p.replace(/\\\\/g, '/');\n        }\n        this.absolute = normalizeWindowsPath(opt.absolute || path.resolve(this.cwd, p));\n        if (this.path === '') {\n            this.path = './';\n        }\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        const cs = this.statCache.get(this.absolute);\n        if (cs) {\n            this[ONLSTAT](cs);\n        }\n        else {\n            this[LSTAT]();\n        }\n    }\n    warn(code, message, data = {}) {\n        return warnMethod(this, code, message, data);\n    }\n    emit(ev, ...data) {\n        if (ev === 'error') {\n            this.#hadError = true;\n        }\n        return super.emit(ev, ...data);\n    }\n    [LSTAT]() {\n        fs.lstat(this.absolute, (er, stat) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONLSTAT](stat);\n        });\n    }\n    [ONLSTAT](stat) {\n        this.statCache.set(this.absolute, stat);\n        this.stat = stat;\n        if (!stat.isFile()) {\n            stat.size = 0;\n        }\n        this.type = getType(stat);\n        this.emit('stat', stat);\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        switch (this.type) {\n            case 'File':\n                return this[FILE]();\n            case 'Directory':\n                return this[DIRECTORY]();\n            case 'SymbolicLink':\n                return this[SYMLINK]();\n            // unsupported types are ignored.\n            default:\n                return this.end();\n        }\n    }\n    [MODE](mode) {\n        return modeFix(mode, this.type === 'Directory', this.portable);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [HEADER]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot write header before stat');\n        }\n        /* c8 ignore stop */\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.onWriteEntry?.(this);\n        this.header = new Header({\n            path: this[PREFIX](this.path),\n            // only apply the prefix to hard links.\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this[MODE](this.stat.mode),\n            uid: this.portable ? undefined : this.stat.uid,\n            gid: this.portable ? undefined : this.stat.gid,\n            size: this.stat.size,\n            mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,\n            /* c8 ignore next */\n            type: this.type === 'Unsupported' ? undefined : this.type,\n            uname: this.portable ? undefined\n                : this.stat.uid === this.myuid ? this.myuser\n                    : '',\n            atime: this.portable ? undefined : this.stat.atime,\n            ctime: this.portable ? undefined : this.stat.ctime,\n        });\n        if (this.header.encode() && !this.noPax) {\n            super.write(new Pax({\n                atime: this.portable ? undefined : this.header.atime,\n                ctime: this.portable ? undefined : this.header.ctime,\n                gid: this.portable ? undefined : this.header.gid,\n                mtime: this.noMtime ? undefined : (this.mtime || this.header.mtime),\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.header.size,\n                uid: this.portable ? undefined : this.header.uid,\n                uname: this.portable ? undefined : this.header.uname,\n                dev: this.portable ? undefined : this.stat.dev,\n                ino: this.portable ? undefined : this.stat.ino,\n                nlink: this.portable ? undefined : this.stat.nlink,\n            }).encode());\n        }\n        const block = this.header?.block;\n        /* c8 ignore start */\n        if (!block) {\n            throw new Error('failed to encode header');\n        }\n        /* c8 ignore stop */\n        super.write(block);\n    }\n    [DIRECTORY]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create directory entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.path.slice(-1) !== '/') {\n            this.path += '/';\n        }\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [SYMLINK]() {\n        fs.readlink(this.absolute, (er, linkpath) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADLINK](linkpath);\n        });\n    }\n    [ONREADLINK](linkpath) {\n        this.linkpath = normalizeWindowsPath(linkpath);\n        this[HEADER]();\n        this.end();\n    }\n    [HARDLINK](linkpath) {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create link entry without stat');\n        }\n        /* c8 ignore stop */\n        this.type = 'Link';\n        this.linkpath = normalizeWindowsPath(path.relative(this.cwd, linkpath));\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [FILE]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create file entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.stat.nlink > 1) {\n            const linkKey = `${this.stat.dev}:${this.stat.ino}`;\n            const linkpath = this.linkCache.get(linkKey);\n            if (linkpath?.indexOf(this.cwd) === 0) {\n                return this[HARDLINK](linkpath);\n            }\n            this.linkCache.set(linkKey, this.absolute);\n        }\n        this[HEADER]();\n        if (this.stat.size === 0) {\n            return this.end();\n        }\n        this[OPENFILE]();\n    }\n    [OPENFILE]() {\n        fs.open(this.absolute, 'r', (er, fd) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONOPENFILE](fd);\n        });\n    }\n    [ONOPENFILE](fd) {\n        this.fd = fd;\n        if (this.#hadError) {\n            return this[CLOSE]();\n        }\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('should stat before calling onopenfile');\n        }\n        /* c8 ignore start */\n        this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n        this.blockRemain = this.blockLen;\n        const bufLen = Math.min(this.blockLen, this.maxReadSize);\n        this.buf = Buffer.allocUnsafe(bufLen);\n        this.offset = 0;\n        this.pos = 0;\n        this.remain = this.stat.size;\n        this.length = this.buf.length;\n        this[READ]();\n    }\n    [READ]() {\n        const { fd, buf, offset, length, pos } = this;\n        if (fd === undefined || buf === undefined) {\n            throw new Error('cannot read file without first opening');\n        }\n        fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n            if (er) {\n                // ignoring the error from close(2) is a bad practice, but at\n                // this point we already have an error, don't need another one\n                return this[CLOSE](() => this.emit('error', er));\n            }\n            this[ONREAD](bytesRead);\n        });\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs.close(this.fd, cb);\n    }\n    [ONREAD](bytesRead) {\n        if (bytesRead <= 0 && this.remain > 0) {\n            const er = Object.assign(new Error('encountered unexpected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        if (bytesRead > this.remain) {\n            const er = Object.assign(new Error('did not encounter expected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('should have created buffer prior to reading');\n        }\n        /* c8 ignore stop */\n        // null out the rest of the buffer, if we could fit the block padding\n        // at the end of this loop, we've incremented bytesRead and this.remain\n        // to be incremented up to the blockRemain level, as if we had expected\n        // to get a null-padded file, and read it until the end.  then we will\n        // decrement both remain and blockRemain by bytesRead, and know that we\n        // reached the expected EOF, without any null buffer to append.\n        if (bytesRead === this.remain) {\n            for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n                this.buf[i + this.offset] = 0;\n                bytesRead++;\n                this.remain++;\n            }\n        }\n        const chunk = this.offset === 0 && bytesRead === this.buf.length ?\n            this.buf\n            : this.buf.subarray(this.offset, this.offset + bytesRead);\n        const flushed = this.write(chunk);\n        if (!flushed) {\n            this[AWAITDRAIN](() => this[ONDRAIN]());\n        }\n        else {\n            this[ONDRAIN]();\n        }\n    }\n    [AWAITDRAIN](cb) {\n        this.once('drain', cb);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        if (this.blockRemain < chunk.length) {\n            const er = Object.assign(new Error('writing more data than expected'), {\n                path: this.absolute,\n            });\n            return this.emit('error', er);\n        }\n        this.remain -= chunk.length;\n        this.blockRemain -= chunk.length;\n        this.pos += chunk.length;\n        this.offset += chunk.length;\n        return super.write(chunk, null, cb);\n    }\n    [ONDRAIN]() {\n        if (!this.remain) {\n            if (this.blockRemain) {\n                super.write(Buffer.alloc(this.blockRemain));\n            }\n            return this[CLOSE](er => er ? this.emit('error', er) : this.end());\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('buffer lost somehow in ONDRAIN');\n        }\n        /* c8 ignore stop */\n        if (this.offset >= this.length) {\n            // if we only have a smaller bit left to read, alloc a smaller buffer\n            // otherwise, keep it the same length it was before.\n            this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n            this.offset = 0;\n        }\n        this.length = this.buf.length - this.offset;\n        this[READ]();\n    }\n}\nexport class WriteEntrySync extends WriteEntry {\n    sync = true;\n    [LSTAT]() {\n        this[ONLSTAT](fs.lstatSync(this.absolute));\n    }\n    [SYMLINK]() {\n        this[ONREADLINK](fs.readlinkSync(this.absolute));\n    }\n    [OPENFILE]() {\n        this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n    }\n    [READ]() {\n        let threw = true;\n        try {\n            const { fd, buf, offset, length, pos } = this;\n            /* c8 ignore start */\n            if (fd === undefined || buf === undefined) {\n                throw new Error('fd and buf must be set in READ method');\n            }\n            /* c8 ignore stop */\n            const bytesRead = fs.readSync(fd, buf, offset, length, pos);\n            this[ONREAD](bytesRead);\n            threw = false;\n        }\n        finally {\n            // ignoring the error from close(2) is a bad practice, but at\n            // this point we already have an error, don't need another one\n            if (threw) {\n                try {\n                    this[CLOSE](() => { });\n                }\n                catch (er) { }\n            }\n        }\n    }\n    [AWAITDRAIN](cb) {\n        cb();\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs.closeSync(this.fd);\n        cb();\n    }\n}\nexport class WriteEntryTar extends Minipass {\n    blockLen = 0;\n    blockRemain = 0;\n    buf = 0;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    preservePaths;\n    portable;\n    strict;\n    noPax;\n    noMtime;\n    readEntry;\n    type;\n    prefix;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    header;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    size;\n    onWriteEntry;\n    warn(code, message, data = {}) {\n        return warnMethod(this, code, message, data);\n    }\n    constructor(readEntry, opt_ = {}) {\n        const opt = dealias(opt_);\n        super();\n        this.preservePaths = !!opt.preservePaths;\n        this.portable = !!opt.portable;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.onWriteEntry = opt.onWriteEntry;\n        this.readEntry = readEntry;\n        const { type } = readEntry;\n        /* c8 ignore start */\n        if (type === 'Unsupported') {\n            throw new Error('writing entry that should be ignored');\n        }\n        /* c8 ignore stop */\n        this.type = type;\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.prefix = opt.prefix;\n        this.path = normalizeWindowsPath(readEntry.path);\n        this.mode =\n            readEntry.mode !== undefined ?\n                this[MODE](readEntry.mode)\n                : undefined;\n        this.uid = this.portable ? undefined : readEntry.uid;\n        this.gid = this.portable ? undefined : readEntry.gid;\n        this.uname = this.portable ? undefined : readEntry.uname;\n        this.gname = this.portable ? undefined : readEntry.gname;\n        this.size = readEntry.size;\n        this.mtime =\n            this.noMtime ? undefined : opt.mtime || readEntry.mtime;\n        this.atime = this.portable ? undefined : readEntry.atime;\n        this.ctime = this.portable ? undefined : readEntry.ctime;\n        this.linkpath =\n            readEntry.linkpath !== undefined ?\n                normalizeWindowsPath(readEntry.linkpath)\n                : undefined;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = stripAbsolutePath(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.remain = readEntry.size;\n        this.blockRemain = readEntry.startBlockSize;\n        this.onWriteEntry?.(this);\n        this.header = new Header({\n            path: this[PREFIX](this.path),\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this.mode,\n            uid: this.portable ? undefined : this.uid,\n            gid: this.portable ? undefined : this.gid,\n            size: this.size,\n            mtime: this.noMtime ? undefined : this.mtime,\n            type: this.type,\n            uname: this.portable ? undefined : this.uname,\n            atime: this.portable ? undefined : this.atime,\n            ctime: this.portable ? undefined : this.ctime,\n        });\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        if (this.header.encode() && !this.noPax) {\n            super.write(new Pax({\n                atime: this.portable ? undefined : this.atime,\n                ctime: this.portable ? undefined : this.ctime,\n                gid: this.portable ? undefined : this.gid,\n                mtime: this.noMtime ? undefined : this.mtime,\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.size,\n                uid: this.portable ? undefined : this.uid,\n                uname: this.portable ? undefined : this.uname,\n                dev: this.portable ? undefined : this.readEntry.dev,\n                ino: this.portable ? undefined : this.readEntry.ino,\n                nlink: this.portable ? undefined : this.readEntry.nlink,\n            }).encode());\n        }\n        const b = this.header?.block;\n        /* c8 ignore start */\n        if (!b)\n            throw new Error('failed to encode header');\n        /* c8 ignore stop */\n        super.write(b);\n        readEntry.pipe(this);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [MODE](mode) {\n        return modeFix(mode, this.type === 'Directory', this.portable);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        const writeLen = chunk.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        this.blockRemain -= writeLen;\n        return super.write(chunk, cb);\n    }\n    end(chunk, encoding, cb) {\n        if (this.blockRemain) {\n            super.write(Buffer.alloc(this.blockRemain));\n        }\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding ?? 'utf8');\n        }\n        if (cb)\n            this.once('finish', cb);\n        chunk ? super.end(chunk, cb) : super.end(cb);\n        /* c8 ignore stop */\n        return this;\n    }\n}\nconst getType = (stat) => stat.isFile() ? 'File'\n    : stat.isDirectory() ? 'Directory'\n        : stat.isSymbolicLink() ? 'SymbolicLink'\n            : 'Unsupported';\n//# sourceMappingURL=write-entry.js.map","export class Yallist {\n    tail;\n    head;\n    length = 0;\n    static create(list = []) {\n        return new Yallist(list);\n    }\n    constructor(list = []) {\n        for (const item of list) {\n            this.push(item);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let walker = this.head; walker; walker = walker.next) {\n            yield walker.value;\n        }\n    }\n    removeNode(node) {\n        if (node.list !== this) {\n            throw new Error('removing node which does not belong to this list');\n        }\n        const next = node.next;\n        const prev = node.prev;\n        if (next) {\n            next.prev = prev;\n        }\n        if (prev) {\n            prev.next = next;\n        }\n        if (node === this.head) {\n            this.head = next;\n        }\n        if (node === this.tail) {\n            this.tail = prev;\n        }\n        this.length--;\n        node.next = undefined;\n        node.prev = undefined;\n        node.list = undefined;\n        return next;\n    }\n    unshiftNode(node) {\n        if (node === this.head) {\n            return;\n        }\n        if (node.list) {\n            node.list.removeNode(node);\n        }\n        const head = this.head;\n        node.list = this;\n        node.next = head;\n        if (head) {\n            head.prev = node;\n        }\n        this.head = node;\n        if (!this.tail) {\n            this.tail = node;\n        }\n        this.length++;\n    }\n    pushNode(node) {\n        if (node === this.tail) {\n            return;\n        }\n        if (node.list) {\n            node.list.removeNode(node);\n        }\n        const tail = this.tail;\n        node.list = this;\n        node.prev = tail;\n        if (tail) {\n            tail.next = node;\n        }\n        this.tail = node;\n        if (!this.head) {\n            this.head = node;\n        }\n        this.length++;\n    }\n    push(...args) {\n        for (let i = 0, l = args.length; i < l; i++) {\n            push(this, args[i]);\n        }\n        return this.length;\n    }\n    unshift(...args) {\n        for (var i = 0, l = args.length; i < l; i++) {\n            unshift(this, args[i]);\n        }\n        return this.length;\n    }\n    pop() {\n        if (!this.tail) {\n            return undefined;\n        }\n        const res = this.tail.value;\n        const t = this.tail;\n        this.tail = this.tail.prev;\n        if (this.tail) {\n            this.tail.next = undefined;\n        }\n        else {\n            this.head = undefined;\n        }\n        t.list = undefined;\n        this.length--;\n        return res;\n    }\n    shift() {\n        if (!this.head) {\n            return undefined;\n        }\n        const res = this.head.value;\n        const h = this.head;\n        this.head = this.head.next;\n        if (this.head) {\n            this.head.prev = undefined;\n        }\n        else {\n            this.tail = undefined;\n        }\n        h.list = undefined;\n        this.length--;\n        return res;\n    }\n    forEach(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this.head, i = 0; !!walker; i++) {\n            fn.call(thisp, walker.value, i, this);\n            walker = walker.next;\n        }\n    }\n    forEachReverse(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this.tail, i = this.length - 1; !!walker; i--) {\n            fn.call(thisp, walker.value, i, this);\n            walker = walker.prev;\n        }\n    }\n    get(n) {\n        let i = 0;\n        let walker = this.head;\n        for (; !!walker && i < n; i++) {\n            walker = walker.next;\n        }\n        if (i === n && !!walker) {\n            return walker.value;\n        }\n    }\n    getReverse(n) {\n        let i = 0;\n        let walker = this.tail;\n        for (; !!walker && i < n; i++) {\n            // abort out of the list early if we hit a cycle\n            walker = walker.prev;\n        }\n        if (i === n && !!walker) {\n            return walker.value;\n        }\n    }\n    map(fn, thisp) {\n        thisp = thisp || this;\n        const res = new Yallist();\n        for (let walker = this.head; !!walker;) {\n            res.push(fn.call(thisp, walker.value, this));\n            walker = walker.next;\n        }\n        return res;\n    }\n    mapReverse(fn, thisp) {\n        thisp = thisp || this;\n        var res = new Yallist();\n        for (let walker = this.tail; !!walker;) {\n            res.push(fn.call(thisp, walker.value, this));\n            walker = walker.prev;\n        }\n        return res;\n    }\n    reduce(fn, initial) {\n        let acc;\n        let walker = this.head;\n        if (arguments.length > 1) {\n            acc = initial;\n        }\n        else if (this.head) {\n            walker = this.head.next;\n            acc = this.head.value;\n        }\n        else {\n            throw new TypeError('Reduce of empty list with no initial value');\n        }\n        for (var i = 0; !!walker; i++) {\n            acc = fn(acc, walker.value, i);\n            walker = walker.next;\n        }\n        return acc;\n    }\n    reduceReverse(fn, initial) {\n        let acc;\n        let walker = this.tail;\n        if (arguments.length > 1) {\n            acc = initial;\n        }\n        else if (this.tail) {\n            walker = this.tail.prev;\n            acc = this.tail.value;\n        }\n        else {\n            throw new TypeError('Reduce of empty list with no initial value');\n        }\n        for (let i = this.length - 1; !!walker; i--) {\n            acc = fn(acc, walker.value, i);\n            walker = walker.prev;\n        }\n        return acc;\n    }\n    toArray() {\n        const arr = new Array(this.length);\n        for (let i = 0, walker = this.head; !!walker; i++) {\n            arr[i] = walker.value;\n            walker = walker.next;\n        }\n        return arr;\n    }\n    toArrayReverse() {\n        const arr = new Array(this.length);\n        for (let i = 0, walker = this.tail; !!walker; i++) {\n            arr[i] = walker.value;\n            walker = walker.prev;\n        }\n        return arr;\n    }\n    slice(from = 0, to = this.length) {\n        if (to < 0) {\n            to += this.length;\n        }\n        if (from < 0) {\n            from += this.length;\n        }\n        const ret = new Yallist();\n        if (to < from || to < 0) {\n            return ret;\n        }\n        if (from < 0) {\n            from = 0;\n        }\n        if (to > this.length) {\n            to = this.length;\n        }\n        let walker = this.head;\n        let i = 0;\n        for (i = 0; !!walker && i < from; i++) {\n            walker = walker.next;\n        }\n        for (; !!walker && i < to; i++, walker = walker.next) {\n            ret.push(walker.value);\n        }\n        return ret;\n    }\n    sliceReverse(from = 0, to = this.length) {\n        if (to < 0) {\n            to += this.length;\n        }\n        if (from < 0) {\n            from += this.length;\n        }\n        const ret = new Yallist();\n        if (to < from || to < 0) {\n            return ret;\n        }\n        if (from < 0) {\n            from = 0;\n        }\n        if (to > this.length) {\n            to = this.length;\n        }\n        let i = this.length;\n        let walker = this.tail;\n        for (; !!walker && i > to; i--) {\n            walker = walker.prev;\n        }\n        for (; !!walker && i > from; i--, walker = walker.prev) {\n            ret.push(walker.value);\n        }\n        return ret;\n    }\n    splice(start, deleteCount = 0, ...nodes) {\n        if (start > this.length) {\n            start = this.length - 1;\n        }\n        if (start < 0) {\n            start = this.length + start;\n        }\n        let walker = this.head;\n        for (let i = 0; !!walker && i < start; i++) {\n            walker = walker.next;\n        }\n        const ret = [];\n        for (let i = 0; !!walker && i < deleteCount; i++) {\n            ret.push(walker.value);\n            walker = this.removeNode(walker);\n        }\n        if (!walker) {\n            walker = this.tail;\n        }\n        else if (walker !== this.tail) {\n            walker = walker.prev;\n        }\n        for (const v of nodes) {\n            walker = insertAfter(this, walker, v);\n        }\n        return ret;\n    }\n    reverse() {\n        const head = this.head;\n        const tail = this.tail;\n        for (let walker = head; !!walker; walker = walker.prev) {\n            const p = walker.prev;\n            walker.prev = walker.next;\n            walker.next = p;\n        }\n        this.head = tail;\n        this.tail = head;\n        return this;\n    }\n}\n// insertAfter undefined means \"make the node the new head of list\"\nfunction insertAfter(self, node, value) {\n    const prev = node;\n    const next = node ? node.next : self.head;\n    const inserted = new Node(value, prev, next, self);\n    if (inserted.next === undefined) {\n        self.tail = inserted;\n    }\n    if (inserted.prev === undefined) {\n        self.head = inserted;\n    }\n    self.length++;\n    return inserted;\n}\nfunction push(self, item) {\n    self.tail = new Node(item, self.tail, undefined, self);\n    if (!self.head) {\n        self.head = self.tail;\n    }\n    self.length++;\n}\nfunction unshift(self, item) {\n    self.head = new Node(item, undefined, self.head, self);\n    if (!self.tail) {\n        self.tail = self.head;\n    }\n    self.length++;\n}\nexport class Node {\n    list;\n    next;\n    prev;\n    value;\n    constructor(value, prev, next, list) {\n        this.list = list;\n        this.value = value;\n        if (prev) {\n            prev.next = this;\n            this.prev = prev;\n        }\n        else {\n            this.prev = undefined;\n        }\n        if (next) {\n            next.prev = this;\n            this.next = next;\n        }\n        else {\n            this.next = undefined;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\nimport fs from 'fs';\nimport { WriteEntry, WriteEntrySync, WriteEntryTar, } from './write-entry.js';\nexport class PackJob {\n    path;\n    absolute;\n    entry;\n    stat;\n    readdir;\n    pending = false;\n    ignore = false;\n    piped = false;\n    constructor(path, absolute) {\n        this.path = path || './';\n        this.absolute = absolute;\n    }\n}\nimport { Minipass } from 'minipass';\nimport * as zlib from 'minizlib';\nimport { Yallist } from 'yallist';\nimport { ReadEntry } from './read-entry.js';\nimport { warnMethod, } from './warn-method.js';\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\nimport path from 'path';\nimport { normalizeWindowsPath } from './normalize-windows-path.js';\nexport class Pack extends Minipass {\n    opt;\n    cwd;\n    maxReadSize;\n    preservePaths;\n    strict;\n    noPax;\n    prefix;\n    linkCache;\n    statCache;\n    file;\n    portable;\n    zip;\n    readdirCache;\n    noDirRecurse;\n    follow;\n    noMtime;\n    mtime;\n    filter;\n    jobs;\n    [WRITEENTRYCLASS];\n    onWriteEntry;\n    // Note: we actually DO need a linked list here, because we\n    // shift() to update the head of the list where we start, but still\n    // while that happens, need to know what the next item in the queue\n    // will be. Since we do multiple jobs in parallel, it's not as simple\n    // as just an Array.shift(), since that would lose the information about\n    // the next job in the list. We could add a .next field on the PackJob\n    // class, but then we'd have to be tracking the tail of the queue the\n    // whole time, and Yallist just does that for us anyway.\n    [QUEUE];\n    [JOBS] = 0;\n    [PROCESSING] = false;\n    [ENDED] = false;\n    constructor(opt = {}) {\n        //@ts-ignore\n        super();\n        this.opt = opt;\n        this.file = opt.file || '';\n        this.cwd = opt.cwd || process.cwd();\n        this.maxReadSize = opt.maxReadSize;\n        this.preservePaths = !!opt.preservePaths;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.prefix = normalizeWindowsPath(opt.prefix || '');\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.readdirCache = opt.readdirCache || new Map();\n        this.onWriteEntry = opt.onWriteEntry;\n        this[WRITEENTRYCLASS] = WriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        this.portable = !!opt.portable;\n        if (opt.gzip || opt.brotli || opt.zstd) {\n            if ((opt.gzip ? 1 : 0) + (opt.brotli ? 1 : 0) + (opt.zstd ? 1 : 0) > 1) {\n                throw new TypeError('gzip, brotli, zstd are mutually exclusive');\n            }\n            if (opt.gzip) {\n                if (typeof opt.gzip !== 'object') {\n                    opt.gzip = {};\n                }\n                if (this.portable) {\n                    opt.gzip.portable = true;\n                }\n                this.zip = new zlib.Gzip(opt.gzip);\n            }\n            if (opt.brotli) {\n                if (typeof opt.brotli !== 'object') {\n                    opt.brotli = {};\n                }\n                this.zip = new zlib.BrotliCompress(opt.brotli);\n            }\n            if (opt.zstd) {\n                if (typeof opt.zstd !== 'object') {\n                    opt.zstd = {};\n                }\n                this.zip = new zlib.ZstdCompress(opt.zstd);\n            }\n            /* c8 ignore next */\n            if (!this.zip)\n                throw new Error('impossible');\n            const zip = this.zip;\n            zip.on('data', chunk => super.write(chunk));\n            zip.on('end', () => super.end());\n            zip.on('drain', () => this[ONDRAIN]());\n            this.on('resume', () => zip.resume());\n        }\n        else {\n            this.on('drain', this[ONDRAIN]);\n        }\n        this.noDirRecurse = !!opt.noDirRecurse;\n        this.follow = !!opt.follow;\n        this.noMtime = !!opt.noMtime;\n        if (opt.mtime)\n            this.mtime = opt.mtime;\n        this.filter =\n            typeof opt.filter === 'function' ? opt.filter : () => true;\n        this[QUEUE] = new Yallist();\n        this[JOBS] = 0;\n        this.jobs = Number(opt.jobs) || 4;\n        this[PROCESSING] = false;\n        this[ENDED] = false;\n    }\n    [WRITE](chunk) {\n        return super.write(chunk);\n    }\n    add(path) {\n        this.write(path);\n        return this;\n    }\n    end(path, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof path === 'function') {\n            cb = path;\n            path = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (path) {\n            this.add(path);\n        }\n        this[ENDED] = true;\n        this[PROCESS]();\n        /* c8 ignore next */\n        if (cb)\n            cb();\n        return this;\n    }\n    write(path) {\n        if (this[ENDED]) {\n            throw new Error('write after end');\n        }\n        if (path instanceof ReadEntry) {\n            this[ADDTARENTRY](path);\n        }\n        else {\n            this[ADDFSENTRY](path);\n        }\n        return this.flowing;\n    }\n    [ADDTARENTRY](p) {\n        const absolute = normalizeWindowsPath(path.resolve(this.cwd, p.path));\n        // in this case, we don't have to wait for the stat\n        if (!this.filter(p.path, p)) {\n            p.resume();\n        }\n        else {\n            const job = new PackJob(p.path, absolute);\n            job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n            job.entry.on('end', () => this[JOBDONE](job));\n            this[JOBS] += 1;\n            this[QUEUE].push(job);\n        }\n        this[PROCESS]();\n    }\n    [ADDFSENTRY](p) {\n        const absolute = normalizeWindowsPath(path.resolve(this.cwd, p));\n        this[QUEUE].push(new PackJob(p, absolute));\n        this[PROCESS]();\n    }\n    [STAT](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        const stat = this.follow ? 'stat' : 'lstat';\n        fs[stat](job.absolute, (er, stat) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                this.emit('error', er);\n            }\n            else {\n                this[ONSTAT](job, stat);\n            }\n        });\n    }\n    [ONSTAT](job, stat) {\n        this.statCache.set(job.absolute, stat);\n        job.stat = stat;\n        // now we have the stat, we can filter it.\n        if (!this.filter(job.path, stat)) {\n            job.ignore = true;\n        }\n        this[PROCESS]();\n    }\n    [READDIR](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        fs.readdir(job.absolute, (er, entries) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADDIR](job, entries);\n        });\n    }\n    [ONREADDIR](job, entries) {\n        this.readdirCache.set(job.absolute, entries);\n        job.readdir = entries;\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        if (this[PROCESSING]) {\n            return;\n        }\n        this[PROCESSING] = true;\n        for (let w = this[QUEUE].head; !!w && this[JOBS] < this.jobs; w = w.next) {\n            this[PROCESSJOB](w.value);\n            if (w.value.ignore) {\n                const p = w.next;\n                this[QUEUE].removeNode(w);\n                w.next = p;\n            }\n        }\n        this[PROCESSING] = false;\n        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n            if (this.zip) {\n                this.zip.end(EOF);\n            }\n            else {\n                super.write(EOF);\n                super.end();\n            }\n        }\n    }\n    get [CURRENT]() {\n        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n    [JOBDONE](_job) {\n        this[QUEUE].shift();\n        this[JOBS] -= 1;\n        this[PROCESS]();\n    }\n    [PROCESSJOB](job) {\n        if (job.pending) {\n            return;\n        }\n        if (job.entry) {\n            if (job === this[CURRENT] && !job.piped) {\n                this[PIPE](job);\n            }\n            return;\n        }\n        if (!job.stat) {\n            const sc = this.statCache.get(job.absolute);\n            if (sc) {\n                this[ONSTAT](job, sc);\n            }\n            else {\n                this[STAT](job);\n            }\n        }\n        if (!job.stat) {\n            return;\n        }\n        // filtered out!\n        if (job.ignore) {\n            return;\n        }\n        if (!this.noDirRecurse &&\n            job.stat.isDirectory() &&\n            !job.readdir) {\n            const rc = this.readdirCache.get(job.absolute);\n            if (rc) {\n                this[ONREADDIR](job, rc);\n            }\n            else {\n                this[READDIR](job);\n            }\n            if (!job.readdir) {\n                return;\n            }\n        }\n        // we know it doesn't have an entry, because that got checked above\n        job.entry = this[ENTRY](job);\n        if (!job.entry) {\n            job.ignore = true;\n            return;\n        }\n        if (job === this[CURRENT] && !job.piped) {\n            this[PIPE](job);\n        }\n    }\n    [ENTRYOPT](job) {\n        return {\n            onwarn: (code, msg, data) => this.warn(code, msg, data),\n            noPax: this.noPax,\n            cwd: this.cwd,\n            absolute: job.absolute,\n            preservePaths: this.preservePaths,\n            maxReadSize: this.maxReadSize,\n            strict: this.strict,\n            portable: this.portable,\n            linkCache: this.linkCache,\n            statCache: this.statCache,\n            noMtime: this.noMtime,\n            mtime: this.mtime,\n            prefix: this.prefix,\n            onWriteEntry: this.onWriteEntry,\n        };\n    }\n    [ENTRY](job) {\n        this[JOBS] += 1;\n        try {\n            const e = new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job));\n            return e\n                .on('end', () => this[JOBDONE](job))\n                .on('error', er => this.emit('error', er));\n        }\n        catch (er) {\n            this.emit('error', er);\n        }\n    }\n    [ONDRAIN]() {\n        if (this[CURRENT] && this[CURRENT].entry) {\n            this[CURRENT].entry.resume();\n        }\n    }\n    // like .pipe() but using super, because our write() is special\n    [PIPE](job) {\n        job.piped = true;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        const source = job.entry;\n        const zip = this.zip;\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                if (!zip.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                if (!super.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n    }\n    pause() {\n        if (this.zip) {\n            this.zip.pause();\n        }\n        return super.pause();\n    }\n    warn(code, message, data = {}) {\n        warnMethod(this, code, message, data);\n    }\n}\nexport class PackSync extends Pack {\n    sync = true;\n    constructor(opt) {\n        super(opt);\n        this[WRITEENTRYCLASS] = WriteEntrySync;\n    }\n    // pause/resume are no-ops in sync streams.\n    pause() { }\n    resume() { }\n    [STAT](job) {\n        const stat = this.follow ? 'statSync' : 'lstatSync';\n        this[ONSTAT](job, fs[stat](job.absolute));\n    }\n    [READDIR](job) {\n        this[ONREADDIR](job, fs.readdirSync(job.absolute));\n    }\n    // gotta get it all in this tick\n    [PIPE](job) {\n        const source = job.entry;\n        const zip = this.zip;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('Cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                zip.write(chunk);\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                super[WRITE](chunk);\n            });\n        }\n    }\n}\n//# sourceMappingURL=pack.js.map","import { WriteStream, WriteStreamSync } from '@isaacs/fs-minipass';\nimport path from 'node:path';\nimport { list } from './list.js';\nimport { makeCommand } from './make-command.js';\nimport { Pack, PackSync } from './pack.js';\nconst createFileSync = (opt, files) => {\n    const p = new PackSync(opt);\n    const stream = new WriteStreamSync(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst createFile = (opt, files) => {\n    const p = new Pack(opt);\n    const stream = new WriteStream(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    const promise = new Promise((res, rej) => {\n        stream.on('error', rej);\n        stream.on('close', res);\n        p.on('error', rej);\n    });\n    addFilesAsync(p, files);\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            list({\n                file: path.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await list({\n                file: path.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => {\n                    p.add(entry);\n                },\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nconst createSync = (opt, files) => {\n    const p = new PackSync(opt);\n    addFilesSync(p, files);\n    return p;\n};\nconst createAsync = (opt, files) => {\n    const p = new Pack(opt);\n    addFilesAsync(p, files);\n    return p;\n};\nexport const create = makeCommand(createFileSync, createFile, createSync, createAsync, (_opt, files) => {\n    if (!files?.length) {\n        throw new TypeError('no paths specified to add to archive');\n    }\n});\n//# sourceMappingURL=create.js.map","// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\nimport fs from 'fs';\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform;\nconst isWindows = platform === 'win32';\n/* c8 ignore start */\nconst { O_CREAT, O_TRUNC, O_WRONLY } = fs.constants;\nconst UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) ||\n    fs.constants.UV_FS_O_FILEMAP ||\n    0;\n/* c8 ignore stop */\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;\nconst fMapLimit = 512 * 1024;\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;\nexport const getWriteFlag = !fMapEnabled ?\n    () => 'w'\n    : (size) => (size < fMapLimit ? fMapFlag : 'w');\n//# sourceMappingURL=get-write-flag.js.map","import fs from 'node:fs';\nimport path from 'node:path';\nconst lchownSync = (path, uid, gid) => {\n    try {\n        return fs.lchownSync(path, uid, gid);\n    }\n    catch (er) {\n        if (er?.code !== 'ENOENT')\n            throw er;\n    }\n};\nconst chown = (cpath, uid, gid, cb) => {\n    fs.lchown(cpath, uid, gid, er => {\n        // Skip ENOENT error\n        cb(er && er?.code !== 'ENOENT' ? er : null);\n    });\n};\nconst chownrKid = (p, child, uid, gid, cb) => {\n    if (child.isDirectory()) {\n        chownr(path.resolve(p, child.name), uid, gid, (er) => {\n            if (er)\n                return cb(er);\n            const cpath = path.resolve(p, child.name);\n            chown(cpath, uid, gid, cb);\n        });\n    }\n    else {\n        const cpath = path.resolve(p, child.name);\n        chown(cpath, uid, gid, cb);\n    }\n};\nexport const chownr = (p, uid, gid, cb) => {\n    fs.readdir(p, { withFileTypes: true }, (er, children) => {\n        // any error other than ENOTDIR or ENOTSUP means it's not readable,\n        // or doesn't exist.  give up.\n        if (er) {\n            if (er.code === 'ENOENT')\n                return cb();\n            else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n                return cb(er);\n        }\n        if (er || !children.length)\n            return chown(p, uid, gid, cb);\n        let len = children.length;\n        let errState = null;\n        const then = (er) => {\n            /* c8 ignore start */\n            if (errState)\n                return;\n            /* c8 ignore stop */\n            if (er)\n                return cb((errState = er));\n            if (--len === 0)\n                return chown(p, uid, gid, cb);\n        };\n        for (const child of children) {\n            chownrKid(p, child, uid, gid, then);\n        }\n    });\n};\nconst chownrKidSync = (p, child, uid, gid) => {\n    if (child.isDirectory())\n        chownrSync(path.resolve(p, child.name), uid, gid);\n    lchownSync(path.resolve(p, child.name), uid, gid);\n};\nexport const chownrSync = (p, uid, gid) => {\n    let children;\n    try {\n        children = fs.readdirSync(p, { withFileTypes: true });\n    }\n    catch (er) {\n        const e = er;\n        if (e?.code === 'ENOENT')\n            return;\n        else if (e?.code === 'ENOTDIR' || e?.code === 'ENOTSUP')\n            return lchownSync(p, uid, gid);\n        else\n            throw e;\n    }\n    for (const child of children) {\n        chownrKidSync(p, child, uid, gid);\n    }\n    return lchownSync(p, uid, gid);\n};\n//# sourceMappingURL=index.js.map","export class CwdError extends Error {\n    path;\n    code;\n    syscall = 'chdir';\n    constructor(path, code) {\n        super(`${code}: Cannot cd into '${path}'`);\n        this.path = path;\n        this.code = code;\n    }\n    get name() {\n        return 'CwdError';\n    }\n}\n//# sourceMappingURL=cwd-error.js.map","export class SymlinkError extends Error {\n    path;\n    symlink;\n    syscall = 'symlink';\n    code = 'TAR_SYMLINK_ERROR';\n    constructor(symlink, path) {\n        super('TAR_SYMLINK_ERROR: Cannot extract through symbolic link');\n        this.symlink = symlink;\n        this.path = path;\n    }\n    get name() {\n        return 'SymlinkError';\n    }\n}\n//# sourceMappingURL=symlink-error.js.map","import { chownr, chownrSync } from 'chownr';\nimport fs from 'node:fs';\nimport fsp from 'node:fs/promises';\nimport path from 'node:path';\nimport { CwdError } from './cwd-error.js';\nimport { normalizeWindowsPath } from './normalize-windows-path.js';\nimport { SymlinkError } from './symlink-error.js';\nconst checkCwd = (dir, cb) => {\n    fs.stat(dir, (er, st) => {\n        if (er || !st.isDirectory()) {\n            er = new CwdError(dir, er?.code || 'ENOTDIR');\n        }\n        cb(er);\n    });\n};\n/**\n * Wrapper around fs/promises.mkdir for tar's needs.\n *\n * The main purpose is to avoid creating directories if we know that\n * they already exist (and track which ones exist for this purpose),\n * and prevent entries from being extracted into symlinked folders,\n * if `preservePaths` is not set.\n */\nexport const mkdir = (dir, opt, cb) => {\n    dir = normalizeWindowsPath(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o0700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cwd = normalizeWindowsPath(opt.cwd);\n    const done = (er, created) => {\n        if (er) {\n            cb(er);\n        }\n        else {\n            if (created && doChown) {\n                chownr(created, uid, gid, er => done(er));\n            }\n            else if (needChmod) {\n                fs.chmod(dir, mode, cb);\n            }\n            else {\n                cb();\n            }\n        }\n    };\n    if (dir === cwd) {\n        return checkCwd(dir, done);\n    }\n    if (preserve) {\n        return fsp.mkdir(dir, { mode, recursive: true }).then(made => done(null, made ?? undefined), // oh, ts\n        done);\n    }\n    const sub = normalizeWindowsPath(path.relative(cwd, dir));\n    const parts = sub.split('/');\n    mkdir_(cwd, parts, mode, unlink, cwd, undefined, done);\n};\nconst mkdir_ = (base, parts, mode, unlink, cwd, created, cb) => {\n    if (!parts.length) {\n        return cb(null, created);\n    }\n    const p = parts.shift();\n    const part = normalizeWindowsPath(path.resolve(base + '/' + p));\n    fs.mkdir(part, mode, onmkdir(part, parts, mode, unlink, cwd, created, cb));\n};\nconst onmkdir = (part, parts, mode, unlink, cwd, created, cb) => (er) => {\n    if (er) {\n        fs.lstat(part, (statEr, st) => {\n            if (statEr) {\n                statEr.path =\n                    statEr.path && normalizeWindowsPath(statEr.path);\n                cb(statEr);\n            }\n            else if (st.isDirectory()) {\n                mkdir_(part, parts, mode, unlink, cwd, created, cb);\n            }\n            else if (unlink) {\n                fs.unlink(part, er => {\n                    if (er) {\n                        return cb(er);\n                    }\n                    fs.mkdir(part, mode, onmkdir(part, parts, mode, unlink, cwd, created, cb));\n                });\n            }\n            else if (st.isSymbolicLink()) {\n                return cb(new SymlinkError(part, part + '/' + parts.join('/')));\n            }\n            else {\n                cb(er);\n            }\n        });\n    }\n    else {\n        created = created || part;\n        mkdir_(part, parts, mode, unlink, cwd, created, cb);\n    }\n};\nconst checkCwdSync = (dir) => {\n    let ok = false;\n    let code = undefined;\n    try {\n        ok = fs.statSync(dir).isDirectory();\n    }\n    catch (er) {\n        code = er?.code;\n    }\n    finally {\n        if (!ok) {\n            throw new CwdError(dir, code ?? 'ENOTDIR');\n        }\n    }\n};\nexport const mkdirSync = (dir, opt) => {\n    dir = normalizeWindowsPath(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cwd = normalizeWindowsPath(opt.cwd);\n    const done = (created) => {\n        if (created && doChown) {\n            chownrSync(created, uid, gid);\n        }\n        if (needChmod) {\n            fs.chmodSync(dir, mode);\n        }\n    };\n    if (dir === cwd) {\n        checkCwdSync(cwd);\n        return done();\n    }\n    if (preserve) {\n        return done(fs.mkdirSync(dir, { mode, recursive: true }) ?? undefined);\n    }\n    const sub = normalizeWindowsPath(path.relative(cwd, dir));\n    const parts = sub.split('/');\n    let created = undefined;\n    for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n        part = normalizeWindowsPath(path.resolve(part));\n        try {\n            fs.mkdirSync(part, mode);\n            created = created || part;\n        }\n        catch (er) {\n            const st = fs.lstatSync(part);\n            if (st.isDirectory()) {\n                continue;\n            }\n            else if (unlink) {\n                fs.unlinkSync(part);\n                fs.mkdirSync(part, mode);\n                created = created || part;\n                continue;\n            }\n            else if (st.isSymbolicLink()) {\n                return new SymlinkError(part, part + '/' + parts.join('/'));\n            }\n        }\n    }\n    return done(created);\n};\n//# sourceMappingURL=mkdir.js.map","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null);\n// Limit the size of this. Very low-sophistication LRU cache\nconst MAX = 10000;\nconst cache = new Set();\nexport const normalizeUnicode = (s) => {\n    if (!cache.has(s)) {\n        normalizeCache[s] = s.normalize('NFD');\n    }\n    else {\n        cache.delete(s);\n    }\n    cache.add(s);\n    const ret = normalizeCache[s];\n    let i = cache.size - MAX;\n    // only prune when we're 10% over the max\n    if (i > MAX / 10) {\n        for (const s of cache) {\n            cache.delete(s);\n            delete normalizeCache[s];\n            if (--i <= 0)\n                break;\n        }\n    }\n    return ret;\n};\n//# sourceMappingURL=normalize-unicode.js.map","// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\nimport { join } from 'node:path';\nimport { normalizeUnicode } from './normalize-unicode.js';\nimport { stripTrailingSlashes } from './strip-trailing-slashes.js';\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\n// return a set of parent dirs for a given path\n// '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\nconst getDirs = (path) => {\n    const dirs = path\n        .split('/')\n        .slice(0, -1)\n        .reduce((set, path) => {\n        const s = set[set.length - 1];\n        if (s !== undefined) {\n            path = join(s, path);\n        }\n        set.push(path || '/');\n        return set;\n    }, []);\n    return dirs;\n};\nexport class PathReservations {\n    // path => [function or Set]\n    // A Set object means a directory reservation\n    // A fn is a direct reservation on that path\n    #queues = new Map();\n    // fn => {paths:[path,...], dirs:[path, ...]}\n    #reservations = new Map();\n    // functions currently running\n    #running = new Set();\n    reserve(paths, fn) {\n        paths =\n            isWindows ?\n                ['win32 parallelization disabled']\n                : paths.map(p => {\n                    // don't need normPath, because we skip this entirely for windows\n                    return stripTrailingSlashes(join(normalizeUnicode(p))).toLowerCase();\n                });\n        const dirs = new Set(paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)));\n        this.#reservations.set(fn, { dirs, paths });\n        for (const p of paths) {\n            const q = this.#queues.get(p);\n            if (!q) {\n                this.#queues.set(p, [fn]);\n            }\n            else {\n                q.push(fn);\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            if (!q) {\n                this.#queues.set(dir, [new Set([fn])]);\n            }\n            else {\n                const l = q[q.length - 1];\n                if (l instanceof Set) {\n                    l.add(fn);\n                }\n                else {\n                    q.push(new Set([fn]));\n                }\n            }\n        }\n        return this.#run(fn);\n    }\n    // return the queues for each path the function cares about\n    // fn => {paths, dirs}\n    #getQueues(fn) {\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('function does not have any path reservations');\n        }\n        /* c8 ignore stop */\n        return {\n            paths: res.paths.map((path) => this.#queues.get(path)),\n            dirs: [...res.dirs].map(path => this.#queues.get(path)),\n        };\n    }\n    // check if fn is first in line for all its paths, and is\n    // included in the first set for all its dir queues\n    check(fn) {\n        const { paths, dirs } = this.#getQueues(fn);\n        return (paths.every(q => q && q[0] === fn) &&\n            dirs.every(q => q && q[0] instanceof Set && q[0].has(fn)));\n    }\n    // run the function if it's first in line and not already running\n    #run(fn) {\n        if (this.#running.has(fn) || !this.check(fn)) {\n            return false;\n        }\n        this.#running.add(fn);\n        fn(() => this.#clear(fn));\n        return true;\n    }\n    #clear(fn) {\n        if (!this.#running.has(fn)) {\n            return false;\n        }\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('invalid reservation');\n        }\n        /* c8 ignore stop */\n        const { paths, dirs } = res;\n        const next = new Set();\n        for (const path of paths) {\n            const q = this.#queues.get(path);\n            /* c8 ignore start */\n            if (!q || q?.[0] !== fn) {\n                continue;\n            }\n            /* c8 ignore stop */\n            const q0 = q[1];\n            if (!q0) {\n                this.#queues.delete(path);\n                continue;\n            }\n            q.shift();\n            if (typeof q0 === 'function') {\n                next.add(q0);\n            }\n            else {\n                for (const f of q0) {\n                    next.add(f);\n                }\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            const q0 = q?.[0];\n            /* c8 ignore next - type safety only */\n            if (!q || !(q0 instanceof Set))\n                continue;\n            if (q0.size === 1 && q.length === 1) {\n                this.#queues.delete(dir);\n                continue;\n            }\n            else if (q0.size === 1) {\n                q.shift();\n                // next one must be a function,\n                // or else the Set would've been reused\n                const n = q[0];\n                if (typeof n === 'function') {\n                    next.add(n);\n                }\n            }\n            else {\n                q0.delete(fn);\n            }\n        }\n        this.#running.delete(fn);\n        next.forEach(fn => this.#run(fn));\n        return true;\n    }\n}\n//# sourceMappingURL=path-reservations.js.map","// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\nimport * as fsm from '@isaacs/fs-minipass';\nimport assert from 'node:assert';\nimport { randomBytes } from 'node:crypto';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { getWriteFlag } from './get-write-flag.js';\nimport { mkdir, mkdirSync } from './mkdir.js';\nimport { normalizeWindowsPath } from './normalize-windows-path.js';\nimport { Parser } from './parse.js';\nimport { stripAbsolutePath } from './strip-absolute-path.js';\nimport * as wc from './winchars.js';\nimport { PathReservations } from './path-reservations.js';\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\nconst DEFAULT_MAX_DEPTH = 1024;\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* c8 ignore start */\nconst unlinkFile = (path, cb) => {\n    if (!isWindows) {\n        return fs.unlink(path, cb);\n    }\n    const name = path + '.DELETE.' + randomBytes(16).toString('hex');\n    fs.rename(path, name, er => {\n        if (er) {\n            return cb(er);\n        }\n        fs.unlink(name, cb);\n    });\n};\n/* c8 ignore stop */\n/* c8 ignore start */\nconst unlinkFileSync = (path) => {\n    if (!isWindows) {\n        return fs.unlinkSync(path);\n    }\n    const name = path + '.DELETE.' + randomBytes(16).toString('hex');\n    fs.renameSync(path, name);\n    fs.unlinkSync(name);\n};\n/* c8 ignore stop */\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) => a !== undefined && a === a >>> 0 ? a\n    : b !== undefined && b === b >>> 0 ? b\n        : c;\nexport class Unpack extends Parser {\n    [ENDED] = false;\n    [CHECKED_CWD] = false;\n    [PENDING] = 0;\n    reservations = new PathReservations();\n    transform;\n    writable = true;\n    readable = false;\n    uid;\n    gid;\n    setOwner;\n    preserveOwner;\n    processGid;\n    processUid;\n    maxDepth;\n    forceChown;\n    win32;\n    newer;\n    keep;\n    noMtime;\n    preservePaths;\n    unlink;\n    cwd;\n    strip;\n    processUmask;\n    umask;\n    dmode;\n    fmode;\n    chmod;\n    constructor(opt = {}) {\n        opt.ondone = () => {\n            this[ENDED] = true;\n            this[MAYBECLOSE]();\n        };\n        super(opt);\n        this.transform = opt.transform;\n        this.chmod = !!opt.chmod;\n        if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n            // need both or neither\n            if (typeof opt.uid !== 'number' ||\n                typeof opt.gid !== 'number') {\n                throw new TypeError('cannot set owner without number uid and gid');\n            }\n            if (opt.preserveOwner) {\n                throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n            }\n            this.uid = opt.uid;\n            this.gid = opt.gid;\n            this.setOwner = true;\n        }\n        else {\n            this.uid = undefined;\n            this.gid = undefined;\n            this.setOwner = false;\n        }\n        // default true for root\n        if (opt.preserveOwner === undefined &&\n            typeof opt.uid !== 'number') {\n            this.preserveOwner = !!(process.getuid && process.getuid() === 0);\n        }\n        else {\n            this.preserveOwner = !!opt.preserveOwner;\n        }\n        this.processUid =\n            (this.preserveOwner || this.setOwner) && process.getuid ?\n                process.getuid()\n                : undefined;\n        this.processGid =\n            (this.preserveOwner || this.setOwner) && process.getgid ?\n                process.getgid()\n                : undefined;\n        // prevent excessively deep nesting of subfolders\n        // set to `Infinity` to remove this restriction\n        this.maxDepth =\n            typeof opt.maxDepth === 'number' ?\n                opt.maxDepth\n                : DEFAULT_MAX_DEPTH;\n        // mostly just for testing, but useful in some cases.\n        // Forcibly trigger a chown on every entry, no matter what\n        this.forceChown = opt.forceChown === true;\n        // turn ><?| in filenames into 0xf000-higher encoded forms\n        this.win32 = !!opt.win32 || isWindows;\n        // do not unpack over files that are newer than what's in the archive\n        this.newer = !!opt.newer;\n        // do not unpack over ANY files\n        this.keep = !!opt.keep;\n        // do not set mtime/atime of extracted entries\n        this.noMtime = !!opt.noMtime;\n        // allow .., absolute path entries, and unpacking through symlinks\n        // without this, warn and skip .., relativize absolutes, and error\n        // on symlinks in extraction path\n        this.preservePaths = !!opt.preservePaths;\n        // unlink files and links before writing. This breaks existing hard\n        // links, and removes symlink directories rather than erroring\n        this.unlink = !!opt.unlink;\n        this.cwd = normalizeWindowsPath(path.resolve(opt.cwd || process.cwd()));\n        this.strip = Number(opt.strip) || 0;\n        // if we're not chmodding, then we don't need the process umask\n        this.processUmask =\n            !this.chmod ? 0\n                : typeof opt.processUmask === 'number' ? opt.processUmask\n                    : process.umask();\n        this.umask =\n            typeof opt.umask === 'number' ? opt.umask : this.processUmask;\n        // default mode for dirs created as parents\n        this.dmode = opt.dmode || 0o0777 & ~this.umask;\n        this.fmode = opt.fmode || 0o0666 & ~this.umask;\n        this.on('entry', entry => this[ONENTRY](entry));\n    }\n    // a bad or damaged archive is a warning for Parser, but an error\n    // when extracting.  Mark those errors as unrecoverable, because\n    // the Unpack contract cannot be met.\n    warn(code, msg, data = {}) {\n        if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n            data.recoverable = false;\n        }\n        return super.warn(code, msg, data);\n    }\n    [MAYBECLOSE]() {\n        if (this[ENDED] && this[PENDING] === 0) {\n            this.emit('prefinish');\n            this.emit('finish');\n            this.emit('end');\n        }\n    }\n    [CHECKPATH](entry) {\n        const p = normalizeWindowsPath(entry.path);\n        const parts = p.split('/');\n        if (this.strip) {\n            if (parts.length < this.strip) {\n                return false;\n            }\n            if (entry.type === 'Link') {\n                const linkparts = normalizeWindowsPath(String(entry.linkpath)).split('/');\n                if (linkparts.length >= this.strip) {\n                    entry.linkpath = linkparts.slice(this.strip).join('/');\n                }\n                else {\n                    return false;\n                }\n            }\n            parts.splice(0, this.strip);\n            entry.path = parts.join('/');\n        }\n        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n            this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n                entry,\n                path: p,\n                depth: parts.length,\n                maxDepth: this.maxDepth,\n            });\n            return false;\n        }\n        if (!this.preservePaths) {\n            if (parts.includes('..') ||\n                /* c8 ignore next */\n                (isWindows && /^[a-z]:\\.\\.$/i.test(parts[0] ?? ''))) {\n                this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n                    entry,\n                    path: p,\n                });\n                return false;\n            }\n            // strip off the root\n            const [root, stripped] = stripAbsolutePath(p);\n            if (root) {\n                entry.path = String(stripped);\n                this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n                    entry,\n                    path: p,\n                });\n            }\n        }\n        if (path.isAbsolute(entry.path)) {\n            entry.absolute = normalizeWindowsPath(path.resolve(entry.path));\n        }\n        else {\n            entry.absolute = normalizeWindowsPath(path.resolve(this.cwd, entry.path));\n        }\n        // if we somehow ended up with a path that escapes the cwd, and we are\n        // not in preservePaths mode, then something is fishy!  This should have\n        // been prevented above, so ignore this for coverage.\n        /* c8 ignore start - defense in depth */\n        if (!this.preservePaths &&\n            typeof entry.absolute === 'string' &&\n            entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n            entry.absolute !== this.cwd) {\n            this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n                entry,\n                path: normalizeWindowsPath(entry.path),\n                resolvedPath: entry.absolute,\n                cwd: this.cwd,\n            });\n            return false;\n        }\n        /* c8 ignore stop */\n        // an archive can set properties on the extraction directory, but it\n        // may not replace the cwd with a different kind of thing entirely.\n        if (entry.absolute === this.cwd &&\n            entry.type !== 'Directory' &&\n            entry.type !== 'GNUDumpDir') {\n            return false;\n        }\n        // only encode : chars that aren't drive letter indicators\n        if (this.win32) {\n            const { root: aRoot } = path.win32.parse(String(entry.absolute));\n            entry.absolute =\n                aRoot + wc.encode(String(entry.absolute).slice(aRoot.length));\n            const { root: pRoot } = path.win32.parse(entry.path);\n            entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));\n        }\n        return true;\n    }\n    [ONENTRY](entry) {\n        if (!this[CHECKPATH](entry)) {\n            return entry.resume();\n        }\n        assert.equal(typeof entry.absolute, 'string');\n        switch (entry.type) {\n            case 'Directory':\n            case 'GNUDumpDir':\n                if (entry.mode) {\n                    entry.mode = entry.mode | 0o700;\n                }\n            // eslint-disable-next-line no-fallthrough\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n            case 'Link':\n            case 'SymbolicLink':\n                return this[CHECKFS](entry);\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'FIFO':\n            default:\n                return this[UNSUPPORTED](entry);\n        }\n    }\n    [ONERROR](er, entry) {\n        // Cwd has to exist, or else nothing works. That's serious.\n        // Other errors are warnings, which raise the error in strict\n        // mode, but otherwise continue on.\n        if (er.name === 'CwdError') {\n            this.emit('error', er);\n        }\n        else {\n            this.warn('TAR_ENTRY_ERROR', er, { entry });\n            this[UNPEND]();\n            entry.resume();\n        }\n    }\n    [MKDIR](dir, mode, cb) {\n        mkdir(normalizeWindowsPath(dir), {\n            uid: this.uid,\n            gid: this.gid,\n            processUid: this.processUid,\n            processGid: this.processGid,\n            umask: this.processUmask,\n            preserve: this.preservePaths,\n            unlink: this.unlink,\n            cwd: this.cwd,\n            mode: mode,\n        }, cb);\n    }\n    [DOCHOWN](entry) {\n        // in preserve owner mode, chown if the entry doesn't match process\n        // in set owner mode, chown if setting doesn't match process\n        return (this.forceChown ||\n            (this.preserveOwner &&\n                ((typeof entry.uid === 'number' &&\n                    entry.uid !== this.processUid) ||\n                    (typeof entry.gid === 'number' &&\n                        entry.gid !== this.processGid))) ||\n            (typeof this.uid === 'number' &&\n                this.uid !== this.processUid) ||\n            (typeof this.gid === 'number' && this.gid !== this.processGid));\n    }\n    [UID](entry) {\n        return uint32(this.uid, entry.uid, this.processUid);\n    }\n    [GID](entry) {\n        return uint32(this.gid, entry.gid, this.processGid);\n    }\n    [FILE](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const stream = new fsm.WriteStream(String(entry.absolute), {\n            // slight lie, but it can be numeric flags\n            flags: getWriteFlag(entry.size),\n            mode: mode,\n            autoClose: false,\n        });\n        stream.on('error', (er) => {\n            if (stream.fd) {\n                fs.close(stream.fd, () => { });\n            }\n            // flush all the data out so that we aren't left hanging\n            // if the error wasn't actually fatal.  otherwise the parse\n            // is blocked, and we never proceed.\n            stream.write = () => true;\n            this[ONERROR](er, entry);\n            fullyDone();\n        });\n        let actions = 1;\n        const done = (er) => {\n            if (er) {\n                /* c8 ignore start - we should always have a fd by now */\n                if (stream.fd) {\n                    fs.close(stream.fd, () => { });\n                }\n                /* c8 ignore stop */\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            if (--actions === 0) {\n                if (stream.fd !== undefined) {\n                    fs.close(stream.fd, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                        }\n                        else {\n                            this[UNPEND]();\n                        }\n                        fullyDone();\n                    });\n                }\n            }\n        };\n        stream.on('finish', () => {\n            // if futimes fails, try utimes\n            // if utimes fails, fail with the original error\n            // same for fchown/chown\n            const abs = String(entry.absolute);\n            const fd = stream.fd;\n            if (typeof fd === 'number' && entry.mtime && !this.noMtime) {\n                actions++;\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                fs.futimes(fd, atime, mtime, er => er ?\n                    fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n                    : done());\n            }\n            if (typeof fd === 'number' && this[DOCHOWN](entry)) {\n                actions++;\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                if (typeof uid === 'number' && typeof gid === 'number') {\n                    fs.fchown(fd, uid, gid, er => er ?\n                        fs.chown(abs, uid, gid, er2 => done(er2 && er))\n                        : done());\n                }\n            }\n            done();\n        });\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => {\n                this[ONERROR](er, entry);\n                fullyDone();\n            });\n            entry.pipe(tx);\n        }\n        tx.pipe(stream);\n    }\n    [DIRECTORY](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        this[MKDIR](String(entry.absolute), mode, er => {\n            if (er) {\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            let actions = 1;\n            const done = () => {\n                if (--actions === 0) {\n                    fullyDone();\n                    this[UNPEND]();\n                    entry.resume();\n                }\n            };\n            if (entry.mtime && !this.noMtime) {\n                actions++;\n                fs.utimes(String(entry.absolute), entry.atime || new Date(), entry.mtime, done);\n            }\n            if (this[DOCHOWN](entry)) {\n                actions++;\n                fs.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);\n            }\n            done();\n        });\n    }\n    [UNSUPPORTED](entry) {\n        entry.unsupported = true;\n        this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, { entry });\n        entry.resume();\n    }\n    [SYMLINK](entry, done) {\n        this[LINK](entry, String(entry.linkpath), 'symlink', done);\n    }\n    [HARDLINK](entry, done) {\n        const linkpath = normalizeWindowsPath(path.resolve(this.cwd, String(entry.linkpath)));\n        this[LINK](entry, linkpath, 'link', done);\n    }\n    [PEND]() {\n        this[PENDING]++;\n    }\n    [UNPEND]() {\n        this[PENDING]--;\n        this[MAYBECLOSE]();\n    }\n    [SKIP](entry) {\n        this[UNPEND]();\n        entry.resume();\n    }\n    // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n    [ISREUSABLE](entry, st) {\n        return (entry.type === 'File' &&\n            !this.unlink &&\n            st.isFile() &&\n            st.nlink <= 1 &&\n            !isWindows);\n    }\n    // check if a thing is there, and if so, try to clobber it\n    [CHECKFS](entry) {\n        this[PEND]();\n        const paths = [entry.path];\n        if (entry.linkpath) {\n            paths.push(entry.linkpath);\n        }\n        this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n    }\n    [CHECKFS2](entry, fullyDone) {\n        const done = (er) => {\n            fullyDone(er);\n        };\n        const checkCwd = () => {\n            this[MKDIR](this.cwd, this.dmode, er => {\n                if (er) {\n                    this[ONERROR](er, entry);\n                    done();\n                    return;\n                }\n                this[CHECKED_CWD] = true;\n                start();\n            });\n        };\n        const start = () => {\n            if (entry.absolute !== this.cwd) {\n                const parent = normalizeWindowsPath(path.dirname(String(entry.absolute)));\n                if (parent !== this.cwd) {\n                    return this[MKDIR](parent, this.dmode, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                            done();\n                            return;\n                        }\n                        afterMakeParent();\n                    });\n                }\n            }\n            afterMakeParent();\n        };\n        const afterMakeParent = () => {\n            fs.lstat(String(entry.absolute), (lstatEr, st) => {\n                if (st &&\n                    (this.keep ||\n                        /* c8 ignore next */\n                        (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n                    this[SKIP](entry);\n                    done();\n                    return;\n                }\n                if (lstatEr || this[ISREUSABLE](entry, st)) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                if (st.isDirectory()) {\n                    if (entry.type === 'Directory') {\n                        const needChmod = this.chmod &&\n                            entry.mode &&\n                            (st.mode & 0o7777) !== entry.mode;\n                        const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);\n                        if (!needChmod) {\n                            return afterChmod();\n                        }\n                        return fs.chmod(String(entry.absolute), Number(entry.mode), afterChmod);\n                    }\n                    // Not a dir entry, have to remove it.\n                    // NB: the only way to end up with an entry that is the cwd\n                    // itself, in such a way that == does not detect, is a\n                    // tricky windows absolute path with UNC or 8.3 parts (and\n                    // preservePaths:true, or else it will have been stripped).\n                    // In that case, the user has opted out of path protections\n                    // explicitly, so if they blow away the cwd, c'est la vie.\n                    if (entry.absolute !== this.cwd) {\n                        return fs.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));\n                    }\n                }\n                // not a dir, and not reusable\n                // don't remove if the cwd, we want that error\n                if (entry.absolute === this.cwd) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                unlinkFile(String(entry.absolute), er => this[MAKEFS](er ?? null, entry, done));\n            });\n        };\n        if (this[CHECKED_CWD]) {\n            start();\n        }\n        else {\n            checkCwd();\n        }\n    }\n    [MAKEFS](er, entry, done) {\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        switch (entry.type) {\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n                return this[FILE](entry, done);\n            case 'Link':\n                return this[HARDLINK](entry, done);\n            case 'SymbolicLink':\n                return this[SYMLINK](entry, done);\n            case 'Directory':\n            case 'GNUDumpDir':\n                return this[DIRECTORY](entry, done);\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        // XXX: get the type ('symlink' or 'junction') for windows\n        fs[link](linkpath, String(entry.absolute), er => {\n            if (er) {\n                this[ONERROR](er, entry);\n            }\n            else {\n                this[UNPEND]();\n                entry.resume();\n            }\n            done();\n        });\n    }\n}\nconst callSync = (fn) => {\n    try {\n        return [null, fn()];\n    }\n    catch (er) {\n        return [er, null];\n    }\n};\nexport class UnpackSync extends Unpack {\n    sync = true;\n    [MAKEFS](er, entry) {\n        return super[MAKEFS](er, entry, () => { });\n    }\n    [CHECKFS](entry) {\n        if (!this[CHECKED_CWD]) {\n            const er = this[MKDIR](this.cwd, this.dmode);\n            if (er) {\n                return this[ONERROR](er, entry);\n            }\n            this[CHECKED_CWD] = true;\n        }\n        // don't bother to make the parent if the current entry is the cwd,\n        // we've already checked it.\n        if (entry.absolute !== this.cwd) {\n            const parent = normalizeWindowsPath(path.dirname(String(entry.absolute)));\n            if (parent !== this.cwd) {\n                const mkParent = this[MKDIR](parent, this.dmode);\n                if (mkParent) {\n                    return this[ONERROR](mkParent, entry);\n                }\n            }\n        }\n        const [lstatEr, st] = callSync(() => fs.lstatSync(String(entry.absolute)));\n        if (st &&\n            (this.keep ||\n                /* c8 ignore next */\n                (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n            return this[SKIP](entry);\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n            return this[MAKEFS](null, entry);\n        }\n        if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n                const needChmod = this.chmod &&\n                    entry.mode &&\n                    (st.mode & 0o7777) !== entry.mode;\n                const [er] = needChmod ?\n                    callSync(() => {\n                        fs.chmodSync(String(entry.absolute), Number(entry.mode));\n                    })\n                    : [];\n                return this[MAKEFS](er, entry);\n            }\n            // not a dir entry, have to remove it\n            const [er] = callSync(() => fs.rmdirSync(String(entry.absolute)));\n            this[MAKEFS](er, entry);\n        }\n        // not a dir, and not reusable.\n        // don't remove if it's the cwd, since we want that error.\n        const [er] = entry.absolute === this.cwd ?\n            []\n            : callSync(() => unlinkFileSync(String(entry.absolute)));\n        this[MAKEFS](er, entry);\n    }\n    [FILE](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const oner = (er) => {\n            let closeError;\n            try {\n                fs.closeSync(fd);\n            }\n            catch (e) {\n                closeError = e;\n            }\n            if (er || closeError) {\n                this[ONERROR](er || closeError, entry);\n            }\n            done();\n        };\n        let fd;\n        try {\n            fd = fs.openSync(String(entry.absolute), getWriteFlag(entry.size), mode);\n            /* c8 ignore start - This is only a problem if the file was successfully\n             * statted, BUT failed to open. Testing this is annoying, and we\n             * already have ample testint for other uses of oner() methods.\n             */\n        }\n        catch (er) {\n            return oner(er);\n        }\n        /* c8 ignore stop */\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => this[ONERROR](er, entry));\n            entry.pipe(tx);\n        }\n        tx.on('data', (chunk) => {\n            try {\n                fs.writeSync(fd, chunk, 0, chunk.length);\n            }\n            catch (er) {\n                oner(er);\n            }\n        });\n        tx.on('end', () => {\n            let er = null;\n            // try both, falling futimes back to utimes\n            // if either fails, handle the first error\n            if (entry.mtime && !this.noMtime) {\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                try {\n                    fs.futimesSync(fd, atime, mtime);\n                }\n                catch (futimeser) {\n                    try {\n                        fs.utimesSync(String(entry.absolute), atime, mtime);\n                    }\n                    catch (utimeser) {\n                        er = futimeser;\n                    }\n                }\n            }\n            if (this[DOCHOWN](entry)) {\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                try {\n                    fs.fchownSync(fd, Number(uid), Number(gid));\n                }\n                catch (fchowner) {\n                    try {\n                        fs.chownSync(String(entry.absolute), Number(uid), Number(gid));\n                    }\n                    catch (chowner) {\n                        er = er || fchowner;\n                    }\n                }\n            }\n            oner(er);\n        });\n    }\n    [DIRECTORY](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        const er = this[MKDIR](String(entry.absolute), mode);\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        if (entry.mtime && !this.noMtime) {\n            try {\n                fs.utimesSync(String(entry.absolute), entry.atime || new Date(), entry.mtime);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n        if (this[DOCHOWN](entry)) {\n            try {\n                fs.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));\n            }\n            catch (er) { }\n        }\n        done();\n        entry.resume();\n    }\n    [MKDIR](dir, mode) {\n        try {\n            return mkdirSync(normalizeWindowsPath(dir), {\n                uid: this.uid,\n                gid: this.gid,\n                processUid: this.processUid,\n                processGid: this.processGid,\n                umask: this.processUmask,\n                preserve: this.preservePaths,\n                unlink: this.unlink,\n                cwd: this.cwd,\n                mode: mode,\n            });\n        }\n        catch (er) {\n            return er;\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        const ls = `${link}Sync`;\n        try {\n            fs[ls](linkpath, String(entry.absolute));\n            done();\n            entry.resume();\n        }\n        catch (er) {\n            return this[ONERROR](er, entry);\n        }\n    }\n}\n//# sourceMappingURL=unpack.js.map","// tar -x\nimport * as fsm from '@isaacs/fs-minipass';\nimport fs from 'node:fs';\nimport { filesFilter } from './list.js';\nimport { makeCommand } from './make-command.js';\nimport { Unpack, UnpackSync } from './unpack.js';\nconst extractFileSync = (opt) => {\n    const u = new UnpackSync(opt);\n    const file = opt.file;\n    const stat = fs.statSync(file);\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const stream = new fsm.ReadStreamSync(file, {\n        readSize: readSize,\n        size: stat.size,\n    });\n    stream.pipe(u);\n};\nconst extractFile = (opt, _) => {\n    const u = new Unpack(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        u.on('error', reject);\n        u.on('close', resolve);\n        // This trades a zero-byte read() syscall for a stat\n        // However, it will usually result in less memory allocation\n        fs.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new fsm.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(u);\n            }\n        });\n    });\n    return p;\n};\nexport const extract = makeCommand(extractFileSync, extractFile, opt => new UnpackSync(opt), opt => new Unpack(opt), (opt, files) => {\n    if (files?.length)\n        filesFilter(opt, files);\n});\n//# sourceMappingURL=extract.js.map","// tar -r\nimport { WriteStream, WriteStreamSync } from '@isaacs/fs-minipass';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { Header } from './header.js';\nimport { list } from './list.js';\nimport { makeCommand } from './make-command.js';\nimport { isFile, } from './options.js';\nimport { Pack, PackSync } from './pack.js';\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\nconst replaceSync = (opt, files) => {\n    const p = new PackSync(opt);\n    let threw = true;\n    let fd;\n    let position;\n    try {\n        try {\n            fd = fs.openSync(opt.file, 'r+');\n        }\n        catch (er) {\n            if (er?.code === 'ENOENT') {\n                fd = fs.openSync(opt.file, 'w+');\n            }\n            else {\n                throw er;\n            }\n        }\n        const st = fs.fstatSync(fd);\n        const headBuf = Buffer.alloc(512);\n        POSITION: for (position = 0; position < st.size; position += 512) {\n            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n                bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n                if (position === 0 &&\n                    headBuf[0] === 0x1f &&\n                    headBuf[1] === 0x8b) {\n                    throw new Error('cannot append to compressed archives');\n                }\n                if (!bytes) {\n                    break POSITION;\n                }\n            }\n            const h = new Header(headBuf);\n            if (!h.cksumValid) {\n                break;\n            }\n            const entryBlockSize = 512 * Math.ceil((h.size || 0) / 512);\n            if (position + entryBlockSize + 512 > st.size) {\n                break;\n            }\n            // the 512 for the header we just parsed will be added as well\n            // also jump ahead all the blocks for the body\n            position += entryBlockSize;\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n        }\n        threw = false;\n        streamSync(opt, p, position, fd, files);\n    }\n    finally {\n        if (threw) {\n            try {\n                fs.closeSync(fd);\n            }\n            catch (er) { }\n        }\n    }\n};\nconst streamSync = (opt, p, position, fd, files) => {\n    const stream = new WriteStreamSync(opt.file, {\n        fd: fd,\n        start: position,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst replaceAsync = (opt, files) => {\n    files = Array.from(files);\n    const p = new Pack(opt);\n    const getPos = (fd, size, cb_) => {\n        const cb = (er, pos) => {\n            if (er) {\n                fs.close(fd, _ => cb_(er));\n            }\n            else {\n                cb_(null, pos);\n            }\n        };\n        let position = 0;\n        if (size === 0) {\n            return cb(null, 0);\n        }\n        let bufPos = 0;\n        const headBuf = Buffer.alloc(512);\n        const onread = (er, bytes) => {\n            if (er || typeof bytes === 'undefined') {\n                return cb(er);\n            }\n            bufPos += bytes;\n            if (bufPos < 512 && bytes) {\n                return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n            }\n            if (position === 0 &&\n                headBuf[0] === 0x1f &&\n                headBuf[1] === 0x8b) {\n                return cb(new Error('cannot append to compressed archives'));\n            }\n            // truncated header\n            if (bufPos < 512) {\n                return cb(null, position);\n            }\n            const h = new Header(headBuf);\n            if (!h.cksumValid) {\n                return cb(null, position);\n            }\n            /* c8 ignore next */\n            const entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512);\n            if (position + entryBlockSize + 512 > size) {\n                return cb(null, position);\n            }\n            position += entryBlockSize + 512;\n            if (position >= size) {\n                return cb(null, position);\n            }\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n            bufPos = 0;\n            fs.read(fd, headBuf, 0, 512, position, onread);\n        };\n        fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n    const promise = new Promise((resolve, reject) => {\n        p.on('error', reject);\n        let flag = 'r+';\n        const onopen = (er, fd) => {\n            if (er && er.code === 'ENOENT' && flag === 'r+') {\n                flag = 'w+';\n                return fs.open(opt.file, flag, onopen);\n            }\n            if (er || !fd) {\n                return reject(er);\n            }\n            fs.fstat(fd, (er, st) => {\n                if (er) {\n                    return fs.close(fd, () => reject(er));\n                }\n                getPos(fd, st.size, (er, position) => {\n                    if (er) {\n                        return reject(er);\n                    }\n                    const stream = new WriteStream(opt.file, {\n                        fd: fd,\n                        start: position,\n                    });\n                    p.pipe(stream);\n                    stream.on('error', reject);\n                    stream.on('close', resolve);\n                    addFilesAsync(p, files);\n                });\n            });\n        };\n        fs.open(opt.file, flag, onopen);\n    });\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            list({\n                file: path.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await list({\n                file: path.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nexport const replace = makeCommand(replaceSync, replaceAsync, \n/* c8 ignore start */\n() => {\n    throw new TypeError('file is required');\n}, () => {\n    throw new TypeError('file is required');\n}, \n/* c8 ignore stop */\n(opt, entries) => {\n    if (!isFile(opt)) {\n        throw new TypeError('file is required');\n    }\n    if (opt.gzip ||\n        opt.brotli ||\n        opt.zstd ||\n        opt.file.endsWith('.br') ||\n        opt.file.endsWith('.tbr')) {\n        throw new TypeError('cannot append to compressed archives');\n    }\n    if (!entries?.length) {\n        throw new TypeError('no paths specified to add/replace');\n    }\n});\n//# sourceMappingURL=replace.js.map","// tar -u\nimport { makeCommand } from './make-command.js';\nimport { replace as r } from './replace.js';\n// just call tar.r with the filter and mtimeCache\nexport const update = makeCommand(r.syncFile, r.asyncFile, r.syncNoFile, r.asyncNoFile, (opt, entries = []) => {\n    r.validate?.(opt, entries);\n    mtimeFilter(opt);\n});\nconst mtimeFilter = (opt) => {\n    const filter = opt.filter;\n    if (!opt.mtimeCache) {\n        opt.mtimeCache = new Map();\n    }\n    opt.filter =\n        filter ?\n            (path, stat) => filter(path, stat) &&\n                !(\n                /* c8 ignore start */\n                ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                    (stat.mtime ?? 0))\n                /* c8 ignore stop */\n                )\n            : (path, stat) => !(\n            /* c8 ignore start */\n            ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                (stat.mtime ?? 0))\n            /* c8 ignore stop */\n            );\n};\n//# sourceMappingURL=update.js.map","/**\n * Git Repository Template Loader\n *\n * Downloads templates from git repositories without full git history.\n * Similar to degit - downloads tarball of latest commit.\n *\n * Supports:\n * - github:user/repo\n * - github:user/repo/subdir#ref\n * - gitlab:user/repo\n * - https://github.com/user/repo.git\n * - https://github.com/user/repo.git#ref:subdir\n * - git@github.com:user/repo.git#ref:subdir\n *\n * Subdirectory syntax:\n * - Shorthand: github:user/repo/path/to/subdir\n * - Full URL: https://github.com/user/repo.git#branch:path/to/subdir\n */\n\nimport { mkdir, rm } from 'node:fs/promises';\nimport https from 'node:https';\nimport { tmpdir } from 'node:os';\nimport { join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport { extract } from 'tar';\nimport type { TemplateConfig } from './template-loader.js';\n\n// Track temp directories for cleanup on process exit\nconst tempDirectories = new Set<string>();\nlet cleanupHandlersRegistered = false;\n\n/**\n * Register cleanup handlers for temporary directories\n * Ensures temp directories are removed on process termination\n */\nfunction registerCleanupHandlers() {\n  if (cleanupHandlersRegistered) return;\n  cleanupHandlersRegistered = true;\n\n  const cleanup = async () => {\n    if (tempDirectories.size === 0) return;\n\n    const dirs = Array.from(tempDirectories);\n    await Promise.all(\n      dirs.map(async (dir) => {\n        try {\n          await rm(dir, { recursive: true, force: true });\n          tempDirectories.delete(dir);\n        } catch (_error) {\n          // Ignore cleanup errors - directory may already be removed\n        }\n      }),\n    );\n  };\n\n  // Clean up on normal exit\n  process.on('exit', () => {\n    // Synchronous cleanup not ideal, but exit is synchronous\n    // Most cleanup happens via other handlers\n  });\n\n  // Clean up on termination signals\n  process.on('SIGINT', async () => {\n    await cleanup();\n    process.exit(130); // Standard exit code for SIGINT\n  });\n\n  process.on('SIGTERM', async () => {\n    await cleanup();\n    process.exit(143); // Standard exit code for SIGTERM\n  });\n\n  // Clean up on uncaught exceptions\n  process.on('uncaughtException', async (error) => {\n    await cleanup();\n    throw error;\n  });\n}\n\ninterface GitRepo {\n  host: 'github' | 'gitlab' | 'bitbucket';\n  user: string;\n  repo: string;\n  ref: string; // branch, tag, or commit\n  subdir?: string; // subdirectory within repo\n}\n\n/**\n * Parse git URL to repository information\n *\n * Supports subdirectories via:\n * - github:user/repo/subdir#ref\n * - https://github.com/user/repo.git#ref:subdir\n * - git@github.com:user/repo.git#ref:subdir\n */\nfunction parseGitUrl(url: string): GitRepo {\n  let host: 'github' | 'gitlab' | 'bitbucket';\n  let user: string;\n  let repo: string;\n  let ref = 'HEAD'; // default to latest\n  let subdir: string | undefined;\n\n  // Handle shorthand: github:user/repo/subdir#ref\n  if (url.startsWith('github:')) {\n    host = 'github';\n    const parts = url.slice(7).split('/');\n    user = parts[0];\n\n    // Check for ref in second part\n    const repoAndRef = parts[1]?.split('#') || ['', ''];\n    repo = repoAndRef[0];\n    if (repoAndRef[1]) ref = repoAndRef[1];\n\n    // Remaining parts are subdirectory\n    if (parts.length > 2) {\n      subdir = parts.slice(2).join('/');\n    }\n  } else if (url.startsWith('gitlab:')) {\n    host = 'gitlab';\n    const parts = url.slice(7).split('/');\n    user = parts[0];\n\n    const repoAndRef = parts[1]?.split('#') || ['', ''];\n    repo = repoAndRef[0];\n    if (repoAndRef[1]) ref = repoAndRef[1];\n\n    if (parts.length > 2) {\n      subdir = parts.slice(2).join('/');\n    }\n  } else if (url.startsWith('bitbucket:')) {\n    host = 'bitbucket';\n    const parts = url.slice(10).split('/');\n    user = parts[0];\n\n    const repoAndRef = parts[1]?.split('#') || ['', ''];\n    repo = repoAndRef[0];\n    if (repoAndRef[1]) ref = repoAndRef[1];\n\n    if (parts.length > 2) {\n      subdir = parts.slice(2).join('/');\n    }\n  }\n  // Handle HTTPS URLs\n  else if (url.includes('github.com')) {\n    host = 'github';\n    const match = url.match(/github\\.com[:/]([^/]+)\\/([^/.]+)/);\n    if (!match) throw new Error(`Invalid GitHub URL: ${url}`);\n    user = match[1];\n    repo = match[2].replace(/\\.git$/, '');\n\n    // Extract ref and subdir from hash: #ref:subdir or #ref\n    const refMatch = url.match(/#(.+)$/);\n    if (refMatch) {\n      const refParts = refMatch[1].split(':');\n      ref = refParts[0];\n      if (refParts[1]) subdir = refParts[1];\n    }\n  } else if (url.includes('gitlab.com')) {\n    host = 'gitlab';\n    const match = url.match(/gitlab\\.com[:/]([^/]+)\\/([^/.]+)/);\n    if (!match) throw new Error(`Invalid GitLab URL: ${url}`);\n    user = match[1];\n    repo = match[2].replace(/\\.git$/, '');\n\n    const refMatch = url.match(/#(.+)$/);\n    if (refMatch) {\n      const refParts = refMatch[1].split(':');\n      ref = refParts[0];\n      if (refParts[1]) subdir = refParts[1];\n    }\n  } else if (url.includes('bitbucket.org')) {\n    host = 'bitbucket';\n    const match = url.match(/bitbucket\\.org[:/]([^/]+)\\/([^/.]+)/);\n    if (!match) throw new Error(`Invalid Bitbucket URL: ${url}`);\n    user = match[1];\n    repo = match[2].replace(/\\.git$/, '');\n\n    const refMatch = url.match(/#(.+)$/);\n    if (refMatch) {\n      const refParts = refMatch[1].split(':');\n      ref = refParts[0];\n      if (refParts[1]) subdir = refParts[1];\n    }\n  } else {\n    throw new Error(`Unsupported git URL: ${url}`);\n  }\n\n  return { host, user, repo, ref, subdir };\n}\n\n/**\n * Get tarball URL for repository\n */\nfunction getTarballUrl(repo: GitRepo): string {\n  switch (repo.host) {\n    case 'github':\n      return `https://github.com/${repo.user}/${repo.repo}/archive/${repo.ref}.tar.gz`;\n    case 'gitlab':\n      return `https://gitlab.com/${repo.user}/${repo.repo}/-/archive/${repo.ref}/${repo.repo}-${repo.ref}.tar.gz`;\n    case 'bitbucket':\n      return `https://bitbucket.org/${repo.user}/${repo.repo}/get/${repo.ref}.tar.gz`;\n    default:\n      throw new Error(`Unsupported git host: ${repo.host}`);\n  }\n}\n\n/**\n * Validate redirect URL to prevent SSRF attacks\n * Only allow redirects to trusted git hosting services\n */\nfunction validateRedirectUrl(redirectUrl: string): void {\n  try {\n    const url = new URL(redirectUrl);\n\n    // Only allow HTTPS protocol\n    if (url.protocol !== 'https:') {\n      throw new Error(\n        `Invalid redirect protocol: ${url.protocol} (only https: allowed)`,\n      );\n    }\n\n    // Only allow trusted git hosting services\n    const trustedHosts = [\n      'github.com',\n      'www.github.com',\n      'codeload.github.com',\n      'gitlab.com',\n      'www.gitlab.com',\n      'bitbucket.org',\n      'www.bitbucket.org',\n    ];\n\n    if (!trustedHosts.includes(url.hostname)) {\n      throw new Error(`Redirect to untrusted host: ${url.hostname}`);\n    }\n\n    // Reject redirects to localhost or internal IPs\n    if (\n      url.hostname === 'localhost' ||\n      url.hostname === '127.0.0.1' ||\n      url.hostname.startsWith('192.168.') ||\n      url.hostname.startsWith('10.') ||\n      url.hostname.startsWith('172.')\n    ) {\n      throw new Error(\n        `Redirect to internal/local address not allowed: ${url.hostname}`,\n      );\n    }\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw new Error(`Invalid redirect URL format: ${redirectUrl}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Download and extract git repository tarball\n */\nasync function downloadTarball(url: string, dest: string): Promise<string> {\n  const REQUEST_TIMEOUT = 30000; // 30 seconds\n  const MAX_TARBALL_SIZE = 100 * 1024 * 1024; // 100 MB\n\n  return new Promise((resolve, reject) => {\n    let timedOut = false;\n    let receivedBytes = 0;\n\n    const req = https.get(url, (response) => {\n      // Handle redirects\n      if (response.statusCode === 301 || response.statusCode === 302) {\n        const redirectUrl = response.headers.location;\n        if (!redirectUrl) {\n          return reject(new Error('Redirect without location header'));\n        }\n\n        // Validate redirect URL before following\n        try {\n          validateRedirectUrl(redirectUrl);\n        } catch (error) {\n          return reject(error);\n        }\n\n        return downloadTarball(redirectUrl, dest).then(resolve, reject);\n      }\n\n      if (response.statusCode !== 200) {\n        return reject(\n          new Error(`Failed to download tarball: HTTP ${response.statusCode}`),\n        );\n      }\n\n      // Monitor response size\n      response.on('data', (chunk) => {\n        receivedBytes += chunk.length;\n        if (receivedBytes > MAX_TARBALL_SIZE) {\n          response.destroy(new Error('Tarball size exceeds limit'));\n        }\n      });\n\n      // Extract tarball to destination\n      const extractStream = extract({\n        cwd: dest,\n        strip: 1, // Remove top-level directory from tarball\n      });\n\n      response.pipe(extractStream);\n\n      extractStream.on('finish', () => resolve(dest));\n      extractStream.on('error', (err) => {\n        response.destroy();\n        reject(err);\n      });\n    });\n\n    req.setTimeout(REQUEST_TIMEOUT, () => {\n      timedOut = true;\n      req.destroy(new Error('Request timed out'));\n    });\n\n    req.on('error', (err) => {\n      if (timedOut) {\n        reject(new Error('Request timed out'));\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n\n/**\n * Load template from git repository\n */\nexport async function loadGitTemplate(gitUrl: string): Promise<TemplateConfig> {\n  // Register cleanup handlers (only once)\n  registerCleanupHandlers();\n\n  // Parse git URL\n  const repo = parseGitUrl(gitUrl);\n\n  // Create temporary directory\n  const tempDir = join(\n    tmpdir(),\n    `smrt-template-${repo.user}-${repo.repo}-${Date.now()}`,\n  );\n  await mkdir(tempDir, { recursive: true });\n\n  // Track temp directory for cleanup\n  tempDirectories.add(tempDir);\n\n  try {\n    // Download and extract tarball\n    const tarballUrl = getTarballUrl(repo);\n    console.log(\n      `Downloading template from ${repo.host}:${repo.user}/${repo.repo}...`,\n    );\n    await downloadTarball(tarballUrl, tempDir);\n\n    // Load template config\n    const templateDir = repo.subdir ? join(tempDir, repo.subdir) : tempDir;\n    const configPath = join(templateDir, 'template.config.js');\n\n    // Try to load config\n    try {\n      const configUrl = pathToFileURL(configPath).href;\n      const module = await import(configUrl);\n      const config = module.default || module;\n\n      // Validate\n      validateTemplateConfig(config, configPath);\n\n      // Store temp directory in config for later cleanup\n      (config as any).__tempDir = tempDir;\n\n      return config;\n    } catch (_error) {\n      // Try .ts extension\n      try {\n        const tsConfigPath = join(templateDir, 'template.config.ts');\n        const configUrl = pathToFileURL(tsConfigPath).href;\n        const module = await import(configUrl);\n        const config = module.default || module;\n\n        validateTemplateConfig(config, tsConfigPath);\n        (config as any).__tempDir = tempDir;\n\n        return config;\n      } catch {\n        throw new Error(\n          `No template.config.js or template.config.ts found in ${gitUrl}`,\n        );\n      }\n    }\n  } catch (error) {\n    // Cleanup temp directory on error\n    await rm(tempDir, { recursive: true, force: true });\n    throw error;\n  }\n}\n\n/**\n * Get the template directory path (for copying overlay files)\n */\nexport function getGitTemplateDir(config: TemplateConfig): string {\n  const tempDir = (config as any).__tempDir;\n  if (!tempDir) {\n    throw new Error('Template was not loaded from git repository');\n  }\n  return tempDir;\n}\n\n/**\n * Cleanup temporary directory after template is used\n */\nexport async function cleanupGitTemplate(\n  config: TemplateConfig,\n): Promise<void> {\n  const tempDir = (config as any).__tempDir;\n  if (tempDir) {\n    await rm(tempDir, { recursive: true, force: true });\n  }\n}\n\n/**\n * Validate template configuration has required fields\n */\nfunction validateTemplateConfig(config: any, source: string): void {\n  const required = ['name', 'description', 'dependencies'];\n\n  for (const field of required) {\n    if (!config[field]) {\n      throw new Error(\n        `Invalid template config at ${source}: missing required field '${field}'`,\n      );\n    }\n  }\n\n  if (typeof config.dependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'dependencies' must be an object`,\n    );\n  }\n\n  if (config.devDependencies && typeof config.devDependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'devDependencies' must be an object`,\n    );\n  }\n}\n","/**\n * Local Filesystem Template Loader\n *\n * Loads templates from local directories.\n * Useful for development and testing.\n */\n\nimport { access } from 'node:fs/promises';\nimport { homedir } from 'node:os';\nimport { join, resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport type { TemplateConfig } from './template-loader.js';\n\n/**\n * Expand home directory (~) in paths\n * Handles both ~/ and ~ patterns\n */\nfunction expandHomeDirectory(path: string): string {\n  if (path.startsWith('~/')) {\n    return join(homedir(), path.slice(2));\n  }\n  if (path.startsWith('~')) {\n    return join(homedir(), path.slice(1));\n  }\n  return path;\n}\n\n/**\n * Validate resolved path to prevent path traversal attacks\n * Focuses on blocking access to sensitive system directories\n * while allowing legitimate parent directory navigation (e.g., ../sibling-dir)\n */\nfunction validateResolvedPath(\n  absolutePath: string,\n  originalPath: string,\n): void {\n  const home = homedir();\n\n  // Check if path contains null bytes (common path traversal technique)\n  if (absolutePath.includes('\\0') || originalPath.includes('\\0')) {\n    throw new Error(\n      'Path contains null bytes (potential path traversal attempt)',\n    );\n  }\n\n  // For home directory paths, ensure they stay within home directory\n  // This is stricter because ~ explicitly means \"home directory\"\n  if (originalPath.startsWith('~')) {\n    const normalizedPath = resolve(absolutePath);\n    const normalizedHome = resolve(home);\n\n    if (!normalizedPath.startsWith(normalizedHome)) {\n      throw new Error(\n        `Path traversal detected: resolved path \"${normalizedPath}\" escapes home directory \"${normalizedHome}\"`,\n      );\n    }\n  }\n\n  // Reject paths that resolve to sensitive system directories\n  // This is the primary defense against malicious path traversal\n  const sensitivePaths = [\n    '/etc',\n    '/proc',\n    '/sys',\n    '/dev',\n    '/boot',\n    '/root',\n    '/var/log',\n  ];\n  const normalizedPath = resolve(absolutePath);\n\n  for (const sensitivePath of sensitivePaths) {\n    if (\n      normalizedPath === sensitivePath ||\n      normalizedPath.startsWith(`${sensitivePath}/`)\n    ) {\n      throw new Error(\n        `Access to sensitive system directory not allowed: ${sensitivePath}`,\n      );\n    }\n  }\n\n  // Block paths that attempt to access system binaries\n  if (\n    normalizedPath.startsWith('/bin/') ||\n    normalizedPath.startsWith('/sbin/') ||\n    normalizedPath.startsWith('/usr/bin/') ||\n    normalizedPath.startsWith('/usr/sbin/')\n  ) {\n    throw new Error('Access to system binary directories not allowed');\n  }\n}\n\n/**\n * Resolve local path to absolute path\n *\n * Handles:\n * - Relative paths (./path, ../path)\n * - Absolute paths (/path)\n * - Home directory (~/)\n *\n * Includes path traversal protection to prevent malicious paths\n */\nexport async function resolveLocalPath(localPath: string): Promise<string> {\n  let absolutePath: string;\n\n  // Expand home directory (~) if present\n  if (localPath.startsWith('~')) {\n    absolutePath = expandHomeDirectory(localPath);\n  } else if (localPath.startsWith('/')) {\n    // Already absolute\n    absolutePath = localPath;\n  } else {\n    // Relative to current working directory\n    absolutePath = resolve(process.cwd(), localPath);\n  }\n\n  // Validate path for traversal attacks\n  validateResolvedPath(absolutePath, localPath);\n\n  // Verify directory exists\n  try {\n    await access(absolutePath);\n  } catch {\n    throw new Error(`Local template path does not exist: ${absolutePath}`);\n  }\n\n  return absolutePath;\n}\n\n/**\n * Load template configuration from local directory\n */\nexport async function loadLocalTemplate(\n  resolvedPath: string,\n): Promise<TemplateConfig> {\n  // Look for template.config.{js,ts}\n  let configPath: string | null = null;\n\n  for (const ext of ['js', 'ts']) {\n    const testPath = join(resolvedPath, `template.config.${ext}`);\n    try {\n      await access(testPath);\n      configPath = testPath;\n      break;\n    } catch {\n      // Try next extension\n    }\n  }\n\n  if (!configPath) {\n    throw new Error(\n      `No template.config.js or template.config.ts found in ${resolvedPath}`,\n    );\n  }\n\n  // Load the configuration\n  try {\n    const configUrl = pathToFileURL(configPath).href;\n    const module = await import(configUrl);\n    const config = module.default || module;\n\n    // Validate required fields\n    validateTemplateConfig(config, configPath);\n\n    return config;\n  } catch (error) {\n    throw new Error(\n      `Failed to load template config from ${configPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\n/**\n * Validate template configuration has required fields\n */\nfunction validateTemplateConfig(config: any, source: string): void {\n  const required = ['name', 'description', 'dependencies'];\n\n  for (const field of required) {\n    if (!config[field]) {\n      throw new Error(\n        `Invalid template config at ${source}: missing required field '${field}'`,\n      );\n    }\n  }\n\n  if (typeof config.dependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'dependencies' must be an object`,\n    );\n  }\n\n  if (config.devDependencies && typeof config.devDependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'devDependencies' must be an object`,\n    );\n  }\n}\n","/**\n * NPM Package Template Loader\n *\n * Loads templates from installed npm packages.\n * Supports package exports for template discovery.\n */\n\nimport { access, readFile } from 'node:fs/promises';\nimport { dirname, join, resolve } from 'node:path';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport glob from 'fast-glob';\nimport type { TemplateConfig } from './template-loader.js';\n\n/**\n * Resolve npm package path to template configuration\n *\n * Examples:\n * - @happyvertical/praeco/templates/sveltekit\n * - @org/templates\n * - my-template-package\n */\nexport async function resolveNpmPackage(packagePath: string): Promise<string> {\n  // Try to resolve as module\n  try {\n    const resolved = require.resolve(packagePath, {\n      paths: [process.cwd(), ...module.paths],\n    });\n    return resolved;\n  } catch {\n    // If not found, try looking in node_modules directly\n    const nodeModulesPath = join(process.cwd(), 'node_modules', packagePath);\n    try {\n      await access(nodeModulesPath);\n      return nodeModulesPath;\n    } catch {\n      throw new Error(\n        `npm package '${packagePath}' not found. Install with: npm install ${packagePath.split('/')[0]}`,\n      );\n    }\n  }\n}\n\n/**\n * Load template configuration from npm package\n */\nexport async function loadNpmTemplate(\n  resolvedPath: string,\n): Promise<TemplateConfig> {\n  let configPath: string;\n\n  // Check if resolved path is a template.config.js/ts file\n  if (\n    resolvedPath.endsWith('template.config.js') ||\n    resolvedPath.endsWith('template.config.ts')\n  ) {\n    configPath = resolvedPath;\n  } else {\n    // Look for template.config.{js,ts} in the resolved directory\n    const dir = resolvedPath.endsWith('.js')\n      ? dirname(resolvedPath)\n      : resolvedPath;\n\n    try {\n      configPath = join(dir, 'template.config.js');\n      await access(configPath);\n    } catch {\n      try {\n        configPath = join(dir, 'template.config.ts');\n        await access(configPath);\n      } catch {\n        throw new Error(\n          `No template.config.js or template.config.ts found in ${dir}`,\n        );\n      }\n    }\n  }\n\n  // Load the configuration\n  try {\n    const configUrl = pathToFileURL(configPath).href;\n    const module = await import(configUrl);\n    const config = module.default || module;\n\n    // Validate required fields\n    validateTemplateConfig(config, configPath);\n\n    return config;\n  } catch (error) {\n    throw new Error(\n      `Failed to load template config from ${configPath}: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\n/**\n * Find template by short name in installed packages\n *\n * Searches for:\n * - Scoped packages with templates directory\n * - Scoped packages direct\n * - Unscoped packages\n */\nexport async function findTemplateInPackages(\n  shortName: string,\n): Promise<string | null> {\n  const nodeModulesPath = join(process.cwd(), 'node_modules');\n\n  // Search patterns\n  const patterns = [\n    // Scoped packages with templates directory\n    `${nodeModulesPath}/@*/templates/${shortName}/template.config.{js,ts}`,\n    // Scoped packages direct\n    `${nodeModulesPath}/@*/${shortName}/template.config.{js,ts}`,\n    // Unscoped packages\n    `${nodeModulesPath}/${shortName}/template.config.{js,ts}`,\n    // Templates subdirectory in any package\n    `${nodeModulesPath}/*/templates/${shortName}/template.config.{js,ts}`,\n  ];\n\n  for (const pattern of patterns) {\n    const matches = await glob(pattern, { absolute: true });\n    if (matches.length > 0) {\n      // Return the package path, not the template.config path\n      const configPath = matches[0];\n      return dirname(configPath);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Discover all templates in installed packages\n *\n * Useful for `smrt gnode list-templates` command\n */\nexport async function discoverInstalledTemplates(): Promise<\n  Array<{ name: string; source: string; config: TemplateConfig }>\n> {\n  const nodeModulesPath = join(process.cwd(), 'node_modules');\n\n  const patterns = [\n    `${nodeModulesPath}/@*/templates/*/template.config.{js,ts}`,\n    `${nodeModulesPath}/*/template.config.{js,ts}`,\n  ];\n\n  const templates: Array<{\n    name: string;\n    source: string;\n    config: TemplateConfig;\n  }> = [];\n\n  for (const pattern of patterns) {\n    const matches = await glob(pattern, { absolute: true });\n\n    for (const configPath of matches) {\n      try {\n        const configUrl = pathToFileURL(configPath).href;\n        const module = await import(configUrl);\n        const config = module.default || module;\n\n        // Extract package name from path\n        const relativePath = configPath.replace(nodeModulesPath + '/', '');\n        const source = relativePath.substring(\n          0,\n          relativePath.indexOf('/template.config'),\n        );\n\n        templates.push({\n          name: config.name || 'unknown',\n          source,\n          config,\n        });\n      } catch (error) {\n        // Skip templates that fail to load\n        console.warn(`Failed to load template at ${configPath}:`, error);\n      }\n    }\n  }\n\n  return templates;\n}\n\n/**\n * Validate template configuration has required fields\n */\nfunction validateTemplateConfig(config: any, source: string): void {\n  const required = ['name', 'description', 'dependencies'];\n\n  for (const field of required) {\n    if (!config[field]) {\n      throw new Error(\n        `Invalid template config at ${source}: missing required field '${field}'`,\n      );\n    }\n  }\n\n  if (typeof config.dependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'dependencies' must be an object`,\n    );\n  }\n\n  if (config.devDependencies && typeof config.devDependencies !== 'object') {\n    throw new Error(\n      `Invalid template config at ${source}: 'devDependencies' must be an object`,\n    );\n  }\n}\n","/**\n * Template Loader - Resolves and loads templates from various sources\n *\n * Supports:\n * - npm packages (@org/pkg/templates/name)\n * - Git repositories (github:user/repo, https://github.com/user/repo.git)\n * - Local filesystem paths (../path/to/template, /absolute/path)\n */\n\nimport { loadGitTemplate } from './git-loader.js';\nimport { loadLocalTemplate, resolveLocalPath } from './local-loader.js';\nimport {\n  findTemplateInPackages,\n  loadNpmTemplate,\n  resolveNpmPackage,\n} from './npm-loader.js';\n\nexport interface TemplateConfig {\n  name: string;\n  description: string;\n  framework: string;\n  baseGenerator?: {\n    command: string;\n    args: string[];\n    skipPrompts?: boolean;\n  };\n  dependencies: Record<string, string>;\n  devDependencies: Record<string, string>;\n}\n\nexport interface TemplateSource {\n  type: 'npm' | 'git' | 'local';\n  location: string;\n  resolved: string;\n}\n\n/**\n * Resolve a template name to a specific source\n *\n * @param name - Template name or path\n *   - @org/pkg/templates/name (npm package)\n *   - github:user/repo (git shorthand)\n *   - https://github.com/user/repo.git (git URL)\n *   - ../path/to/template (local path)\n *   - short-name (searches installed packages)\n *\n * @returns Template source information\n */\nexport async function resolveTemplate(name: string): Promise<TemplateSource> {\n  // Check for git repository first (most specific)\n  if (\n    name.startsWith('github:') ||\n    name.startsWith('gitlab:') ||\n    name.startsWith('git@') ||\n    name.endsWith('.git') ||\n    name.startsWith('https://github.com') ||\n    name.startsWith('https://gitlab.com')\n  ) {\n    return {\n      type: 'git',\n      location: name,\n      resolved: name,\n    };\n  }\n\n  // Check for local filesystem path (before npm to avoid matching ./ and ~/)\n  if (name.startsWith('/') || name.startsWith('.') || name.startsWith('~')) {\n    return {\n      type: 'local',\n      location: name,\n      resolved: await resolveLocalPath(name),\n    };\n  }\n\n  // Check for npm package (contains @ or /)\n  if (name.includes('@') || name.includes('/')) {\n    return {\n      type: 'npm',\n      location: name,\n      resolved: await resolveNpmPackage(name),\n    };\n  }\n\n  // Short name - search installed packages\n  const npmPath = await findTemplateInPackages(name);\n  if (npmPath) {\n    return {\n      type: 'npm',\n      location: npmPath,\n      resolved: await resolveNpmPackage(npmPath),\n    };\n  }\n\n  throw new Error(\n    `Template '${name}' not found. Tried:\\n` +\n      `  - npm package: @*/${name}, @*/templates/${name}\\n` +\n      `  - local path: ./${name}, ../${name}\\n` +\n      `\\n` +\n      `Use one of:\\n` +\n      `  - npm package: @org/pkg/templates/name\\n` +\n      `  - git repo: github:user/repo\\n` +\n      `  - local path: ../path/to/template`,\n  );\n}\n\n/**\n * Load template configuration from resolved source\n */\nexport async function loadTemplate(\n  source: TemplateSource,\n): Promise<TemplateConfig> {\n  switch (source.type) {\n    case 'npm':\n      return loadNpmTemplate(source.resolved);\n    case 'git':\n      return loadGitTemplate(source.resolved);\n    case 'local':\n      return loadLocalTemplate(source.resolved);\n    default:\n      throw new Error(`Unknown template type: ${source.type}`);\n  }\n}\n","/**\n * Template Generator Utilities\n *\n * Handles template instantiation:\n * - Run base generators (SvelteKit, Next.js, etc.)\n * - Overlay template files\n * - Merge package.json dependencies\n */\n\nimport { spawn } from 'node:child_process';\nimport { cp, mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { dirname, join } from 'node:path';\nimport glob from 'fast-glob';\nimport type { TemplateConfig, TemplateSource } from '../loaders/index.js';\n\nexport interface GeneratorOptions {\n  template: string;\n  name: string;\n  outputDir: string;\n}\n\n/**\n * Generate project from template\n */\nexport async function generate(\n  source: TemplateSource,\n  config: TemplateConfig,\n  options: GeneratorOptions,\n): Promise<void> {\n  console.log(`\\n🏗️  Creating gnode: ${options.name}`);\n  console.log(`📦 Using template: ${config.name} (${config.description})\\n`);\n\n  // Step 1: Run base generator if specified\n  if (config.baseGenerator) {\n    console.log(`📝 Running base generator (${config.framework})...`);\n    await runBaseGenerator(config.baseGenerator, options.outputDir);\n  } else {\n    // Create directory if no base generator\n    await mkdir(options.outputDir, { recursive: true });\n  }\n\n  // Step 2: Overlay template files\n  console.log('📋 Copying template files...');\n  await overlayTemplate(source, config, options.outputDir);\n\n  // Step 3: Merge package.json\n  console.log('🔧 Configuring package.json...');\n  await mergePackageJson(options.outputDir, config, options.name);\n\n  console.log('\\n✅ Gnode created successfully!');\n  console.log(`\\n📍 Next steps:`);\n  console.log(`   cd ${options.name}`);\n  console.log(`   pnpm install`);\n  console.log(`   pnpm dev\\n`);\n}\n\n/**\n * Validate base generator configuration to prevent command injection\n */\nfunction validateBaseGenerator(\n  baseGen: NonNullable<TemplateConfig['baseGenerator']>,\n  outputDir: string,\n): void {\n  // Whitelist of allowed base generator commands\n  const allowedCommands = ['npm', 'npx', 'pnpm', 'yarn', 'bun', 'bunx'];\n\n  if (!allowedCommands.includes(baseGen.command)) {\n    throw new Error(\n      `Base generator command \"${baseGen.command}\" not allowed. ` +\n        `Allowed commands: ${allowedCommands.join(', ')}`,\n    );\n  }\n\n  // Validate outputDir doesn't contain shell metacharacters\n  const dangerousChars = /[;&|`$(){}[\\]<>'\"\\\\]/;\n  if (dangerousChars.test(outputDir)) {\n    throw new Error(\n      `Output directory contains dangerous characters: ${outputDir}. ` +\n        `Only alphanumeric, dash, underscore, dot, and forward slash are allowed.`,\n    );\n  }\n\n  // Validate all arguments after {DIR} replacement\n  for (const arg of baseGen.args) {\n    // Replace {DIR} placeholder first\n    const replacedArg = arg.replace('{DIR}', outputDir);\n\n    // Then check for command injection patterns in the replaced argument\n    if (dangerousChars.test(replacedArg)) {\n      throw new Error(\n        `Base generator argument contains dangerous characters after placeholder replacement: ${replacedArg}`,\n      );\n    }\n  }\n}\n\n/**\n * Run base project generator (e.g., create-svelte, create-next-app)\n *\n * Security: Command and arguments are validated to prevent injection attacks.\n * shell: true is NOT used to avoid command injection vulnerabilities.\n */\nasync function runBaseGenerator(\n  baseGen: NonNullable<TemplateConfig['baseGenerator']>,\n  outputDir: string,\n): Promise<void> {\n  // Validate configuration before executing\n  validateBaseGenerator(baseGen, outputDir);\n\n  // Replace {DIR} placeholder in arguments\n  const args = baseGen.args.map((arg) => arg.replace('{DIR}', outputDir));\n\n  return new Promise((resolve, reject) => {\n    // Do NOT use shell: true to prevent command injection\n    const proc = spawn(baseGen.command, args, {\n      stdio: 'inherit',\n      shell: false,\n    });\n\n    proc.on('close', (code) => {\n      if (code === 0) {\n        resolve();\n      } else {\n        reject(new Error(`Base generator exited with code ${code}`));\n      }\n    });\n\n    proc.on('error', reject);\n  });\n}\n\n/**\n * Overlay template files onto generated project\n */\nasync function overlayTemplate(\n  source: TemplateSource,\n  config: TemplateConfig,\n  outputDir: string,\n): Promise<void> {\n  // Determine overlay directory based on source type\n  let overlayDir: string;\n\n  switch (source.type) {\n    case 'npm':\n      overlayDir = join(dirname(source.resolved), 'overlay');\n      break;\n    case 'git': {\n      // For git templates, the temp directory is stored in config\n      const tempDir = (config as any).__tempDir;\n      if (!tempDir) {\n        throw new Error('Git template temp directory not found');\n      }\n      overlayDir = join(tempDir, 'overlay');\n      break;\n    }\n    case 'local':\n      overlayDir = join(source.resolved, 'overlay');\n      break;\n    default:\n      throw new Error(`Unknown source type: ${source.type}`);\n  }\n\n  // Find all files in overlay directory\n  const files = await glob('**/*', {\n    cwd: overlayDir,\n    dot: true,\n    onlyFiles: true,\n  });\n\n  // Copy each file\n  for (const file of files) {\n    const src = join(overlayDir, file);\n    const dest = join(outputDir, file);\n\n    // Ensure directory exists\n    await mkdir(dirname(dest), { recursive: true });\n\n    // Copy file\n    await cp(src, dest);\n  }\n}\n\n/**\n * Merge template dependencies into package.json\n */\nasync function mergePackageJson(\n  outputDir: string,\n  config: TemplateConfig,\n  projectName: string,\n): Promise<void> {\n  const pkgPath = join(outputDir, 'package.json');\n\n  let pkg: any;\n  try {\n    const content = await readFile(pkgPath, 'utf-8');\n    pkg = JSON.parse(content);\n  } catch {\n    // If no package.json exists, create one\n    pkg = {\n      name: projectName,\n      version: '0.1.0',\n      private: true,\n      scripts: {},\n      dependencies: {},\n      devDependencies: {},\n    };\n  }\n\n  // Update name\n  pkg.name = projectName;\n\n  // Merge dependencies\n  pkg.dependencies = {\n    ...pkg.dependencies,\n    ...config.dependencies,\n  };\n\n  pkg.devDependencies = {\n    ...pkg.devDependencies,\n    ...config.devDependencies,\n  };\n\n  // Add gnode-specific scripts if not present\n  if (!pkg.scripts['workflow:research']) {\n    pkg.scripts = {\n      ...pkg.scripts,\n      'workflow:research': 'tsx src/workflows/research.ts',\n      'workflow:report': 'tsx src/workflows/report.ts',\n    };\n  }\n\n  // Write back\n  await writeFile(pkgPath, JSON.stringify(pkg, null, 2) + '\\n');\n}\n","/**\n * Gnode CLI Commands\n *\n * Commands for creating and managing gnodes (federated local knowledge bases)\n */\n\nimport type { CLICommand } from '../../generators/cli.js';\nimport {\n  cleanupGitTemplate,\n  discoverInstalledTemplates,\n  loadTemplate,\n  resolveTemplate,\n} from '../loaders/index.js';\nimport { generate } from '../utils/generator.js';\n\n/**\n * Gnode commands for CLI\n */\nexport const gnodeCommands: Record<string, CLICommand> = {\n  'gnode create': {\n    name: 'gnode create',\n    description: 'Create a new gnode from template',\n    args: ['name'],\n    options: {\n      template: {\n        type: 'string',\n        description: 'Template to use (npm package, git repo, or local path)',\n        default: 'sveltekit',\n      },\n      'output-dir': {\n        type: 'string',\n        description: 'Output directory (defaults to ./<name>)',\n      },\n    },\n    handler: async (args: string[], options: any) => {\n      const name = args[0];\n      if (!name) {\n        throw new Error('Project name is required: smrt gnode create <name>');\n      }\n\n      const outputDir = options.outputDir || `./${name}`;\n      const templateName = options.template || 'sveltekit';\n\n      try {\n        // Resolve template source\n        console.log(`🔍 Resolving template: ${templateName}...`);\n        const source = await resolveTemplate(templateName);\n        console.log(`✓ Found template: ${source.type}:${source.location}\\n`);\n\n        // Load template configuration\n        const config = await loadTemplate(source);\n\n        // Generate project\n        await generate(source, config, {\n          name,\n          template: templateName,\n          outputDir,\n        });\n\n        // Cleanup git template if needed\n        if (source.type === 'git') {\n          await cleanupGitTemplate(config);\n        }\n      } catch (error) {\n        throw new Error(\n          `Failed to create gnode: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          { cause: error },\n        );\n      }\n    },\n  },\n\n  'gnode list-templates': {\n    name: 'gnode list-templates',\n    description: 'List available gnode templates',\n    aliases: ['gnode ls'],\n    handler: async (_args: string[], _options: any) => {\n      console.log('📦 Discovering installed templates...\\n');\n\n      const templates = await discoverInstalledTemplates();\n\n      if (templates.length === 0) {\n        console.log('No templates found in node_modules.');\n        console.log(\n          '\\nTo use a template, install a package that provides one:',\n        );\n        console.log('  npm install @happyvertical/praeco');\n        console.log('\\nOr use a git repository:');\n        console.log('  smrt gnode create my-town --template=github:user/repo');\n        return;\n      }\n\n      console.log('Available templates:\\n');\n\n      for (const t of templates) {\n        console.log(`  ${t.name}`);\n        console.log(`    ${t.config.description}`);\n        console.log(`    Source: ${t.source}`);\n        console.log(`    Framework: ${t.config.framework || 'unknown'}`);\n        console.log();\n      }\n\n      console.log(`Found ${templates.length} template(s)\\n`);\n      console.log('Usage:');\n      console.log('  smrt gnode create <name> --template=<template-name>');\n      console.log('  smrt gnode create my-town --template=sveltekit');\n    },\n  },\n};\n"],"names":["EOF","READ","BUFFER","ABORTED","p","ret","resolve","res","realZlib","Buffer","noop","encode","parse","types.isCode","types.name","types.code","pathModule","large.parse","large.encode","platform","code","QUEUE","ENDED","EE","chunk","fs","pos","fsm.ReadStream","s","PROCESS","FILE","DIRECTORY","SYMLINK","HARDLINK","ONDRAIN","winchars.decode","path","list","zlib.Gzip","zlib.BrotliCompress","zlib.ZstdCompress","stat","addFilesSync","addFilesAsync","isWindows","er","created","fn","name","wc.encode","assert","fsm.WriteStream","checkCwd","fsm.ReadStreamSync","r","mkdir","module","validateTemplateConfig","normalizedPath","dirname","proc"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAYO,MAAM,mBAA+C;AAAA,EAC1D,kBAAkB;AAAA,IAChB,MAAM;AAAA,IACN,aAAa;AAAA,IACb,SAAS,CAAC,uBAAuB;AAAA,IACjC,MAAM,CAAC,eAAe;AAAA,IACtB,SAAS;AAAA,MACP,cAAc;AAAA,QACZ,MAAM;AAAA,QACN,aAAa;AAAA,MAAA;AAAA,IACf;AAAA,IAEF,SAAS,OAAO,MAAgB,YAAiB;AAC/C,YAAM,eAAe,KAAK,CAAC;AAC3B,UAAI,CAAC,cAAc;AACjB,cAAM,IAAI;AAAA,UACR;AAAA,QAAA;AAAA,MAEJ;AAEA,YAAM,YAAY,QAAQ,aAAa,KAAK,CAAC;AAE7C,UAAI;AACF,cAAM,UAAU,YAAY,CAAC,cAAc,SAAS,IAAI,CAAC,YAAY;AACrE,cAAM,4BAA4B,OAAO;AAAA,MAC3C,SAAS,OAAO;AACd,cAAM,IAAI;AAAA,UACR,6BAA6B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,QAAA;AAAA,MAEzF;AAAA,IACF;AAAA,EAAA;AAEJ;AC5CA,MAAM,OAAO,OAAO,YAAY,YAAY,UACtC,UACA;AAAA,EACE,QAAQ;AAAA,EACR,QAAQ;AAChB;AAQO,MAAM,WAAW,CAAC,MAAM,CAAC,CAAC,KAC7B,OAAO,MAAM,aACZ,aAAa,YACV,aAAa,UACb,WAAW,CAAC,KACZ,WAAW,CAAC;AAIb,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,KAC/B,OAAO,MAAM,YACb,aAAa,gBACb,OAAO,EAAE,SAAS;AAElB,EAAE,SAAS,OAAO,SAAS,UAAU;AAIlC,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,KAC/B,OAAO,MAAM,YACb,aAAa,gBACb,OAAO,EAAE,UAAU,cACnB,OAAO,EAAE,QAAQ;AACrB,MAAMA,QAAM,OAAO,KAAK;AACxB,MAAM,iBAAiB,OAAO,cAAc;AAC5C,MAAM,cAAc,OAAO,YAAY;AACvC,MAAM,eAAe,OAAO,aAAa;AACzC,MAAM,gBAAgB,OAAO,cAAc;AAC3C,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAMC,SAAO,OAAO,MAAM;AAC1B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAMC,WAAS,OAAO,QAAQ;AAC9B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,eAAe,OAAO,cAAc;AAC1C,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,cAAc,OAAO,aAAa;AACxC,MAAM,aAAa,OAAO,YAAY;AAEtC,MAAM,YAAY,OAAO,WAAW;AAEpC,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAMC,YAAU,OAAO,SAAS;AAChC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,gBAAgB,OAAO,eAAe;AAC5C,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,QAAQ,CAAC,OAAO,QAAQ,QAAO,EAAG,KAAK,EAAE;AAC/C,MAAM,UAAU,CAAC,OAAO,GAAE;AAC1B,MAAM,WAAW,CAAC,OAAO,OAAO,SAAS,OAAO,YAAY,OAAO;AACnE,MAAM,oBAAoB,CAAC,MAAM,aAAa,eACzC,CAAC,CAAC,KACC,OAAO,MAAM,YACb,EAAE,eACF,EAAE,YAAY,SAAS,iBACvB,EAAE,cAAc;AACxB,MAAM,oBAAoB,CAAC,MAAM,CAAC,OAAO,SAAS,CAAC,KAAK,YAAY,OAAO,CAAC;AAM5E,MAAM,KAAK;AAAA,EACP;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,KAAK,MAAM,MAAM;AACzB,SAAK,MAAM;AACX,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,UAAU,MAAM,IAAI,MAAM,EAAC;AAChC,SAAK,KAAK,GAAG,SAAS,KAAK,OAAO;AAAA,EACtC;AAAA,EACA,SAAS;AACL,SAAK,KAAK,eAAe,SAAS,KAAK,OAAO;AAAA,EAClD;AAAA;AAAA;AAAA,EAGA,YAAY,KAAK;AAAA,EAAE;AAAA;AAAA,EAEnB,MAAM;AACF,SAAK,OAAM;AACX,QAAI,KAAK,KAAK;AACV,WAAK,KAAK,IAAG;AAAA,EACrB;AACJ;AAOA,MAAM,wBAAwB,KAAK;AAAA,EAC/B,SAAS;AACL,SAAK,IAAI,eAAe,SAAS,KAAK,WAAW;AACjD,UAAM,OAAM;AAAA,EAChB;AAAA,EACA,YAAY,KAAK,MAAM,MAAM;AACzB,UAAM,KAAK,MAAM,IAAI;AACrB,SAAK,cAAc,QAAM,KAAK,KAAK,SAAS,EAAE;AAC9C,QAAI,GAAG,SAAS,KAAK,WAAW;AAAA,EACpC;AACJ;AACA,MAAM,sBAAsB,CAAC,MAAM,CAAC,CAAC,EAAE;AACvC,MAAM,oBAAoB,CAAC,MAAM,CAAC,EAAE,cAAc,CAAC,CAAC,EAAE,YAAY,EAAE,aAAa;AAY1E,MAAM,iBAAiB,aAAa;AAAA,EACvC,CAAC,OAAO,IAAI;AAAA,EACZ,CAAC,MAAM,IAAI;AAAA,EACX,CAAC,KAAK,IAAI,CAAA;AAAA,EACV,CAACD,QAAM,IAAI,CAAA;AAAA,EACX,CAAC,UAAU;AAAA,EACX,CAAC,QAAQ;AAAA,EACT,CAAC,KAAK;AAAA,EACN,CAAC,OAAO;AAAA,EACR,CAACF,KAAG,IAAI;AAAA,EACR,CAAC,WAAW,IAAI;AAAA,EAChB,CAAC,YAAY,IAAI;AAAA,EACjB,CAAC,MAAM,IAAI;AAAA,EACX,CAAC,aAAa,IAAI;AAAA,EAClB,CAAC,YAAY,IAAI;AAAA,EACjB,CAAC,SAAS,IAAI;AAAA,EACd,CAAC,MAAM;AAAA,EACP,CAACG,SAAO,IAAI;AAAA,EACZ,CAAC,aAAa,IAAI;AAAA,EAClB,CAAC,SAAS,IAAI;AAAA;AAAA;AAAA;AAAA,EAId,WAAW;AAAA;AAAA;AAAA;AAAA,EAIX,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOX,eAAe,MAAM;AACjB,UAAM,UAAW,KAAK,CAAC,KACnB;AACJ,UAAK;AACL,QAAI,QAAQ,cAAc,OAAO,QAAQ,aAAa,UAAU;AAC5D,YAAM,IAAI,UAAU,kDAAkD;AAAA,IAC1E;AACA,QAAI,oBAAoB,OAAO,GAAG;AAC9B,WAAK,UAAU,IAAI;AACnB,WAAK,QAAQ,IAAI;AAAA,IACrB,WACS,kBAAkB,OAAO,GAAG;AACjC,WAAK,QAAQ,IAAI,QAAQ;AACzB,WAAK,UAAU,IAAI;AAAA,IACvB,OACK;AACD,WAAK,UAAU,IAAI;AACnB,WAAK,QAAQ,IAAI;AAAA,IACrB;AACA,SAAK,KAAK,IAAI,CAAC,CAAC,QAAQ;AACxB,SAAK,OAAO,IAAI,KAAK,QAAQ,IACvB,IAAI,cAAc,KAAK,QAAQ,CAAC,IAChC;AAEN,QAAI,WAAW,QAAQ,sBAAsB,MAAM;AAC/C,aAAO,eAAe,MAAM,UAAU,EAAE,KAAK,MAAM,KAAKD,QAAM,GAAG;AAAA,IACrE;AAEA,QAAI,WAAW,QAAQ,qBAAqB,MAAM;AAC9C,aAAO,eAAe,MAAM,SAAS,EAAE,KAAK,MAAM,KAAK,KAAK,GAAG;AAAA,IACnE;AACA,UAAM,EAAE,OAAM,IAAK;AACnB,QAAI,QAAQ;AACR,WAAK,MAAM,IAAI;AACf,UAAI,OAAO,SAAS;AAChB,aAAK,KAAK,EAAC;AAAA,MACf,OACK;AACD,eAAO,iBAAiB,SAAS,MAAM,KAAK,KAAK,EAAC,CAAE;AAAA,MACxD;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,eAAe;AACf,WAAO,KAAK,YAAY;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,WAAW;AACX,WAAO,KAAK,QAAQ;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,SAAS,MAAM;AACf,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,MAAM;AACd,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,aAAa;AACb,WAAO,KAAK,UAAU;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,WAAW,KAAK;AAChB,UAAM,IAAI,MAAM,8CAA8C;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAIA,KAAK,OAAO,IAAI;AACZ,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,KAAK,OAAO,EAAE,GAAG;AACb,SAAK,KAAK,IAAI,KAAK,KAAK,KAAK,CAAC,CAAC;AAAA,EACnC;AAAA;AAAA,EAEA,CAAC,KAAK,IAAI;AACN,SAAKC,SAAO,IAAI;AAChB,SAAK,KAAK,SAAS,KAAK,MAAM,GAAG,MAAM;AACvC,SAAK,QAAQ,KAAK,MAAM,GAAG,MAAM;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,UAAU;AACV,WAAO,KAAKA,SAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,QAAQ,GAAG;AAAA,EAAE;AAAA,EACjB,MAAM,OAAO,UAAU,IAAI;AACvB,QAAI,KAAKA,SAAO;AACZ,aAAO;AACX,QAAI,KAAKH,KAAG;AACR,YAAM,IAAI,MAAM,iBAAiB;AACrC,QAAI,KAAK,SAAS,GAAG;AACjB,WAAK,KAAK,SAAS,OAAO,OAAO,IAAI,MAAM,gDAAgD,GAAG,EAAE,MAAM,uBAAsB,CAAE,CAAC;AAC/H,aAAO;AAAA,IACX;AACA,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AACA,QAAI,CAAC;AACD,iBAAW;AACf,UAAM,KAAK,KAAK,KAAK,IAAI,QAAQ;AAKjC,QAAI,CAAC,KAAK,UAAU,KAAK,CAAC,OAAO,SAAS,KAAK,GAAG;AAC9C,UAAI,kBAAkB,KAAK,GAAG;AAE1B,gBAAQ,OAAO,KAAK,MAAM,QAAQ,MAAM,YAAY,MAAM,UAAU;AAAA,MACxE,WACS,kBAAkB,KAAK,GAAG;AAE/B,gBAAQ,OAAO,KAAK,KAAK;AAAA,MAC7B,WACS,OAAO,UAAU,UAAU;AAChC,cAAM,IAAI,MAAM,sDAAsD;AAAA,MAC1E;AAAA,IACJ;AAGA,QAAI,KAAK,UAAU,GAAG;AAGlB,UAAI,KAAK,OAAO,KAAK,KAAK,YAAY,MAAM;AACxC,aAAK,KAAK,EAAE,IAAI;AAEpB,UAAI,KAAK,OAAO;AACZ,aAAK,KAAK,QAAQ,KAAK;AAAA;AAEvB,aAAK,UAAU,EAAE,KAAK;AAC1B,UAAI,KAAK,YAAY,MAAM;AACvB,aAAK,KAAK,UAAU;AACxB,UAAI;AACA,WAAG,EAAE;AACT,aAAO,KAAK,OAAO;AAAA,IACvB;AAGA,QAAI,CAAC,MAAM,QAAQ;AACf,UAAI,KAAK,YAAY,MAAM;AACvB,aAAK,KAAK,UAAU;AACxB,UAAI;AACA,WAAG,EAAE;AACT,aAAO,KAAK,OAAO;AAAA,IACvB;AAGA,QAAI,OAAO,UAAU;AAAA,IAEjB,EAAE,aAAa,KAAK,QAAQ,KAAK,CAAC,KAAK,OAAO,GAAG,WAAW;AAE5D,cAAQ,OAAO,KAAK,OAAO,QAAQ;AAAA,IACvC;AACA,QAAI,OAAO,SAAS,KAAK,KAAK,KAAK,QAAQ,GAAG;AAE1C,cAAQ,KAAK,OAAO,EAAE,MAAM,KAAK;AAAA,IACrC;AAEA,QAAI,KAAK,OAAO,KAAK,KAAK,YAAY,MAAM;AACxC,WAAK,KAAK,EAAE,IAAI;AACpB,QAAI,KAAK,OAAO;AACZ,WAAK,KAAK,QAAQ,KAAK;AAAA;AAEvB,WAAK,UAAU,EAAE,KAAK;AAC1B,QAAI,KAAK,YAAY,MAAM;AACvB,WAAK,KAAK,UAAU;AACxB,QAAI;AACA,SAAG,EAAE;AACT,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,KAAK,GAAG;AACJ,QAAI,KAAK,SAAS;AACd,aAAO;AACX,SAAK,SAAS,IAAI;AAClB,QAAI,KAAK,YAAY,MAAM,KACvB,MAAM,KACL,KAAK,IAAI,KAAK,YAAY,GAAI;AAC/B,WAAK,cAAc,EAAC;AACpB,aAAO;AAAA,IACX;AACA,QAAI,KAAK,UAAU;AACf,UAAI;AACR,QAAI,KAAKE,QAAM,EAAE,SAAS,KAAK,CAAC,KAAK,UAAU,GAAG;AAG9C,WAAKA,QAAM,IAAI;AAAA,QACV,KAAK,QAAQ,IACR,KAAKA,QAAM,EAAE,KAAK,EAAE,IACpB,OAAO,OAAO,KAAKA,QAAM,GAAG,KAAK,YAAY,CAAC;AAAA,MACpE;AAAA,IACQ;AACA,UAAM,MAAM,KAAKD,MAAI,EAAE,KAAK,MAAM,KAAKC,QAAM,EAAE,CAAC,CAAC;AACjD,SAAK,cAAc,EAAC;AACpB,WAAO;AAAA,EACX;AAAA,EACA,CAACD,MAAI,EAAE,GAAG,OAAO;AACb,QAAI,KAAK,UAAU;AACf,WAAK,WAAW,EAAC;AAAA,SAChB;AACD,YAAM,IAAI;AACV,UAAI,MAAM,EAAE,UAAU,MAAM;AACxB,aAAK,WAAW,EAAC;AAAA,eACZ,OAAO,MAAM,UAAU;AAC5B,aAAKC,QAAM,EAAE,CAAC,IAAI,EAAE,MAAM,CAAC;AAC3B,gBAAQ,EAAE,MAAM,GAAG,CAAC;AACpB,aAAK,YAAY,KAAK;AAAA,MAC1B,OACK;AACD,aAAKA,QAAM,EAAE,CAAC,IAAI,EAAE,SAAS,CAAC;AAC9B,gBAAQ,EAAE,SAAS,GAAG,CAAC;AACvB,aAAK,YAAY,KAAK;AAAA,MAC1B;AAAA,IACJ;AACA,SAAK,KAAK,QAAQ,KAAK;AACvB,QAAI,CAAC,KAAKA,QAAM,EAAE,UAAU,CAAC,KAAKF,KAAG;AACjC,WAAK,KAAK,OAAO;AACrB,WAAO;AAAA,EACX;AAAA,EACA,IAAI,OAAO,UAAU,IAAI;AACrB,QAAI,OAAO,UAAU,YAAY;AAC7B,WAAK;AACL,cAAQ;AAAA,IACZ;AACA,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AACA,QAAI,UAAU;AACV,WAAK,MAAM,OAAO,QAAQ;AAC9B,QAAI;AACA,WAAK,KAAK,OAAO,EAAE;AACvB,SAAKA,KAAG,IAAI;AACZ,SAAK,WAAW;AAKhB,QAAI,KAAK,OAAO,KAAK,CAAC,KAAK,MAAM;AAC7B,WAAK,cAAc,EAAC;AACxB,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,CAAC,MAAM,IAAI;AACP,QAAI,KAAK,SAAS;AACd;AACJ,QAAI,CAAC,KAAK,aAAa,KAAK,CAAC,KAAK,KAAK,EAAE,QAAQ;AAC7C,WAAK,SAAS,IAAI;AAAA,IACtB;AACA,SAAK,MAAM,IAAI;AACf,SAAK,OAAO,IAAI;AAChB,SAAK,KAAK,QAAQ;AAClB,QAAI,KAAKE,QAAM,EAAE;AACb,WAAK,KAAK,EAAC;AAAA,aACN,KAAKF,KAAG;AACb,WAAK,cAAc,EAAC;AAAA;AAEpB,WAAK,KAAK,OAAO;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,SAAS;AACL,WAAO,KAAK,MAAM,EAAC;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ;AACJ,SAAK,OAAO,IAAI;AAChB,SAAK,MAAM,IAAI;AACf,SAAK,SAAS,IAAI;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,YAAY;AACZ,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAU;AACV,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,SAAS;AACT,WAAO,KAAK,MAAM;AAAA,EACtB;AAAA,EACA,CAAC,UAAU,EAAE,OAAO;AAChB,QAAI,KAAK,UAAU;AACf,WAAK,YAAY,KAAK;AAAA;AAEtB,WAAK,YAAY,KAAK,MAAM;AAChC,SAAKE,QAAM,EAAE,KAAK,KAAK;AAAA,EAC3B;AAAA,EACA,CAAC,WAAW,IAAI;AACZ,QAAI,KAAK,UAAU;AACf,WAAK,YAAY,KAAK;AAAA;AAEtB,WAAK,YAAY,KAAK,KAAKA,QAAM,EAAE,CAAC,EAAE;AAC1C,WAAO,KAAKA,QAAM,EAAE,MAAK;AAAA,EAC7B;AAAA,EACA,CAAC,KAAK,EAAE,UAAU,OAAO;AACrB,OAAG;AAAA,IAAE,SAAS,KAAK,UAAU,EAAE,KAAK,WAAW,GAAG,KAC9C,KAAKA,QAAM,EAAE;AACjB,QAAI,CAAC,WAAW,CAAC,KAAKA,QAAM,EAAE,UAAU,CAAC,KAAKF,KAAG;AAC7C,WAAK,KAAK,OAAO;AAAA,EACzB;AAAA,EACA,CAAC,UAAU,EAAE,OAAO;AAChB,SAAK,KAAK,QAAQ,KAAK;AACvB,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,MAAM,MAAM;AACb,QAAI,KAAK,SAAS;AACd,aAAO;AACX,SAAK,SAAS,IAAI;AAClB,UAAM,QAAQ,KAAK,WAAW;AAC9B,WAAO,QAAQ,CAAA;AACf,QAAI,SAAS,KAAK,UAAU,SAAS,KAAK;AACtC,WAAK,MAAM;AAAA;AAEX,WAAK,MAAM,KAAK,QAAQ;AAC5B,SAAK,cAAc,CAAC,CAAC,KAAK;AAE1B,QAAI,OAAO;AACP,UAAI,KAAK;AACL,aAAK,IAAG;AAAA,IAChB,OACK;AAGD,WAAK,KAAK,EAAE,KAAK,CAAC,KAAK,cACjB,IAAI,KAAK,MAAM,MAAM,IAAI,IACzB,IAAI,gBAAgB,MAAM,MAAM,IAAI,CAAC;AAC3C,UAAI,KAAK,KAAK;AACV,cAAM,MAAM,KAAK,MAAM,GAAG;AAAA;AAE1B,aAAK,MAAM,EAAC;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,MAAM;AACT,UAAM,IAAI,KAAK,KAAK,EAAE,KAAK,CAAAI,OAAKA,GAAE,SAAS,IAAI;AAC/C,QAAI,GAAG;AACH,UAAI,KAAK,KAAK,EAAE,WAAW,GAAG;AAC1B,YAAI,KAAK,OAAO,KAAK,KAAK,aAAa,MAAM,GAAG;AAC5C,eAAK,OAAO,IAAI;AAAA,QACpB;AACA,aAAK,KAAK,IAAI,CAAA;AAAA,MAClB;AAEI,aAAK,KAAK,EAAE,OAAO,KAAK,KAAK,EAAE,QAAQ,CAAC,GAAG,CAAC;AAChD,QAAE,OAAM;AAAA,IACZ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,IAAI,SAAS;AACrB,WAAO,KAAK,GAAG,IAAI,OAAO;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBA,GAAG,IAAI,SAAS;AACZ,UAAM,MAAM,MAAM,GAAG,IAAI,OAAO;AAChC,QAAI,OAAO,QAAQ;AACf,WAAK,SAAS,IAAI;AAClB,WAAK,aAAa;AAClB,UAAI,CAAC,KAAK,KAAK,EAAE,UAAU,CAAC,KAAK,OAAO,GAAG;AACvC,aAAK,MAAM,EAAC;AAAA,MAChB;AAAA,IACJ,WACS,OAAO,cAAc,KAAK,YAAY,MAAM,GAAG;AACpD,YAAM,KAAK,UAAU;AAAA,IACzB,WACS,SAAS,EAAE,KAAK,KAAK,WAAW,GAAG;AACxC,YAAM,KAAK,EAAE;AACb,WAAK,mBAAmB,EAAE;AAAA,IAC9B,WACS,OAAO,WAAW,KAAK,aAAa,GAAG;AAC5C,YAAM,IAAI;AACV,UAAI,KAAK,KAAK;AACV,cAAM,MAAM,EAAE,KAAK,MAAM,KAAK,aAAa,CAAC,CAAC;AAAA;AAE7C,UAAE,KAAK,MAAM,KAAK,aAAa,CAAC;AAAA,IACxC;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,eAAe,IAAI,SAAS;AACxB,WAAO,KAAK,IAAI,IAAI,OAAO;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,IAAI,IAAI,SAAS;AACb,UAAM,MAAM,MAAM,IAAI,IAAI,OAAO;AAIjC,QAAI,OAAO,QAAQ;AACf,WAAK,aAAa,IAAI,KAAK,UAAU,MAAM,EAAE;AAC7C,UAAI,KAAK,aAAa,MAAM,KACxB,CAAC,KAAK,SAAS,KACf,CAAC,KAAK,KAAK,EAAE,QAAQ;AACrB,aAAK,OAAO,IAAI;AAAA,MACpB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,mBAAmB,IAAI;AACnB,UAAM,MAAM,MAAM,mBAAmB,EAAE;AACvC,QAAI,OAAO,UAAU,OAAO,QAAW;AACnC,WAAK,aAAa,IAAI;AACtB,UAAI,CAAC,KAAK,SAAS,KAAK,CAAC,KAAK,KAAK,EAAE,QAAQ;AACzC,aAAK,OAAO,IAAI;AAAA,MACpB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,IAAI,aAAa;AACb,WAAO,KAAK,WAAW;AAAA,EAC3B;AAAA,EACA,CAAC,cAAc,IAAI;AACf,QAAI,CAAC,KAAK,YAAY,KAClB,CAAC,KAAK,WAAW,KACjB,CAAC,KAAK,SAAS,KACf,KAAKF,QAAM,EAAE,WAAW,KACxB,KAAKF,KAAG,GAAG;AACX,WAAK,YAAY,IAAI;AACrB,WAAK,KAAK,KAAK;AACf,WAAK,KAAK,WAAW;AACrB,WAAK,KAAK,QAAQ;AAClB,UAAI,KAAK,MAAM;AACX,aAAK,KAAK,OAAO;AACrB,WAAK,YAAY,IAAI;AAAA,IACzB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBA,KAAK,OAAO,MAAM;AACd,UAAM,OAAO,KAAK,CAAC;AAEnB,QAAI,OAAO,WACP,OAAO,WACP,OAAO,aACP,KAAK,SAAS,GAAG;AACjB,aAAO;AAAA,IACX,WACS,OAAO,QAAQ;AACpB,aAAO,CAAC,KAAK,UAAU,KAAK,CAAC,OACvB,QACA,KAAK,KAAK,KACL,MAAM,MAAM,KAAK,QAAQ,EAAE,IAAI,CAAC,GAAG,QACpC,KAAK,QAAQ,EAAE,IAAI;AAAA,IACjC,WACS,OAAO,OAAO;AACnB,aAAO,KAAK,OAAO,EAAC;AAAA,IACxB,WACS,OAAO,SAAS;AACrB,WAAK,MAAM,IAAI;AAEf,UAAI,CAAC,KAAK,WAAW,KAAK,CAAC,KAAK,SAAS;AACrC,eAAO;AACX,YAAMK,OAAM,MAAM,KAAK,OAAO;AAC9B,WAAK,mBAAmB,OAAO;AAC/B,aAAOA;AAAA,IACX,WACS,OAAO,SAAS;AACrB,WAAK,aAAa,IAAI;AACtB,YAAM,KAAK,OAAO,IAAI;AACtB,YAAMA,OAAM,CAAC,KAAK,MAAM,KAAK,KAAK,UAAU,OAAO,EAAE,SAC/C,MAAM,KAAK,SAAS,IAAI,IACxB;AACN,WAAK,cAAc,EAAC;AACpB,aAAOA;AAAA,IACX,WACS,OAAO,UAAU;AACtB,YAAMA,OAAM,MAAM,KAAK,QAAQ;AAC/B,WAAK,cAAc,EAAC;AACpB,aAAOA;AAAA,IACX,WACS,OAAO,YAAY,OAAO,aAAa;AAC5C,YAAMA,OAAM,MAAM,KAAK,EAAE;AACzB,WAAK,mBAAmB,EAAE;AAC1B,aAAOA;AAAA,IACX;AAEA,UAAM,MAAM,MAAM,KAAK,IAAI,GAAG,IAAI;AAClC,SAAK,cAAc,EAAC;AACpB,WAAO;AAAA,EACX;AAAA,EACA,CAAC,QAAQ,EAAE,MAAM;AACb,eAAW,KAAK,KAAK,KAAK,GAAG;AACzB,UAAI,EAAE,KAAK,MAAM,IAAI,MAAM;AACvB,aAAK,MAAK;AAAA,IAClB;AACA,UAAM,MAAM,KAAK,SAAS,IAAI,QAAQ,MAAM,KAAK,QAAQ,IAAI;AAC7D,SAAK,cAAc,EAAC;AACpB,WAAO;AAAA,EACX;AAAA,EACA,CAAC,OAAO,IAAI;AACR,QAAI,KAAK,WAAW;AAChB,aAAO;AACX,SAAK,WAAW,IAAI;AACpB,SAAK,WAAW;AAChB,WAAO,KAAK,KAAK,KACV,MAAM,MAAM,KAAK,QAAQ,EAAC,CAAE,GAAG,QAChC,KAAK,QAAQ,EAAC;AAAA,EACxB;AAAA,EACA,CAAC,QAAQ,IAAI;AACT,QAAI,KAAK,OAAO,GAAG;AACf,YAAM,OAAO,KAAK,OAAO,EAAE,IAAG;AAC9B,UAAI,MAAM;AACN,mBAAW,KAAK,KAAK,KAAK,GAAG;AACzB,YAAE,KAAK,MAAM,IAAI;AAAA,QACrB;AACA,YAAI,CAAC,KAAK,SAAS;AACf,gBAAM,KAAK,QAAQ,IAAI;AAAA,MAC/B;AAAA,IACJ;AACA,eAAW,KAAK,KAAK,KAAK,GAAG;AACzB,QAAE,IAAG;AAAA,IACT;AACA,UAAM,MAAM,MAAM,KAAK,KAAK;AAC5B,SAAK,mBAAmB,KAAK;AAC7B,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU;AACZ,UAAM,MAAM,OAAO,OAAO,IAAI;AAAA,MAC1B,YAAY;AAAA,IACxB,CAAS;AACD,QAAI,CAAC,KAAK,UAAU;AAChB,UAAI,aAAa;AAGrB,UAAM,IAAI,KAAK,QAAO;AACtB,SAAK,GAAG,QAAQ,OAAK;AACjB,UAAI,KAAK,CAAC;AACV,UAAI,CAAC,KAAK,UAAU;AAChB,YAAI,cAAc,EAAE;AAAA,IAC5B,CAAC;AACD,UAAM;AACN,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAS;AACX,QAAI,KAAK,UAAU,GAAG;AAClB,YAAM,IAAI,MAAM,6BAA6B;AAAA,IACjD;AACA,UAAM,MAAM,MAAM,KAAK,QAAO;AAC9B,WAAQ,KAAK,QAAQ,IACf,IAAI,KAAK,EAAE,IACX,OAAO,OAAO,KAAK,IAAI,UAAU;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,UAAU;AACZ,WAAO,IAAI,QAAQ,CAACC,UAAS,WAAW;AACpC,WAAK,GAAG,WAAW,MAAM,OAAO,IAAI,MAAM,kBAAkB,CAAC,CAAC;AAC9D,WAAK,GAAG,SAAS,QAAM,OAAO,EAAE,CAAC;AACjC,WAAK,GAAG,OAAO,MAAMA,SAAO,CAAE;AAAA,IAClC,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,CAAC,OAAO,aAAa,IAAI;AAGrB,SAAK,SAAS,IAAI;AAClB,QAAI,UAAU;AACd,UAAM,OAAO,YAAY;AACrB,WAAK,MAAK;AACV,gBAAU;AACV,aAAO,EAAE,OAAO,QAAW,MAAM,KAAI;AAAA,IACzC;AACA,UAAM,OAAO,MAAM;AACf,UAAI;AACA,eAAO,KAAI;AACf,YAAM,MAAM,KAAK,KAAI;AACrB,UAAI,QAAQ;AACR,eAAO,QAAQ,QAAQ,EAAE,MAAM,OAAO,OAAO,KAAK;AACtD,UAAI,KAAKN,KAAG;AACR,eAAO,KAAI;AACf,UAAIM;AACJ,UAAI;AACJ,YAAM,QAAQ,CAAC,OAAO;AAClB,aAAK,IAAI,QAAQ,MAAM;AACvB,aAAK,IAAI,OAAO,KAAK;AACrB,aAAK,IAAI,WAAW,SAAS;AAC7B,aAAI;AACJ,eAAO,EAAE;AAAA,MACb;AACA,YAAM,SAAS,CAAC,UAAU;AACtB,aAAK,IAAI,SAAS,KAAK;AACvB,aAAK,IAAI,OAAO,KAAK;AACrB,aAAK,IAAI,WAAW,SAAS;AAC7B,aAAK,MAAK;AACV,QAAAA,SAAQ,EAAE,OAAO,MAAM,CAAC,CAAC,KAAKN,KAAG,GAAG;AAAA,MACxC;AACA,YAAM,QAAQ,MAAM;AAChB,aAAK,IAAI,SAAS,KAAK;AACvB,aAAK,IAAI,QAAQ,MAAM;AACvB,aAAK,IAAI,WAAW,SAAS;AAC7B,aAAI;AACJ,QAAAM,SAAQ,EAAE,MAAM,MAAM,OAAO,OAAS,CAAE;AAAA,MAC5C;AACA,YAAM,YAAY,MAAM,MAAM,IAAI,MAAM,kBAAkB,CAAC;AAC3D,aAAO,IAAI,QAAQ,CAACC,MAAK,QAAQ;AAC7B,iBAAS;AACT,QAAAD,WAAUC;AACV,aAAK,KAAK,WAAW,SAAS;AAC9B,aAAK,KAAK,SAAS,KAAK;AACxB,aAAK,KAAK,OAAO,KAAK;AACtB,aAAK,KAAK,QAAQ,MAAM;AAAA,MAC5B,CAAC;AAAA,IACL;AACA,WAAO;AAAA,MACH;AAAA,MACA,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,CAAC,OAAO,aAAa,IAAI;AACrB,eAAO;AAAA,MACX;AAAA,IACZ;AAAA,EACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,CAAC,OAAO,QAAQ,IAAI;AAGhB,SAAK,SAAS,IAAI;AAClB,QAAI,UAAU;AACd,UAAM,OAAO,MAAM;AACf,WAAK,MAAK;AACV,WAAK,IAAI,OAAO,IAAI;AACpB,WAAK,IAAI,WAAW,IAAI;AACxB,WAAK,IAAI,OAAO,IAAI;AACpB,gBAAU;AACV,aAAO,EAAE,MAAM,MAAM,OAAO,OAAS;AAAA,IACzC;AACA,UAAM,OAAO,MAAM;AACf,UAAI;AACA,eAAO,KAAI;AACf,YAAM,QAAQ,KAAK,KAAI;AACvB,aAAO,UAAU,OAAO,KAAI,IAAK,EAAE,MAAM,OAAO,MAAK;AAAA,IACzD;AACA,SAAK,KAAK,OAAO,IAAI;AACrB,SAAK,KAAK,OAAO,IAAI;AACrB,SAAK,KAAK,WAAW,IAAI;AACzB,WAAO;AAAA,MACH;AAAA,MACA,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,CAAC,OAAO,QAAQ,IAAI;AAChB,eAAO;AAAA,MACX;AAAA,IACZ;AAAA,EACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,QAAQ,IAAI;AACR,QAAI,KAAK,SAAS,GAAG;AACjB,UAAI;AACA,aAAK,KAAK,SAAS,EAAE;AAAA;AAErB,aAAK,KAAK,SAAS;AACvB,aAAO;AAAA,IACX;AACA,SAAK,SAAS,IAAI;AAClB,SAAK,SAAS,IAAI;AAElB,SAAKL,QAAM,EAAE,SAAS;AACtB,SAAK,YAAY,IAAI;AACrB,UAAM,KAAK;AACX,QAAI,OAAO,GAAG,UAAU,cAAc,CAAC,KAAK,MAAM;AAC9C,SAAG,MAAK;AACZ,QAAI;AACA,WAAK,KAAK,SAAS,EAAE;AAAA;AAGrB,WAAK,KAAK,SAAS;AACvB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW,WAAW;AAClB,WAAO;AAAA,EACX;AACJ;ACr/BA,MAAM,SAAS,GAAG;AAClB,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,MAAM,OAAO,KAAK;AACxB,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,eAAe,OAAO,cAAc;AAC1C,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,eAAe,OAAO,cAAc;AAC1C,MAAM,WAAW,OAAO,UAAU;AAC3B,MAAM,mBAAmB,SAAS;AAAA,EACrC,CAAC,QAAQ,IAAI;AAAA,EACb,CAAC,GAAG;AAAA,EACJ,CAAC,KAAK;AAAA,EACN,CAAC,SAAS;AAAA,EACV,CAAC,QAAQ,IAAI;AAAA,EACb,CAAC,KAAK;AAAA,EACN,CAAC,OAAO;AAAA,EACR,CAAC,UAAU;AAAA,EACX,YAAY,MAAM,KAAK;AACnB,UAAM,OAAO,CAAA;AACb,UAAM,GAAG;AACT,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,QAAI,OAAO,SAAS,UAAU;AAC1B,YAAM,IAAI,UAAU,uBAAuB;AAAA,IAC/C;AACA,SAAK,QAAQ,IAAI;AACjB,SAAK,GAAG,IAAI,OAAO,IAAI,OAAO,WAAW,IAAI,KAAK;AAClD,SAAK,KAAK,IAAI;AACd,SAAK,SAAS,IAAI,IAAI,YAAY,KAAK,OAAO;AAC9C,SAAK,QAAQ,IAAI;AACjB,SAAK,KAAK,IAAI,OAAO,IAAI,SAAS,WAAW,IAAI,OAAO;AACxD,SAAK,OAAO,IAAI,KAAK,KAAK;AAC1B,SAAK,UAAU,IACX,OAAO,IAAI,cAAc,YAAY,IAAI,YAAY;AACzD,QAAI,OAAO,KAAK,GAAG,MAAM,UAAU;AAC/B,WAAK,KAAK,EAAC;AAAA,IACf,OACK;AACD,WAAK,KAAK,EAAC;AAAA,IACf;AAAA,EACJ;AAAA,EACA,IAAI,KAAK;AACL,WAAO,KAAK,GAAG;AAAA,EACnB;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA;AAAA,EAEA,QAAQ;AACJ,UAAM,IAAI,UAAU,2BAA2B;AAAA,EACnD;AAAA;AAAA,EAEA,MAAM;AACF,UAAM,IAAI,UAAU,2BAA2B;AAAA,EACnD;AAAA,EACA,CAAC,KAAK,IAAI;AACN,OAAG,KAAK,KAAK,KAAK,GAAG,KAAK,CAAC,IAAI,OAAO,KAAK,OAAO,EAAE,IAAI,EAAE,CAAC;AAAA,EAC/D;AAAA,EACA,CAAC,OAAO,EAAE,IAAI,IAAI;AACd,QAAI,IAAI;AACJ,WAAK,QAAQ,EAAE,EAAE;AAAA,IACrB,OACK;AACD,WAAK,GAAG,IAAI;AACZ,WAAK,KAAK,QAAQ,EAAE;AACpB,WAAK,KAAK,EAAC;AAAA,IACf;AAAA,EACJ;AAAA,EACA,CAAC,QAAQ,IAAI;AACT,WAAO,OAAO,YAAY,KAAK,IAAI,KAAK,SAAS,GAAG,KAAK,OAAO,CAAC,CAAC;AAAA,EACtE;AAAA,EACA,CAAC,KAAK,IAAI;AACN,QAAI,CAAC,KAAK,QAAQ,GAAG;AACjB,WAAK,QAAQ,IAAI;AACjB,YAAM,MAAM,KAAK,QAAQ,EAAC;AAE1B,UAAI,IAAI,WAAW,GAAG;AAClB,eAAO,QAAQ,SAAS,MAAM,KAAK,OAAO,EAAE,MAAM,GAAG,GAAG,CAAC;AAAA,MAC7D;AAEA,SAAG,KAAK,KAAK,GAAG,GAAG,KAAK,GAAG,IAAI,QAAQ,MAAM,CAAC,IAAI,IAAI,MAAM,KAAK,OAAO,EAAE,IAAI,IAAI,CAAC,CAAC;AAAA,IACxF;AAAA,EACJ;AAAA,EACA,CAAC,OAAO,EAAE,IAAI,IAAI,KAAK;AACnB,SAAK,QAAQ,IAAI;AACjB,QAAI,IAAI;AACJ,WAAK,QAAQ,EAAE,EAAE;AAAA,IACrB,WACS,KAAK,YAAY,EAAE,IAAI,GAAG,GAAG;AAClC,WAAK,KAAK,EAAC;AAAA,IACf;AAAA,EACJ;AAAA,EACA,CAAC,MAAM,IAAI;AACP,QAAI,KAAK,UAAU,KAAK,OAAO,KAAK,GAAG,MAAM,UAAU;AACnD,YAAM,KAAK,KAAK,GAAG;AACnB,WAAK,GAAG,IAAI;AACZ,SAAG,MAAM,IAAI,QAAM,KAAK,KAAK,KAAK,SAAS,EAAE,IAAI,KAAK,KAAK,OAAO,CAAC;AAAA,IACvE;AAAA,EACJ;AAAA,EACA,CAAC,QAAQ,EAAE,IAAI;AACX,SAAK,QAAQ,IAAI;AACjB,SAAK,MAAM,EAAC;AACZ,SAAK,KAAK,SAAS,EAAE;AAAA,EACzB;AAAA,EACA,CAAC,YAAY,EAAE,IAAI,KAAK;AACpB,QAAI,MAAM;AAEV,SAAK,OAAO,KAAK;AACjB,QAAI,KAAK,GAAG;AACR,YAAM,MAAM,MAAM,KAAK,IAAI,SAAS,IAAI,SAAS,GAAG,EAAE,IAAI,GAAG;AAAA,IACjE;AACA,QAAI,OAAO,KAAK,KAAK,OAAO,KAAK,GAAG;AAChC,YAAM;AACN,WAAK,MAAM,EAAC;AACZ,YAAM,IAAG;AAAA,IACb;AACA,WAAO;AAAA,EACX;AAAA,EACA,KAAK,OAAO,MAAM;AACd,YAAQ,IAAE;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AACD,eAAO;AAAA,MACX,KAAK;AACD,YAAI,OAAO,KAAK,GAAG,MAAM,UAAU;AAC/B,eAAK,KAAK,EAAC;AAAA,QACf;AACA,eAAO;AAAA,MACX,KAAK;AACD,YAAI,KAAK,QAAQ,GAAG;AAChB,iBAAO;AAAA,QACX;AACA,aAAK,QAAQ,IAAI;AACjB,eAAO,MAAM,KAAK,IAAI,GAAG,IAAI;AAAA,MACjC;AACI,eAAO,MAAM,KAAK,IAAI,GAAG,IAAI;AAAA,IAC7C;AAAA,EACI;AACJ;AACO,MAAM,uBAAuB,WAAW;AAAA,EAC3C,CAAC,KAAK,IAAI;AACN,QAAI,QAAQ;AACZ,QAAI;AACA,WAAK,OAAO,EAAE,MAAM,GAAG,SAAS,KAAK,KAAK,GAAG,GAAG,CAAC;AACjD,cAAQ;AAAA,IACZ,UACR;AACY,UAAI,OAAO;AACP,aAAK,MAAM,EAAC;AAAA,MAChB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,CAAC,KAAK,IAAI;AACN,QAAI,QAAQ;AACZ,QAAI;AACA,UAAI,CAAC,KAAK,QAAQ,GAAG;AACjB,aAAK,QAAQ,IAAI;AACjB,WAAG;AACC,gBAAM,MAAM,KAAK,QAAQ,EAAC;AAE1B,gBAAM,KAAK,IAAI,WAAW,IACpB,IACA,GAAG,SAAS,KAAK,GAAG,GAAG,KAAK,GAAG,IAAI,QAAQ,IAAI;AAErD,cAAI,CAAC,KAAK,YAAY,EAAE,IAAI,GAAG,GAAG;AAC9B;AAAA,UACJ;AAAA,QACJ,SAAS;AACT,aAAK,QAAQ,IAAI;AAAA,MACrB;AACA,cAAQ;AAAA,IACZ,UACR;AACY,UAAI,OAAO;AACP,aAAK,MAAM,EAAC;AAAA,MAChB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,CAAC,MAAM,IAAI;AACP,QAAI,KAAK,UAAU,KAAK,OAAO,KAAK,GAAG,MAAM,UAAU;AACnD,YAAM,KAAK,KAAK,GAAG;AACnB,WAAK,GAAG,IAAI;AACZ,SAAG,UAAU,EAAE;AACf,WAAK,KAAK,OAAO;AAAA,IACrB;AAAA,EACJ;AACJ;AACO,MAAM,oBAAoB,GAAG;AAAA,EAChC,WAAW;AAAA,EACX,WAAW;AAAA,EACX,CAAC,QAAQ,IAAI;AAAA,EACb,CAAC,QAAQ,IAAI;AAAA,EACb,CAAC,MAAM,IAAI;AAAA,EACX,CAAC,MAAM,IAAI,CAAA;AAAA,EACX,CAAC,UAAU,IAAI;AAAA,EACf,CAAC,KAAK;AAAA,EACN,CAAC,KAAK;AAAA,EACN,CAAC,UAAU;AAAA,EACX,CAAC,GAAG;AAAA,EACJ,CAAC,YAAY;AAAA,EACb,CAAC,MAAM;AAAA,EACP,CAAC,SAAS,IAAI;AAAA,EACd,CAAC,IAAI;AAAA,EACL,YAAY,MAAM,KAAK;AACnB,UAAM,OAAO,CAAA;AACb,UAAM,GAAG;AACT,SAAK,KAAK,IAAI;AACd,SAAK,GAAG,IAAI,OAAO,IAAI,OAAO,WAAW,IAAI,KAAK;AAClD,SAAK,KAAK,IAAI,IAAI,SAAS,SAAY,MAAQ,IAAI;AACnD,SAAK,IAAI,IAAI,OAAO,IAAI,UAAU,WAAW,IAAI,QAAQ;AACzD,SAAK,UAAU,IACX,OAAO,IAAI,cAAc,YAAY,IAAI,YAAY;AAEzD,UAAM,cAAc,KAAK,IAAI,MAAM,SAAY,OAAO;AACtD,SAAK,YAAY,IAAI,IAAI,UAAU;AACnC,SAAK,MAAM,IAAI,IAAI,UAAU,SAAY,cAAc,IAAI;AAC3D,QAAI,KAAK,GAAG,MAAM,QAAW;AACzB,WAAK,KAAK,EAAC;AAAA,IACf;AAAA,EACJ;AAAA,EACA,KAAK,OAAO,MAAM;AACd,QAAI,OAAO,SAAS;AAChB,UAAI,KAAK,QAAQ,GAAG;AAChB,eAAO;AAAA,MACX;AACA,WAAK,QAAQ,IAAI;AAAA,IACrB;AACA,WAAO,MAAM,KAAK,IAAI,GAAG,IAAI;AAAA,EACjC;AAAA,EACA,IAAI,KAAK;AACL,WAAO,KAAK,GAAG;AAAA,EACnB;AAAA,EACA,IAAI,OAAO;AACP,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA,EACA,CAAC,QAAQ,EAAE,IAAI;AACX,SAAK,MAAM,EAAC;AACZ,SAAK,QAAQ,IAAI;AACjB,SAAK,KAAK,SAAS,EAAE;AAAA,EACzB;AAAA,EACA,CAAC,KAAK,IAAI;AACN,OAAG,KAAK,KAAK,KAAK,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK,GAAG,CAAC,IAAI,OAAO,KAAK,OAAO,EAAE,IAAI,EAAE,CAAC;AAAA,EACrF;AAAA,EACA,CAAC,OAAO,EAAE,IAAI,IAAI;AACd,QAAI,KAAK,YAAY,KACjB,KAAK,MAAM,MAAM,QACjB,MACA,GAAG,SAAS,UAAU;AACtB,WAAK,MAAM,IAAI;AACf,WAAK,KAAK,EAAC;AAAA,IACf,WACS,IAAI;AACT,WAAK,QAAQ,EAAE,EAAE;AAAA,IACrB,OACK;AACD,WAAK,GAAG,IAAI;AACZ,WAAK,KAAK,QAAQ,EAAE;AACpB,UAAI,CAAC,KAAK,QAAQ,GAAG;AACjB,aAAK,MAAM,EAAC;AAAA,MAChB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,IAAI,KAAK,KAAK;AACV,QAAI,KAAK;AAEL,WAAK,MAAM,KAAK,GAAG;AAAA,IACvB;AACA,SAAK,MAAM,IAAI;AAEf,QAAI,CAAC,KAAK,QAAQ,KACd,CAAC,KAAK,MAAM,EAAE,UACd,OAAO,KAAK,GAAG,MAAM,UAAU;AAC/B,WAAK,QAAQ,EAAE,MAAM,CAAC;AAAA,IAC1B;AACA,WAAO;AAAA,EACX;AAAA,EACA,MAAM,KAAK,KAAK;AACZ,QAAI,OAAO,QAAQ,UAAU;AACzB,YAAM,OAAO,KAAK,KAAK,GAAG;AAAA,IAC9B;AACA,QAAI,KAAK,MAAM,GAAG;AACd,WAAK,KAAK,SAAS,IAAI,MAAM,qBAAqB,CAAC;AACnD,aAAO;AAAA,IACX;AACA,QAAI,KAAK,GAAG,MAAM,UAAa,KAAK,QAAQ,KAAK,KAAK,MAAM,EAAE,QAAQ;AAClE,WAAK,MAAM,EAAE,KAAK,GAAG;AACrB,WAAK,UAAU,IAAI;AACnB,aAAO;AAAA,IACX;AACA,SAAK,QAAQ,IAAI;AACjB,SAAK,MAAM,EAAE,GAAG;AAChB,WAAO;AAAA,EACX;AAAA,EACA,CAAC,MAAM,EAAE,KAAK;AACV,OAAG,MAAM,KAAK,GAAG,GAAG,KAAK,GAAG,IAAI,QAAQ,KAAK,IAAI,GAAG,CAAC,IAAI,OAAO,KAAK,QAAQ,EAAE,IAAI,EAAE,CAAC;AAAA,EAC1F;AAAA,EACA,CAAC,QAAQ,EAAE,IAAI,IAAI;AACf,QAAI,IAAI;AACJ,WAAK,QAAQ,EAAE,EAAE;AAAA,IACrB,OACK;AACD,UAAI,KAAK,IAAI,MAAM,UAAa,OAAO,OAAO,UAAU;AACpD,aAAK,IAAI,KAAK;AAAA,MAClB;AACA,UAAI,KAAK,MAAM,EAAE,QAAQ;AACrB,aAAK,MAAM,EAAC;AAAA,MAChB,OACK;AACD,aAAK,QAAQ,IAAI;AACjB,YAAI,KAAK,MAAM,KAAK,CAAC,KAAK,SAAS,GAAG;AAClC,eAAK,SAAS,IAAI;AAClB,eAAK,MAAM,EAAC;AACZ,eAAK,KAAK,QAAQ;AAAA,QACtB,WACS,KAAK,UAAU,GAAG;AACvB,eAAK,UAAU,IAAI;AACnB,eAAK,KAAK,OAAO;AAAA,QACrB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,CAAC,MAAM,IAAI;AACP,QAAI,KAAK,MAAM,EAAE,WAAW,GAAG;AAC3B,UAAI,KAAK,MAAM,GAAG;AACd,aAAK,QAAQ,EAAE,MAAM,CAAC;AAAA,MAC1B;AAAA,IACJ,WACS,KAAK,MAAM,EAAE,WAAW,GAAG;AAChC,WAAK,MAAM,EAAE,KAAK,MAAM,EAAE,IAAG,CAAE;AAAA,IACnC,OACK;AACD,YAAM,QAAQ,KAAK,MAAM;AACzB,WAAK,MAAM,IAAI,CAAA;AACf,aAAO,KAAK,GAAG,GAAG,OAAO,KAAK,IAAI,GAAG,CAAC,IAAI,OAAO,KAAK,QAAQ,EAAE,IAAI,EAAE,CAAC;AAAA,IAC3E;AAAA,EACJ;AAAA,EACA,CAAC,MAAM,IAAI;AACP,QAAI,KAAK,UAAU,KAAK,OAAO,KAAK,GAAG,MAAM,UAAU;AACnD,YAAM,KAAK,KAAK,GAAG;AACnB,WAAK,GAAG,IAAI;AACZ,SAAG,MAAM,IAAI,QAAM,KAAK,KAAK,KAAK,SAAS,EAAE,IAAI,KAAK,KAAK,OAAO,CAAC;AAAA,IACvE;AAAA,EACJ;AACJ;AACO,MAAM,wBAAwB,YAAY;AAAA,EAC7C,CAAC,KAAK,IAAI;AACN,QAAI;AAGJ,QAAI,KAAK,YAAY,KAAK,KAAK,MAAM,MAAM,MAAM;AAC7C,UAAI;AACA,aAAK,GAAG,SAAS,KAAK,KAAK,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK,CAAC;AAAA,MAC3D,SACO,IAAI;AACP,YAAI,IAAI,SAAS,UAAU;AACvB,eAAK,MAAM,IAAI;AACf,iBAAO,KAAK,KAAK,EAAC;AAAA,QACtB,OACK;AACD,gBAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ,OACK;AACD,WAAK,GAAG,SAAS,KAAK,KAAK,GAAG,KAAK,MAAM,GAAG,KAAK,KAAK,CAAC;AAAA,IAC3D;AACA,SAAK,OAAO,EAAE,MAAM,EAAE;AAAA,EAC1B;AAAA,EACA,CAAC,MAAM,IAAI;AACP,QAAI,KAAK,UAAU,KAAK,OAAO,KAAK,GAAG,MAAM,UAAU;AACnD,YAAM,KAAK,KAAK,GAAG;AACnB,WAAK,GAAG,IAAI;AACZ,SAAG,UAAU,EAAE;AACf,WAAK,KAAK,OAAO;AAAA,IACrB;AAAA,EACJ;AAAA,EACA,CAAC,MAAM,EAAE,KAAK;AAEV,QAAI,QAAQ;AACZ,QAAI;AACA,WAAK,QAAQ,EAAE,MAAM,GAAG,UAAU,KAAK,GAAG,GAAG,KAAK,GAAG,IAAI,QAAQ,KAAK,IAAI,CAAC,CAAC;AAC5E,cAAQ;AAAA,IACZ,UACR;AACY,UAAI,OAAO;AACP,YAAI;AACA,eAAK,MAAM,EAAC;AAAA,QAChB,QACM;AAAA,QAEN;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;ACjaA,MAAM,SAAS,oBAAI,IAAI;AAAA,EACnB,CAAC,KAAK,KAAK;AAAA,EACX,CAAC,KAAK,MAAM;AAAA,EACZ,CAAC,KAAK,MAAM;AAAA,EACZ,CAAC,KAAK,eAAe;AAAA,EACrB,CAAC,KAAK,QAAQ;AAAA,EACd,CAAC,oBAAoB,OAAO;AAAA,EAC5B,CAAC,mBAAmB,OAAO;AAAA,EAC3B,CAAC,cAAc,OAAO;AAAA,EACtB,CAAC,aAAa,OAAO;AAAA,EACrB,CAAC,oBAAoB,OAAO;AAAA,EAC5B,CAAC,kBAAkB,OAAO;AAAA,EAC1B,CAAC,KAAK,MAAM;AAAA,EACZ,CAAC,iBAAiB,MAAM;AAAA,EACxB,CAAC,gBAAgB,MAAM;AAAA,EACvB,CAAC,KAAK,SAAS;AAAA,EACf,CAAC,YAAY,SAAS;AAAA,EACtB,CAAC,KAAK,eAAe;AAAA,EACrB,CAAC,KAAK,QAAQ;AAAA,EACd,CAAC,KAAK,QAAQ;AAAA,EACd,CAAC,WAAW,aAAa;AAC7B,CAAC;AACM,MAAM,aAAa,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE;AAC1C,MAAM,cAAc,CAAC,MAAM,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE;AAC1C,MAAM,eAAe,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,EAAE;AAC3C,MAAM,gBAAgB,CAAC,MAAM,CAAC,EAAE,QAAQ,CAAC,EAAE;AAG3C,MAAM,SAAS,CAAC,MAAM,CAAC,CAAC,EAAE;AAEjC,MAAM,aAAa,CAAC,MAAM;AACtB,QAAM,IAAI,OAAO,IAAI,CAAC;AACtB,MAAI;AACA,WAAO;AACX,SAAO;AACX;AACO,MAAM,UAAU,CAAC,MAAM,OAAO;AACjC,MAAI,CAAC;AACD,WAAO,CAAA;AACX,QAAM,SAAS,CAAA;AACf,aAAW,CAAC,KAAK,CAAC,KAAK,OAAO,QAAQ,GAAG,GAAG;AAExC,UAAM,IAAI,WAAW,GAAG;AACxB,WAAO,CAAC,IAAI;AAAA,EAChB;AAEA,MAAI,OAAO,UAAU,UAAa,OAAO,YAAY,OAAO;AACxD,WAAO,QAAQ;AAAA,EACnB;AACA,SAAO,OAAO;AACd,SAAO;AACX;ACnDO,MAAM,cAAc,CAAC,UAAU,WAAW,YAAY,aAAa,aAAa;AACnF,SAAO,OAAO,OAAO,CAAC,OAAO,CAAA,GAAI,SAAS,OAAO;AAC7C,QAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,gBAAU;AACV,aAAO,CAAA;AAAA,IACX;AACA,QAAI,OAAO,YAAY,YAAY;AAC/B,WAAK;AACL,gBAAU;AAAA,IACd;AACA,QAAI,CAAC,SAAS;AACV,gBAAU,CAAA;AAAA,IACd,OACK;AACD,gBAAU,MAAM,KAAK,OAAO;AAAA,IAChC;AACA,UAAM,MAAM,QAAQ,IAAI;AACxB,eAAW,KAAK,OAAO;AACvB,QAAI,WAAW,GAAG,GAAG;AACjB,UAAI,OAAO,OAAO,YAAY;AAC1B,cAAM,IAAI,UAAU,+CAA+C;AAAA,MACvE;AACA,aAAO,SAAS,KAAK,OAAO;AAAA,IAChC,WACS,YAAY,GAAG,GAAG;AACvB,YAAM,IAAI,UAAU,KAAK,OAAO;AAEhC,YAAM,IAAI,KAAK,KAAK;AACpB,aAAO,IAAI,EAAE,KAAK,MAAM,EAAC,GAAI,CAAC,IAAI;AAAA,IACtC,WACS,aAAa,GAAG,GAAG;AACxB,UAAI,OAAO,OAAO,YAAY;AAC1B,cAAM,IAAI,UAAU,+CAA+C;AAAA,MACvE;AACA,aAAO,WAAW,KAAK,OAAO;AAAA,IAClC,WACS,cAAc,GAAG,GAAG;AACzB,UAAI,OAAO,OAAO,YAAY;AAC1B,cAAM,IAAI,UAAU,0CAA0C;AAAA,MAClE;AACA,aAAO,YAAY,KAAK,OAAO;AAAA,IAEnC,OACK;AACD,YAAM,IAAI,MAAM,sBAAsB;AAAA,IAC1C;AAAA,EAEJ,GAAG;AAAA,IACC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACR,CAAK;AACL;ACjDA,MAAM,oBAAoBM,kBAAS,aAAa,EAAE,aAAa,KAAI;AAE5D,MAAM,YAAY,OAAO,OAAO,OAAO,OAAO,uBAAO,OAAO,IAAI,GAAG;AAAA,EACtE,YAAY;AAAA,EACZ,iBAAiB;AAAA,EACjB,cAAc;AAAA,EACd,cAAc;AAAA,EACd,UAAU;AAAA,EACV,SAAS;AAAA,EACT,MAAM;AAAA,EACN,cAAc;AAAA,EACd,aAAa;AAAA,EACb,SAAS;AAAA,EACT,gBAAgB;AAAA,EAChB,cAAc;AAAA,EACd,aAAa;AAAA,EACb,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,kBAAkB;AAAA,EAClB,cAAc;AAAA,EACd,oBAAoB;AAAA,EACpB,uBAAuB;AAAA,EACvB,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,OAAO;AAAA,EACP,SAAS;AAAA,EACT,oBAAoB;AAAA,EACpB,SAAS;AAAA,EACT,SAAS;AAAA,EACT,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,OAAO;AAAA,EACP,eAAe;AAAA,EACf,eAAe;AAAA,EACf,kBAAkB;AAAA,EAClB,kBAAkB;AAAA,EAClB,sBAAsB;AAAA,EACtB,aAAa;AAAA,EACb,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,gBAAgB;AAAA,EAChB,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,aAAa;AAAA,EACb,aAAa;AAAA,EACb,iBAAiB;AAAA,EACjB,0BAA0B;AAAA,EAC1B,wBAAwB;AAAA,EACxB,yBAAyB;AAAA,EACzB,gCAAgC;AAAA,EAChC,qBAAqB;AAAA,EACrB,kBAAkB;AAAA,EAClB,kBAAkB;AAAA,EAClB,qBAAqB;AAAA,EACrB,oBAAoB;AAAA,EACpB,oBAAoB;AAAA,EACpB,wBAAwB;AAAA,EACxB,wBAAwB;AAAA,EACxB,wBAAwB;AAAA,EACxB,8BAA8B;AAAA,EAC9B,uBAAuB;AAAA,EACvB,6BAA6B;AAAA,EAC7B,6BAA6B;AAAA,EAC7B,mBAAmB;AAAA,EACnB,sBAAsB;AAAA,EACtB,oBAAoB;AAAA,EACpB,sBAAsB;AAAA,EACtB,+CAA+C;AAAA,EAC/C,wBAAwB;AAAA,EACxB,2BAA2B;AAAA,EAC3B,uBAAuB;AAAA,EACvB,sBAAsB;AAAA,EACtB,6BAA6B;AAAA,EAC7B,+BAA+B;AAAA,EAC/B,wCAAwC;AAAA,EACxC,yCAAyC;AAAA,EACzC,uDAAuD;AAAA,EACvD,mCAAmC;AAAA,EACnC,yBAAyB;AAAA,EACzB,wBAAwB;AAAA,EACxB,iCAAiC;AAAA,EACjC,kCAAkC;AAAA,EAClC,8CAA8C;AAAA,EAC9C,sCAAsC;AAAA,EACtC,mDAAmD;AAAA,EACnD,qDAAqD;AAAA,EACrD,iDAAiD;AAAA,EACjD,sCAAsC;AAAA,EACtC,2CAA2C;AAAA,EAC3C,gDAAgD;AAAA,EAChD,4CAA4C;AAAA,EAC5C,4CAA4C;AAAA,EAC5C,uCAAuC;AAAA,EACvC,wCAAwC;AAAA,EACxC,yCAAyC;AAAA,EACzC,uCAAuC;AAAA,EACvC,uCAAuC;AAAA,EACvC,sCAAsC;AAAA,EACtC,yCAAyC;AAAA,EACzC,wCAAwC;AAAA,EACxC,0CAA0C;AAAA,EAC1C,wCAAwC;AAAA,EACxC,wCAAwC;AAAA,EACxC,0CAA0C;AAAA,EAC1C,0CAA0C;AAAA,EAC1C,6CAA6C;AAAA,EAC7C,kCAAkC;AACtC,GAAG,iBAAiB,CAAC;AC7GrB,MAAM,uBAAuBC,SAAO;AACpC,MAAM,OAAO,OAAO,yBAAyBA,UAAQ,QAAQ;AAC7D,MAAMC,SAAO,CAAC,SAAS;AACvB,MAAM,0BAA0B,MAAM,aAAa,QAAQ,MAAM,QAAQ,SACnE,CAAC,aAAa;AACZD,WAAO,SAAS,WAAWC,SAAO;AACtC,IACE,CAAC,MAAM;AAAE;AACf,MAAM,cAAc,OAAO,aAAa;AACjC,MAAM,kBAAkB,MAAM;AAAA,EACjC;AAAA,EACA;AAAA,EACA,YAAY,KAAK,QAAQ;AACrB,UAAM,WAAW,IAAI,SAAS,EAAE,OAAO,KAAK;AAC5C,SAAK,OAAO,IAAI;AAChB,SAAK,QAAQ,IAAI;AAEjB,QAAI,CAAC,KAAK;AACN,WAAK,OAAO;AAChB,SAAK,UAAU,WAAW,IAAI;AAC9B,UAAM,kBAAkB,MAAM,UAAU,KAAK,WAAW;AAAA,EAC5D;AAAA,EACA,IAAI,OAAO;AACP,WAAO;AAAA,EACX;AACJ;AAKA,MAAM,aAAa,OAAO,WAAW;AACrC,MAAM,iBAAiB,SAAS;AAAA,EAC5B,YAAY;AAAA,EACZ,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,IAAI,WAAW;AACX,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,SAAS;AACT,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAEA,IAAI,YAAY;AACZ,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAEA,YAAY,MAAM,MAAM;AACpB,QAAI,CAAC,QAAQ,OAAO,SAAS;AACzB,YAAM,IAAI,UAAU,0CAA0C;AAElE,UAAM,IAAI;AAEV,SAAK,aAAa,KAAK,SAAS;AAChC,SAAK,mBAAmB,KAAK,eAAe;AAC5C,SAAK,iBAAiB,KAAK,iBAAiB;AAG5C,QAAI,OAAO,SAAS,IAAI,MAAM,YAAY;AACtC,YAAM,IAAI,UAAU,uCAAuC,IAAI;AAAA,IACnE;AAEA,QAAI;AAGA,WAAK,UAAU,IAAI,SAAS,IAAI,EAAE,IAAI;AAAA,IAC1C,SACO,IAAI;AAEP,YAAM,IAAI,UAAU,IAAI,KAAK,WAAW;AAAA,IAC5C;AACA,SAAK,WAAW,SAAO;AAEnB,UAAI,KAAK;AACL;AACJ,WAAK,YAAY;AAGjB,WAAK,MAAK;AACV,WAAK,KAAK,SAAS,GAAG;AAAA,IAC1B;AACA,SAAK,SAAS,GAAG,SAAS,QAAM,KAAK,SAAS,IAAI,UAAU,EAAE,CAAC,CAAC;AAChE,SAAK,KAAK,OAAO,MAAM,KAAK,KAAK;AAAA,EACrC;AAAA,EACA,QAAQ;AACJ,QAAI,KAAK,SAAS;AACd,WAAK,QAAQ,MAAK;AAClB,WAAK,UAAU;AACf,WAAK,KAAK,OAAO;AAAA,IACrB;AAAA,EACJ;AAAA,EACA,QAAQ;AACJ,QAAI,CAAC,KAAK,WAAW;AACjB,aAAO,KAAK,SAAS,qBAAqB;AAE1C,aAAO,KAAK,QAAQ,QAAK;AAAA,IAC7B;AAAA,EACJ;AAAA,EACA,MAAM,WAAW;AACb,QAAI,KAAK;AACL;AACJ,QAAI,OAAO,cAAc;AACrB,kBAAY,KAAK;AACrB,SAAK,MAAM,OAAO,OAAOD,SAAO,MAAM,CAAC,GAAG,EAAE,CAAC,UAAU,GAAG,UAAS,CAAE,CAAC;AAAA,EAC1E;AAAA,EACA,IAAI,OAAO,UAAU,IAAI;AAErB,QAAI,OAAO,UAAU,YAAY;AAC7B,WAAK;AACL,iBAAW;AACX,cAAQ;AAAA,IACZ;AACA,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AAEA,QAAI,OAAO;AACP,UAAI;AACA,aAAK,MAAM,OAAO,QAAQ;AAAA;AAE1B,aAAK,MAAM,KAAK;AAAA,IACxB;AACA,SAAK,MAAM,KAAK,gBAAgB;AAChC,SAAK,SAAS;AACd,WAAO,MAAM,IAAI,EAAE;AAAA,EACvB;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAEA,CAAC,WAAW,EAAE,MAAM;AAChB,WAAO,MAAM,MAAM,IAAI;AAAA,EAC3B;AAAA,EACA,MAAM,OAAO,UAAU,IAAI;AAGvB,QAAI,OAAO,aAAa;AACpB,MAAC,KAAK,UAAY,WAAW;AACjC,QAAI,OAAO,UAAU;AACjB,cAAQA,SAAO,KAAK,OAAO,QAAQ;AACvC,QAAI,KAAK;AACL;AACJ,WAAO,KAAK,SAAS,qBAAqB;AAI1C,UAAM,eAAe,KAAK,QACrB;AACL,UAAM,sBAAsB,aAAa;AACzC,iBAAa,QAAQ,MAAM;AAAA,IAAE;AAC7B,UAAM,gBAAgB,KAAK,QAAQ;AACnC,SAAK,QAAQ,QAAQ,MAAM;AAAA,IAAE;AAG7B,4BAAwB,IAAI;AAC5B,QAAI,SAAS;AACb,QAAI;AACA,YAAM,YAAY,OAAO,MAAM,UAAU,MAAM,WACzC,MAAM,UAAU,IAChB,KAAK;AACX,eAAS,KAAK,QAAQ,cAAc,OAAO,SAAS;AAEpD,8BAAwB,KAAK;AAAA,IACjC,SACO,KAAK;AAGR,8BAAwB,KAAK;AAC7B,WAAK,SAAS,IAAI,UAAU,KAAK,KAAK,KAAK,CAAC;AAAA,IAChD,UACR;AACY,UAAI,KAAK,SAAS;AAKd,aAAK,QAAQ,UACT;AACJ,qBAAa,QAAQ;AACrB,aAAK,QAAQ,QAAQ;AAGrB,aAAK,QAAQ,mBAAmB,OAAO;AAAA,MAE3C;AAAA,IACJ;AACA,QAAI,KAAK;AACL,WAAK,QAAQ,GAAG,SAAS,QAAM,KAAK,SAAS,IAAI,UAAU,IAAI,KAAK,KAAK,CAAC,CAAC;AAC/E,QAAI;AACJ,QAAI,QAAQ;AACR,UAAI,MAAM,QAAQ,MAAM,KAAK,OAAO,SAAS,GAAG;AAC5C,cAAM,IAAI,OAAO,CAAC;AAGlB,sBAAc,KAAK,WAAW,EAAEA,SAAO,KAAK,CAAC,CAAC;AAC9C,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,wBAAc,KAAK,WAAW,EAAE,OAAO,CAAC,CAAC;AAAA,QAC7C;AAAA,MACJ,OACK;AAED,sBAAc,KAAK,WAAW,EAAEA,SAAO,KAAK,MAAM,CAAC;AAAA,MACvD;AAAA,IACJ;AACA,QAAI;AACA,SAAE;AACN,WAAO;AAAA,EACX;AACJ;AACO,MAAM,aAAa,SAAS;AAAA,EAC/B;AAAA,EACA;AAAA,EACA,YAAY,MAAM,MAAM;AACpB,WAAO,QAAQ,CAAA;AACf,SAAK,QAAQ,KAAK,SAAS,UAAU;AACrC,SAAK,cAAc,KAAK,eAAe,UAAU;AACjD,SAAK,gBAAgB,UAAU;AAC/B,UAAM,MAAM,IAAI;AAChB,SAAK,SAAS,KAAK;AACnB,SAAK,YAAY,KAAK;AAAA,EAC1B;AAAA,EACA,OAAO,OAAO,UAAU;AACpB,QAAI,KAAK;AACL;AACJ,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,6CAA6C;AAGjE,QAAI,CAAC,KAAK,OAAO;AACb,YAAM,IAAI,MAAM,sCAAsC;AAE1D,QAAI,KAAK,WAAW,SAAS,KAAK,cAAc,UAAU;AACtD,WAAK,MAAM,UAAU,YAAY;AACjC,aAAO,KAAK,QAAQ,qBAAqB;AAIzC,YAAM,YAAY,KAAK,OAAO;AAC9B,WAAK,OAAO,QAAQ,CAAC,WAAW,OAAO;AAEnC,YAAI,OAAO,cAAc,YAAY;AACjC,eAAK;AACL,sBAAY,KAAK;AAAA,QACrB;AAEA,aAAK,MAAM,SAAS;AACpB,aAAE;AAAA,MACN;AACA,UAAI;AACA;AACA,aAAK,OAAO,OAAO,OAAO,QAAQ;AAAA,MACtC,UACZ;AACgB,aAAK,OAAO,QAAQ;AAAA,MACxB;AAEA,UAAI,KAAK,QAAQ;AACb,aAAK,SAAS;AACd,aAAK,YAAY;AAAA,MACrB;AAAA,IAEJ;AAAA,EACJ;AACJ;AAYO,MAAM,aAAa,KAAK;AAAA,EAC3B;AAAA,EACA,YAAY,MAAM;AACd,UAAM,MAAM,MAAM;AAClB,SAAK,YAAY,QAAQ,CAAC,CAAC,KAAK;AAAA,EACpC;AAAA,EACA,CAAC,WAAW,EAAE,MAAM;AAChB,QAAI,CAAC,KAAK;AACN,aAAO,MAAM,WAAW,EAAE,IAAI;AAGlC,SAAK,YAAY;AACjB,SAAK,CAAC,IAAI;AACV,WAAO,MAAM,WAAW,EAAE,IAAI;AAAA,EAClC;AACJ;AAkBO,MAAM,cAAc,KAAK;AAAA,EAC5B,YAAY,MAAM;AACd,UAAM,MAAM,OAAO;AAAA,EACvB;AACJ;AACA,MAAM,eAAe,SAAS;AAAA,EAC1B,YAAY,MAAM,MAAM;AACpB,WAAO,QAAQ,CAAA;AACf,SAAK,QAAQ,KAAK,SAAS,UAAU;AACrC,SAAK,cACD,KAAK,eAAe,UAAU;AAClC,SAAK,gBAAgB,UAAU;AAC/B,UAAM,MAAM,IAAI;AAAA,EACpB;AACJ;AACO,MAAM,uBAAuB,OAAO;AAAA,EACvC,YAAY,MAAM;AACd,UAAM,MAAM,gBAAgB;AAAA,EAChC;AACJ;AACO,MAAM,yBAAyB,OAAO;AAAA,EACzC,YAAY,MAAM;AACd,UAAM,MAAM,kBAAkB;AAAA,EAClC;AACJ;AACA,MAAM,aAAa,SAAS;AAAA,EACxB,YAAY,MAAM,MAAM;AACpB,WAAO,QAAQ,CAAA;AACf,SAAK,QAAQ,KAAK,SAAS,UAAU;AACrC,SAAK,cAAc,KAAK,eAAe,UAAU;AACjD,SAAK,gBAAgB,UAAU;AAC/B,UAAM,MAAM,IAAI;AAAA,EACpB;AACJ;AACO,MAAM,qBAAqB,KAAK;AAAA,EACnC,YAAY,MAAM;AACd,UAAM,MAAM,cAAc;AAAA,EAC9B;AACJ;AACO,MAAM,uBAAuB,KAAK;AAAA,EACrC,YAAY,MAAM;AACd,UAAM,MAAM,gBAAgB;AAAA,EAChC;AACJ;ACvWO,MAAME,WAAS,CAAC,KAAK,QAAQ;AAChC,MAAI,CAAC,OAAO,cAAc,GAAG,GAAG;AAG5B,UAAM,MAAM,+DAA+D;AAAA,EAC/E,WACS,MAAM,GAAG;AACd,mBAAe,KAAK,GAAG;AAAA,EAC3B,OACK;AACD,mBAAe,KAAK,GAAG;AAAA,EAC3B;AACA,SAAO;AACX;AACA,MAAM,iBAAiB,CAAC,KAAK,QAAQ;AACjC,MAAI,CAAC,IAAI;AACT,WAAS,IAAI,IAAI,QAAQ,IAAI,GAAG,KAAK;AACjC,QAAI,IAAI,CAAC,IAAI,MAAM;AACnB,UAAM,KAAK,MAAM,MAAM,GAAK;AAAA,EAChC;AACJ;AACA,MAAM,iBAAiB,CAAC,KAAK,QAAQ;AACjC,MAAI,CAAC,IAAI;AACT,MAAI,UAAU;AACd,QAAM,MAAM;AACZ,WAAS,IAAI,IAAI,QAAQ,IAAI,GAAG,KAAK;AACjC,QAAI,OAAO,MAAM;AACjB,UAAM,KAAK,MAAM,MAAM,GAAK;AAC5B,QAAI,SAAS;AACT,UAAI,IAAI,CAAC,IAAI,SAAS,IAAI;AAAA,IAC9B,WACS,SAAS,GAAG;AACjB,UAAI,IAAI,CAAC,IAAI;AAAA,IACjB,OACK;AACD,gBAAU;AACV,UAAI,IAAI,CAAC,IAAI,SAAS,IAAI;AAAA,IAC9B;AAAA,EACJ;AACJ;AACO,MAAMC,UAAQ,CAAC,QAAQ;AAC1B,QAAM,MAAM,IAAI,CAAC;AACjB,QAAM,QAAQ,QAAQ,MAAO,IAAI,IAAI,SAAS,GAAG,IAAI,MAAM,CAAC,IACtD,QAAQ,MAAO,KAAK,GAAG,IACnB;AACV,MAAI,UAAU,MAAM;AAChB,UAAM,MAAM,0BAA0B;AAAA,EAC1C;AACA,MAAI,CAAC,OAAO,cAAc,KAAK,GAAG;AAG9B,UAAM,MAAM,wDAAwD;AAAA,EACxE;AACA,SAAO;AACX;AACA,MAAM,OAAO,CAAC,QAAQ;AAClB,MAAI,MAAM,IAAI;AACd,MAAI,MAAM;AACV,MAAI,UAAU;AACd,WAAS,IAAI,MAAM,GAAG,IAAI,IAAI,KAAK;AAC/B,QAAI,OAAO,OAAO,IAAI,CAAC,CAAC;AACxB,QAAI;AACJ,QAAI,SAAS;AACT,UAAI,SAAS,IAAI;AAAA,IACrB,WACS,SAAS,GAAG;AACjB,UAAI;AAAA,IACR,OACK;AACD,gBAAU;AACV,UAAI,SAAS,IAAI;AAAA,IACrB;AACA,QAAI,MAAM,GAAG;AACT,aAAO,IAAI,KAAK,IAAI,KAAK,MAAM,IAAI,CAAC;AAAA,IACxC;AAAA,EACJ;AACA,SAAO;AACX;AACA,MAAM,MAAM,CAAC,QAAQ;AACjB,MAAI,MAAM,IAAI;AACd,MAAI,MAAM;AACV,WAAS,IAAI,MAAM,GAAG,IAAI,IAAI,KAAK;AAC/B,QAAI,OAAO,OAAO,IAAI,CAAC,CAAC;AACxB,QAAI,SAAS,GAAG;AACZ,aAAO,OAAO,KAAK,IAAI,KAAK,MAAM,IAAI,CAAC;AAAA,IAC3C;AAAA,EACJ;AACA,SAAO;AACX;AACA,MAAM,WAAW,CAAC,UAAU,MAAO,QAAQ;AAC3C,MAAM,WAAW,CAAC,UAAW,MAAO,QAAQ,IAAK;AC5F1C,MAAM,SAAS,CAAC,MAAM,KAAK,IAAI,CAAC;AAGhC,MAAM,OAAO,oBAAI,IAAI;AAAA,EACxB,CAAC,KAAK,MAAM;AAAA;AAAA,EAEZ,CAAC,IAAI,SAAS;AAAA,EACd,CAAC,KAAK,MAAM;AAAA,EACZ,CAAC,KAAK,cAAc;AAAA;AAAA;AAAA,EAGpB,CAAC,KAAK,iBAAiB;AAAA,EACvB,CAAC,KAAK,aAAa;AAAA,EACnB,CAAC,KAAK,WAAW;AAAA,EACjB,CAAC,KAAK,MAAM;AAAA;AAAA,EAEZ,CAAC,KAAK,gBAAgB;AAAA;AAAA,EAEtB,CAAC,KAAK,sBAAsB;AAAA,EAC5B,CAAC,KAAK,gBAAgB;AAAA;AAAA;AAAA,EAGtB,CAAC,KAAK,YAAY;AAAA;AAAA,EAElB,CAAC,KAAK,YAAY;AAAA;AAAA,EAElB,CAAC,KAAK,OAAO;AAAA;AAAA,EAEb,CAAC,KAAK,yBAAyB;AAAA;AAAA,EAE/B,CAAC,KAAK,qBAAqB;AAAA;AAAA,EAE3B,CAAC,KAAK,kBAAkB;AAAA;AAAA,EAExB,CAAC,KAAK,gBAAgB;AAAA;AAAA,EAEtB,CAAC,KAAK,YAAY;AAAA;AAAA,EAElB,CAAC,KAAK,kBAAkB;AAAA;AAAA,EAExB,CAAC,KAAK,mBAAmB;AAC7B,CAAC;AAEM,MAAM,OAAO,IAAI,IAAI,MAAM,KAAK,IAAI,EAAE,IAAI,QAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;ACpC/D,MAAM,OAAO;AAAA,EAChB,aAAa;AAAA,EACb,UAAU;AAAA,EACV,YAAY;AAAA,EACZ;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAQ;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS;AAAA,EACT,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,MAAM,MAAM,GAAG,IAAI,KAAK;AAChC,QAAI,OAAO,SAAS,IAAI,GAAG;AACvB,WAAK,OAAO,MAAM,OAAO,GAAG,IAAI,GAAG;AAAA,IACvC,WACS,MAAM;AACX,WAAK,OAAO,IAAI;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,OAAO,KAAK,KAAK,IAAI,KAAK;AACtB,QAAI,CAAC,KAAK;AACN,YAAM;AAAA,IACV;AACA,QAAI,CAAC,OAAO,EAAE,IAAI,UAAU,MAAM,MAAM;AACpC,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC/C;AACA,SAAK,OAAO,UAAU,KAAK,KAAK,GAAG;AACnC,SAAK,OAAO,UAAU,KAAK,MAAM,KAAK,CAAC;AACvC,SAAK,MAAM,UAAU,KAAK,MAAM,KAAK,CAAC;AACtC,SAAK,MAAM,UAAU,KAAK,MAAM,KAAK,CAAC;AACtC,SAAK,OAAO,UAAU,KAAK,MAAM,KAAK,EAAE;AACxC,SAAK,QAAQ,QAAQ,KAAK,MAAM,KAAK,EAAE;AACvC,SAAK,QAAQ,UAAU,KAAK,MAAM,KAAK,EAAE;AAIzC,QAAI;AACA,WAAK,OAAO,KAAK,IAAI;AACzB,QAAI;AACA,WAAK,OAAO,EAAE;AAElB,UAAM,IAAI,UAAU,KAAK,MAAM,KAAK,CAAC;AACrC,QAAIC,OAAa,CAAC,GAAG;AACjB,WAAK,QAAQ,KAAK;AAAA,IACtB;AACA,QAAI,KAAK,UAAU,OAAO,KAAK,KAAK,MAAM,EAAE,MAAM,KAAK;AACnD,WAAK,QAAQ;AAAA,IACjB;AAMA,QAAI,KAAK,UAAU,KAAK;AACpB,WAAK,OAAO;AAAA,IAChB;AACA,SAAK,WAAW,UAAU,KAAK,MAAM,KAAK,GAAG;AAC7C,QAAI,IAAI,SAAS,MAAM,KAAK,MAAM,GAAG,EAAE,SAAQ,MAC3C,eAAiB;AACjB,WAAK,QAAQ,UAAU,KAAK,MAAM,KAAK,EAAE;AACzC,WAAK,QAAQ,UAAU,KAAK,MAAM,KAAK,EAAE;AAEzC,WAAK,SAAS,UAAU,KAAK,MAAM,KAAK,CAAC,KAAK;AAC9C,WAAK,SAAS,UAAU,KAAK,MAAM,KAAK,CAAC,KAAK;AAE9C,UAAI,IAAI,MAAM,GAAG,MAAM,GAAG;AAEtB,cAAM,SAAS,UAAU,KAAK,MAAM,KAAK,GAAG;AAC5C,aAAK,OAAO,SAAS,MAAM,KAAK;AAAA,MACpC,OACK;AACD,cAAM,SAAS,UAAU,KAAK,MAAM,KAAK,GAAG;AAC5C,YAAI,QAAQ;AACR,eAAK,OAAO,SAAS,MAAM,KAAK;AAAA,QACpC;AACA,aAAK,QAAQ,QAAQ,KAAK,MAAM,KAAK,EAAE;AACvC,aAAK,QAAQ,QAAQ,KAAK,MAAM,KAAK,EAAE;AAAA,MAC3C;AAAA,IACJ;AACA,QAAI,MAAM,IAAI;AACd,aAAS,IAAI,KAAK,IAAI,MAAM,KAAK,KAAK;AAClC,aAAO,IAAI,CAAC;AAAA,IAChB;AACA,aAAS,IAAI,MAAM,KAAK,IAAI,MAAM,KAAK,KAAK;AACxC,aAAO,IAAI,CAAC;AAAA,IAChB;AACA,SAAK,aAAa,QAAQ,KAAK;AAC/B,QAAI,KAAK,UAAU,UAAa,QAAQ,IAAI,IAAM;AAC9C,WAAK,YAAY;AAAA,IACrB;AAAA,EACJ;AAAA,EACA,OAAO,IAAI,MAAM,OAAO;AACpB,WAAO,OAAO,MAAM,OAAO,YAAY,OAAO,QAAQ,EAAE,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM;AAIzE,aAAO,EAAE,MAAM,QACX,MAAM,UACL,MAAM,UAAU,OAChB,MAAM,cAAc,OACrB,MAAM;AAAA,IACd,CAAC,CAAC,CAAC;AAAA,EACP;AAAA,EACA,OAAO,KAAK,MAAM,GAAG;AACjB,QAAI,CAAC,KAAK;AACN,YAAM,KAAK,QAAQ,OAAO,MAAM,GAAG;AAAA,IACvC;AACA,QAAI,KAAK,UAAU,eAAe;AAC9B,WAAK,QAAQ;AAAA,IACjB;AACA,QAAI,EAAE,IAAI,UAAU,MAAM,MAAM;AAC5B,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC/C;AACA,UAAM,aAAa,KAAK,SAAS,KAAK,QAAQ,MAAM;AACpD,UAAM,QAAQ,YAAY,KAAK,QAAQ,IAAI,UAAU;AACrD,UAAM,OAAO,MAAM,CAAC;AACpB,UAAM,SAAS,MAAM,CAAC;AACtB,SAAK,UAAU,CAAC,CAAC,MAAM,CAAC;AACxB,SAAK,UAAU,UAAU,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK;AACtD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,GAAG,KAAK,IAAI,KAAK,KAAK;AACpD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,GAAG,KAAK,GAAG,KAAK,KAAK;AACnD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,GAAG,KAAK,GAAG,KAAK,KAAK;AACnD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,IAAI,KAAK,IAAI,KAAK,KAAK;AACrD,SAAK,UACD,QAAQ,KAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK;AACpD,QAAI,MAAM,GAAG,IAAI,KAAK,MAAM,WAAW,CAAC;AACxC,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,KAAK,KAAK,QAAQ,KAAK,KAAK;AAC1D,QAAI,MAAM,eAAiB,MAAM,KAAK,CAAC;AACvC,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK;AACtD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK;AACtD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,GAAG,KAAK,MAAM,KAAK,KAAK;AACtD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,GAAG,KAAK,MAAM,KAAK,KAAK;AACtD,SAAK,UACD,UAAU,KAAK,MAAM,KAAK,YAAY,MAAM,KAAK,KAAK;AAC1D,QAAI,IAAI,MAAM,GAAG,MAAM,GAAG;AACtB,WAAK,UACD,UAAU,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,KAAK;AAAA,IACvD,OACK;AACD,WAAK,UACD,UAAU,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,KAAK;AACnD,WAAK,UACD,QAAQ,KAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK;AACpD,WAAK,UACD,QAAQ,KAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK;AAAA,IACxD;AACA,QAAI,MAAM,IAAI;AACd,aAAS,IAAI,KAAK,IAAI,MAAM,KAAK,KAAK;AAClC,aAAO,IAAI,CAAC;AAAA,IAChB;AACA,aAAS,IAAI,MAAM,KAAK,IAAI,MAAM,KAAK,KAAK;AACxC,aAAO,IAAI,CAAC;AAAA,IAChB;AACA,SAAK,QAAQ;AACb,cAAU,KAAK,MAAM,KAAK,GAAG,KAAK,KAAK;AACvC,SAAK,aAAa;AAClB,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,OAAO;AACP,WAAQ,KAAK,UAAU,gBACnB,KAAK,QACHC,KAAW,IAAI,KAAK,KAAK;AAAA,EACnC;AAAA,EACA,IAAI,UAAU;AACV,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,IAAI,KAAK,MAAM;AACX,UAAM,IAAI,OAAOC,KAAW,IAAI,IAAI,CAAC;AACrC,QAAIF,OAAa,CAAC,KAAK,MAAM,eAAe;AACxC,WAAK,QAAQ;AAAA,IACjB,WACSA,OAAa,IAAI,GAAG;AACzB,WAAK,QAAQ;AAAA,IACjB,OACK;AACD,YAAM,IAAI,UAAU,yBAAyB,IAAI;AAAA,IACrD;AAAA,EACJ;AACJ;AACA,MAAM,cAAc,CAAC,GAAG,eAAe;AACnC,QAAM,WAAW;AACjB,MAAI,KAAK;AACT,MAAI,SAAS;AACb,MAAI,MAAM;AACV,QAAM,OAAOG,MAAW,MAAM,CAAC,EAAE,QAAQ;AACzC,MAAI,OAAO,WAAW,EAAE,IAAI,UAAU;AAClC,UAAM,CAAC,IAAI,QAAQ,KAAK;AAAA,EAC5B,OACK;AAED,aAASA,MAAW,QAAQ,EAAE;AAC9B,SAAKA,MAAW,SAAS,EAAE;AAC3B,OAAG;AACC,UAAI,OAAO,WAAW,EAAE,KAAK,YACzB,OAAO,WAAW,MAAM,KAAK,YAAY;AAEzC,cAAM,CAAC,IAAI,QAAQ,KAAK;AAAA,MAC5B,WACS,OAAO,WAAW,EAAE,IAAI,YAC7B,OAAO,WAAW,MAAM,KAAK,YAAY;AAEzC,cAAM,CAAC,GAAG,MAAM,GAAG,WAAW,CAAC,GAAG,QAAQ,IAAI;AAAA,MAClD,OACK;AAED,aAAKA,MAAW,KAAKA,MAAW,SAAS,MAAM,GAAG,EAAE;AACpD,iBAASA,MAAW,QAAQ,MAAM;AAAA,MACtC;AAAA,IACJ,SAAS,WAAW,QAAQ,QAAQ;AAEpC,QAAI,CAAC,KAAK;AACN,YAAM,CAAC,EAAE,MAAM,GAAG,WAAW,CAAC,GAAG,IAAI,IAAI;AAAA,IAC7C;AAAA,EACJ;AACA,SAAO;AACX;AACA,MAAM,YAAY,CAAC,KAAK,KAAK,SAAS,IACjC,SAAS,KAAK,MAAM,IAAI,EACxB,SAAS,MAAM,EACf,QAAQ,QAAQ,EAAE;AACvB,MAAM,UAAU,CAAC,KAAK,KAAK,SAAS,UAAU,UAAU,KAAK,KAAK,IAAI,CAAC;AACvE,MAAM,YAAY,CAAC,QAAQ,QAAQ,SAAY,SAAY,IAAI,KAAK,MAAM,GAAI;AAC9E,MAAM,YAAY,CAAC,KAAK,KAAK,SAAS,OAAO,IAAI,GAAG,CAAC,IAAI,MACrDC,QAAY,IAAI,SAAS,KAAK,MAAM,IAAI,CAAC,IACvC,eAAe,KAAK,KAAK,IAAI;AACnC,MAAM,WAAW,CAAC,UAAW,MAAM,KAAK,IAAI,SAAY;AACxD,MAAM,iBAAiB,CAAC,KAAK,KAAK,SAAS,SAAS,SAAS,IACxD,SAAS,KAAK,MAAM,IAAI,EACxB,SAAS,MAAM,EACf,QAAQ,SAAS,EAAE,EACnB,KAAI,GAAI,CAAC,CAAC;AAEf,MAAM,SAAS;AAAA,EACX,IAAI;AAAA,EACJ,GAAG;AACP;AACA,MAAM,YAAY,CAAC,KAAK,KAAK,MAAM,QAAQ,QAAQ,SAAY,QACzD,MAAM,OAAO,IAAI,KAAK,MAAM,KACzBC,SAAa,KAAK,IAAI,SAAS,KAAK,MAAM,IAAI,CAAC,GAAG,SAChD,eAAe,KAAK,KAAK,MAAM,GAAG,GAAG;AAChD,MAAM,iBAAiB,CAAC,KAAK,KAAK,MAAM,QAAQ,IAAI,MAAM,YAAY,KAAK,IAAI,GAAG,KAAK,MAAM,OAAO;AACpG,MAAM,cAAc,CAAC,KAAK,SAAS,SAAS,KAAK,MAAM,GAAG,EAAE,SAAS,CAAC,GAAG,IAAI;AAC7E,MAAM,WAAW,CAAC,KAAK,UAAU,IAAI,WAAW,OAAO,IACnD,MACE,IAAI,MAAM,OAAO,IAAI,SAAS,CAAC,EAAE,KAAK,GAAG,IAAI,MAAM,OAAO;AAChE,MAAM,UAAU,CAAC,KAAK,KAAK,MAAM,SAAS,SAAS,SAAY,QAAS,UAAU,KAAK,KAAK,MAAM,KAAK,QAAO,IAAK,GAAI;AAEvH,MAAM,QAAQ,IAAI,MAAM,GAAG,EAAE,KAAK,IAAI;AAEtC,MAAM,YAAY,CAAC,KAAK,KAAK,MAAM,QAAQ,QAAQ,SAAY,SAAU,IAAI,MAAM,MAAM,OAAO,KAAK,MAAM,MAAM,GAC7G,IAAI,WAAW,OAAO,WAAW,GAAG,KAAK,IAAI,SAAS;ACnRnD,MAAM,IAAI;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,KAAK,SAAS,OAAO;AAC7B,SAAK,QAAQ,IAAI;AACjB,SAAK,UAAU,IAAI;AACnB,SAAK,UAAU,IAAI;AACnB,SAAK,QAAQ,IAAI;AACjB,SAAK,MAAM,IAAI;AACf,SAAK,MAAM,IAAI;AACf,SAAK,SAAS;AACd,SAAK,QAAQ,IAAI;AACjB,SAAK,MAAM,IAAI;AACf,SAAK,WAAW,IAAI;AACpB,SAAK,QAAQ,IAAI;AACjB,SAAK,QAAQ,IAAI;AACjB,SAAK,OAAO,IAAI;AAChB,SAAK,OAAO,IAAI;AAChB,SAAK,MAAM,IAAI;AACf,SAAK,QAAQ,IAAI;AAAA,EACrB;AAAA,EACA,SAAS;AACL,UAAM,OAAO,KAAK,WAAU;AAC5B,QAAI,SAAS,IAAI;AACb,aAAO,OAAO,YAAY,CAAC;AAAA,IAC/B;AACA,UAAM,UAAU,OAAO,WAAW,IAAI;AAGtC,UAAM,SAAS,MAAM,KAAK,KAAK,IAAI,UAAU,GAAG;AAChD,UAAM,MAAM,OAAO,YAAY,MAAM;AAErC,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,UAAI,CAAC,IAAI;AAAA,IACb;AACA,QAAI,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA,MAKP,OAAO,eAAe,SAAS,KAAK,QAAQ,EAAE,GAAG,MAAM,GAAG,EAAE;AAAA;AAAA,MAE5D,MAAM,KAAK,QAAQ;AAAA,MACnB,KAAK,KAAK;AAAA,MACV,KAAK,KAAK;AAAA,MACV,MAAM;AAAA,MACN,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK,SAAS,yBAAyB;AAAA,MAC7C,UAAU;AAAA,MACV,OAAO,KAAK,SAAS;AAAA,MACrB,OAAO,KAAK,SAAS;AAAA,MACrB,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,OAAO,KAAK;AAAA,MACZ,OAAO,KAAK;AAAA,IACxB,CAAS,EAAE,OAAO,GAAG;AACb,QAAI,MAAM,MAAM,KAAK,SAAS,MAAM;AAEpC,aAAS,IAAI,UAAU,KAAK,IAAI,IAAI,QAAQ,KAAK;AAC7C,UAAI,CAAC,IAAI;AAAA,IACb;AACA,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AACT,WAAQ,KAAK,YAAY,MAAM,IAC3B,KAAK,YAAY,OAAO,IACxB,KAAK,YAAY,OAAO,IACxB,KAAK,YAAY,KAAK,IACtB,KAAK,YAAY,KAAK,IACtB,KAAK,YAAY,OAAO,IACxB,KAAK,YAAY,SAAS,IAC1B,KAAK,YAAY,SAAS,IAC1B,KAAK,YAAY,KAAK,IACtB,KAAK,YAAY,OAAO,IACxB,KAAK,YAAY,UAAU,IAC3B,KAAK,YAAY,OAAO,IACxB,KAAK,YAAY,MAAM,IACvB,KAAK,YAAY,KAAK,IACtB,KAAK,YAAY,OAAO;AAAA,EAChC;AAAA,EACA,YAAY,OAAO;AACf,QAAI,KAAK,KAAK,MAAM,QAAW;AAC3B,aAAO;AAAA,IACX;AACA,UAAM,IAAI,KAAK,KAAK;AACpB,UAAM,IAAI,aAAa,OAAO,EAAE,QAAO,IAAK,MAAO;AACnD,UAAM,IAAI,OACL,UAAU,SAAS,UAAU,SAAS,UAAU,UAC7C,YACE,MACN,QACA,MACA,IACA;AACJ,UAAM,UAAU,OAAO,WAAW,CAAC;AAInC,QAAI,SAAS,KAAK,MAAM,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,EAAE,CAAC,IAAI;AAC5D,QAAI,UAAU,UAAU,KAAK,IAAI,IAAI,MAAM,GAAG;AAC1C,gBAAU;AAAA,IACd;AACA,UAAM,MAAM,SAAS;AACrB,WAAO,MAAM;AAAA,EACjB;AAAA,EACA,OAAO,MAAM,KAAK,IAAI,IAAI,OAAO;AAC7B,WAAO,IAAI,IAAI,MAAM,QAAQ,GAAG,GAAG,EAAE,GAAG,CAAC;AAAA,EAC7C;AACJ;AACA,MAAM,QAAQ,CAAC,GAAG,MAAM,IAAI,OAAO,OAAO,IAAI,GAAG,CAAC,IAAI;AACtD,MAAM,UAAU,CAAC,QAAQ,IACpB,QAAQ,OAAO,EAAE,EACjB,MAAM,IAAI,EACV,OAAO,aAAa,uBAAO,OAAO,IAAI,CAAC;AAC5C,MAAM,cAAc,CAAC,KAAK,SAAS;AAC/B,QAAM,IAAI,SAAS,MAAM,EAAE;AAG3B,MAAI,MAAM,OAAO,WAAW,IAAI,IAAI,GAAG;AACnC,WAAO;AAAA,EACX;AACA,SAAO,KAAK,OAAO,IAAI,KAAK,MAAM;AAClC,QAAM,KAAK,KAAK,MAAM,GAAG;AACzB,QAAM,IAAI,GAAG,MAAK;AAClB,MAAI,CAAC,GAAG;AACJ,WAAO;AAAA,EACX;AACA,QAAM,IAAI,EAAE,QAAQ,4BAA4B,IAAI;AACpD,QAAM,IAAI,GAAG,KAAK,GAAG;AACrB,MAAI,CAAC,IACD,0CAA0C,KAAK,CAAC,IAC5C,IAAI,KAAK,OAAO,CAAC,IAAI,GAAI,IACvB,WAAW,KAAK,CAAC,IAAI,CAAC,IAClB;AACd,SAAO;AACX;ACpJA,MAAMC,aAAW,QAAQ,IAAI,6BAA6B,QAAQ;AAC3D,MAAM,uBAAuBA,eAAa,UAC7C,CAAC,MAAM,IACL,CAAC,MAAM,KAAK,EAAE,QAAQ,OAAO,GAAG;ACL/B,MAAM,kBAAkB,SAAS;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EACP,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,OAAO;AAAA,EACP;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,EACV;AAAA,EACA,cAAc;AAAA,EACd,YAAY,QAAQ,IAAI,KAAK;AACzB,UAAM,CAAA,CAAE;AAIR,SAAK,MAAK;AACV,SAAK,WAAW;AAChB,SAAK,iBAAiB;AACtB,SAAK,SAAS;AAEd,SAAK,SAAS,OAAO,QAAQ;AAE7B,SAAK,iBAAiB,MAAM,KAAK,KAAK,KAAK,SAAS,GAAG;AACvD,SAAK,cAAc,KAAK;AACxB,SAAK,OAAO,OAAO;AACnB,YAAQ,KAAK,MAAI;AAAA,MACb,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD;AAAA,MACJ,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,aAAK,OAAO;AACZ;AAAA;AAAA;AAAA,MAGJ;AACI,aAAK,SAAS;AAAA,IAC9B;AAEQ,QAAI,CAAC,OAAO,MAAM;AACd,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACxD;AAEA,SAAK,OAAO,qBAAqB,OAAO,IAAI;AAC5C,SAAK,OAAO,OAAO;AACnB,QAAI,KAAK,MAAM;AACX,WAAK,OAAO,KAAK,OAAO;AAAA,IAC5B;AACA,SAAK,MAAM,OAAO;AAClB,SAAK,MAAM,OAAO;AAClB,SAAK,QAAQ,OAAO;AACpB,SAAK,QAAQ,OAAO;AACpB,SAAK,OAAO,KAAK;AACjB,SAAK,QAAQ,OAAO;AACpB,SAAK,QAAQ,OAAO;AACpB,SAAK,QAAQ,OAAO;AAEpB,SAAK,WACD,OAAO,WACH,qBAAqB,OAAO,QAAQ,IAClC;AAEV,SAAK,QAAQ,OAAO;AACpB,SAAK,QAAQ,OAAO;AACpB,QAAI,IAAI;AACJ,WAAK,OAAO,EAAE;AAAA,IAClB;AACA,QAAI,KAAK;AACL,WAAK,OAAO,KAAK,IAAI;AAAA,IACzB;AAAA,EACJ;AAAA,EACA,MAAM,MAAM;AACR,UAAM,WAAW,KAAK;AACtB,QAAI,WAAW,KAAK,aAAa;AAC7B,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC/D;AACA,UAAM,IAAI,KAAK;AACf,UAAM,KAAK,KAAK;AAChB,SAAK,SAAS,KAAK,IAAI,GAAG,IAAI,QAAQ;AACtC,SAAK,cAAc,KAAK,IAAI,GAAG,KAAK,QAAQ;AAC5C,QAAI,KAAK,QAAQ;AACb,aAAO;AAAA,IACX;AACA,QAAI,KAAK,UAAU;AACf,aAAO,MAAM,MAAM,IAAI;AAAA,IAC3B;AAEA,WAAO,MAAM,MAAM,KAAK,SAAS,GAAG,CAAC,CAAC;AAAA,EAC1C;AAAA,EACA,OAAO,IAAI,MAAM,OAAO;AACpB,QAAI,GAAG;AACH,SAAG,OAAO,qBAAqB,GAAG,IAAI;AAC1C,QAAI,GAAG;AACH,SAAG,WAAW,qBAAqB,GAAG,QAAQ;AAClD,WAAO,OAAO,MAAM,OAAO,YAAY,OAAO,QAAQ,EAAE,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM;AAIzE,aAAO,EAAE,MAAM,QACX,MAAM,UACL,MAAM,UAAU;AAAA,IACzB,CAAC,CAAC,CAAC;AAAA,EACP;AACJ;ACtIO,MAAM,aAAa,CAAC,MAAMC,OAAM,SAAS,OAAO,CAAA,MAAO;AAC1D,MAAI,KAAK,MAAM;AACX,SAAK,OAAO,KAAK;AAAA,EACrB;AACA,MAAI,KAAK,KAAK;AACV,SAAK,MAAM,KAAK;AAAA,EACpB;AACA,OAAK,OACA,mBAAmB,SAChB,QAAQ,QACRA;AACR,OAAK,UAAUA;AACf,MAAI,CAAC,KAAK,UAAU,KAAK,gBAAgB,OAAO;AAC5C,QAAI,mBAAmB,OAAO;AAC1B,aAAO,OAAO,OAAO,SAAS,IAAI;AAClC,gBAAU,QAAQ;AAAA,IACtB;AACA,SAAK,KAAK,QAAQA,OAAM,SAAS,IAAI;AAAA,EACzC,WACS,mBAAmB,OAAO;AAC/B,SAAK,KAAK,SAAS,OAAO,OAAO,SAAS,IAAI,CAAC;AAAA,EACnD,OACK;AACD,SAAK,KAAK,SAAS,OAAO,OAAO,IAAI,MAAM,GAAGA,KAAI,KAAK,OAAO,EAAE,GAAG,IAAI,CAAC;AAAA,EAC5E;AACJ;ACAA,MAAM,mBAAmB,OAAO;AAChC,MAAM,aAAa,OAAO,KAAK,CAAC,IAAM,GAAI,CAAC;AAC3C,MAAM,aAAa,OAAO,KAAK,CAAC,IAAM,KAAM,IAAM,GAAI,CAAC;AACvD,MAAM,iBAAiB,KAAK,IAAI,WAAW,QAAQ,WAAW,MAAM;AACpE,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,eAAe,OAAO,cAAc;AAC1C,MAAM,KAAK,OAAO,gBAAgB;AAClC,MAAM,MAAM,OAAO,sBAAsB;AACzC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAMC,UAAQ,OAAO,OAAO;AAC5B,MAAMC,UAAQ,OAAO,OAAO;AAC5B,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,eAAe,OAAO,cAAc;AAC1C,MAAM,kBAAkB,OAAO,iBAAiB;AAChD,MAAM,cAAc,OAAO,aAAa;AACxC,MAAM,cAAc,OAAO,aAAa;AACxC,MAAM,gBAAgB,OAAO,eAAe;AAC5C,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,eAAe,OAAO,cAAc;AAC1C,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,OAAO,OAAO,QAAQ;AAC5B,MAAM,kBAAkB,OAAO,eAAe;AAC9C,MAAM,iBAAiB,OAAO,cAAc;AAC5C,MAAM,UAAU,OAAO,QAAQ;AAC/B,MAAM,cAAc,OAAO,aAAa;AACxC,MAAM,OAAO,MAAM;AACZ,MAAM,eAAeC,eAAG;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EACX,WAAW;AAAA,EACX,CAACF,OAAK,IAAI,CAAA;AAAA,EACV,CAAC,MAAM;AAAA,EACP,CAAC,SAAS;AAAA,EACV,CAAC,UAAU;AAAA,EACX,CAAC,KAAK,IAAI;AAAA,EACV,CAAC,IAAI,IAAI;AAAA,EACT,CAAC,EAAE;AAAA,EACH,CAAC,GAAG;AAAA,EACJ,CAACC,OAAK,IAAI;AAAA,EACV,CAAC,KAAK;AAAA,EACN,CAAC,OAAO,IAAI;AAAA,EACZ,CAAC,eAAe;AAAA,EAChB,CAAC,cAAc,IAAI;AAAA,EACnB,CAAC,OAAO,IAAI;AAAA,EACZ,CAAC,OAAO,IAAI;AAAA,EACZ,CAAC,SAAS,IAAI;AAAA,EACd,CAAC,UAAU,IAAI;AAAA,EACf,YAAY,MAAM,IAAI;AAClB,UAAK;AACL,SAAK,OAAO,IAAI,QAAQ;AAExB,SAAK,GAAG,MAAM,MAAM;AAChB,UAAI,KAAK,KAAK,MAAM,WAChB,KAAK,eAAe,MAAM,OAAO;AAGjC,aAAK,KAAK,mBAAmB,6BAA6B;AAAA,MAC9D;AAAA,IACJ,CAAC;AACD,QAAI,IAAI,QAAQ;AACZ,WAAK,GAAG,MAAM,IAAI,MAAM;AAAA,IAC5B,OACK;AACD,WAAK,GAAG,MAAM,MAAM;AAChB,aAAK,KAAK,WAAW;AACrB,aAAK,KAAK,QAAQ;AAClB,aAAK,KAAK,KAAK;AAAA,MACnB,CAAC;AAAA,IACL;AACA,SAAK,SAAS,CAAC,CAAC,IAAI;AACpB,SAAK,mBAAmB,IAAI,oBAAoB;AAChD,SAAK,SAAS,OAAO,IAAI,WAAW,aAAa,IAAI,SAAS;AAI9D,UAAM,QAAQ,IAAI,SACb,IAAI,KAAK,SAAS,SAAS,KAAK,IAAI,KAAK,SAAS,MAAM;AAG7D,SAAK,SACD,EAAE,IAAI,QAAQ,IAAI,SAAS,IAAI,WAAW,SAAY,IAAI,SACpD,QAAQ,SACJ;AAGd,UAAM,SAAS,IAAI,SACd,IAAI,KAAK,SAAS,UAAU,KAAK,IAAI,KAAK,SAAS,OAAO;AAC/D,SAAK,OACD,EAAE,IAAI,QAAQ,IAAI,WAAW,IAAI,SAAS,SAAY,IAAI,OACpD,SAAS,OACL;AAEd,SAAK,GAAG,OAAO,MAAM,KAAK,WAAW,EAAC,CAAE;AACxC,QAAI,OAAO,IAAI,WAAW,YAAY;AAClC,WAAK,GAAG,QAAQ,IAAI,MAAM;AAAA,IAC9B;AACA,QAAI,OAAO,IAAI,gBAAgB,YAAY;AACvC,WAAK,GAAG,SAAS,IAAI,WAAW;AAAA,IACpC;AAAA,EACJ;AAAA,EACA,KAAKF,OAAM,SAAS,OAAO,CAAA,GAAI;AAC3B,eAAW,MAAMA,OAAM,SAAS,IAAI;AAAA,EACxC;AAAA,EACA,CAAC,aAAa,EAAE,OAAO,UAAU;AAC7B,QAAI,KAAK,eAAe,MAAM,QAAW;AACrC,WAAK,eAAe,IAAI;AAAA,IAC5B;AACA,QAAI;AACJ,QAAI;AACA,eAAS,IAAI,OAAO,OAAO,UAAU,KAAK,EAAE,GAAG,KAAK,GAAG,CAAC;AAAA,IAC5D,SACO,IAAI;AACP,aAAO,KAAK,KAAK,qBAAqB,EAAE;AAAA,IAC5C;AACA,QAAI,OAAO,WAAW;AAClB,UAAI,KAAK,cAAc,GAAG;AACtB,aAAK,OAAO,IAAI;AAEhB,YAAI,KAAK,KAAK,MAAM,SAAS;AACzB,eAAK,KAAK,IAAI;AAAA,QAClB;AACA,aAAK,IAAI,EAAE,KAAK;AAAA,MACpB,OACK;AACD,aAAK,cAAc,IAAI;AACvB,aAAK,IAAI,EAAE,WAAW;AAAA,MAC1B;AAAA,IACJ,OACK;AACD,WAAK,cAAc,IAAI;AACvB,UAAI,CAAC,OAAO,YAAY;AACpB,aAAK,KAAK,qBAAqB,oBAAoB,EAAE,OAAM,CAAE;AAAA,MACjE,WACS,CAAC,OAAO,MAAM;AACnB,aAAK,KAAK,qBAAqB,oBAAoB,EAAE,OAAM,CAAE;AAAA,MACjE,OACK;AACD,cAAM,OAAO,OAAO;AACpB,YAAI,oBAAoB,KAAK,IAAI,KAAK,CAAC,OAAO,UAAU;AACpD,eAAK,KAAK,qBAAqB,qBAAqB;AAAA,YAChD;AAAA,UACxB,CAAqB;AAAA,QACL,WACS,CAAC,oBAAoB,KAAK,IAAI,KACnC,CAAC,4BAA4B,KAAK,IAAI,KACtC,OAAO,UAAU;AACjB,eAAK,KAAK,qBAAqB,sBAAsB;AAAA,YACjD;AAAA,UACxB,CAAqB;AAAA,QACL,OACK;AACD,gBAAM,QAAS,KAAK,UAAU,IAAI,IAAI,UAAU,QAAQ,KAAK,EAAE,GAAG,KAAK,GAAG,CAAC;AAG3E,cAAI,CAAC,KAAK,eAAe,GAAG;AACxB,gBAAI,MAAM,QAAQ;AAEd,oBAAM,QAAQ,MAAM;AAChB,oBAAI,CAAC,MAAM,SAAS;AAChB,uBAAK,eAAe,IAAI;AAAA,gBAC5B;AAAA,cACJ;AACA,oBAAM,GAAG,OAAO,KAAK;AAAA,YACzB,OACK;AACD,mBAAK,eAAe,IAAI;AAAA,YAC5B;AAAA,UACJ;AACA,cAAI,MAAM,MAAM;AACZ,gBAAI,MAAM,OAAO,KAAK,kBAAkB;AACpC,oBAAM,SAAS;AACf,mBAAK,IAAI,EAAE,gBAAgB,KAAK;AAChC,mBAAK,KAAK,IAAI;AACd,oBAAM,OAAM;AAAA,YAChB,WACS,MAAM,OAAO,GAAG;AACrB,mBAAK,IAAI,IAAI;AACb,oBAAM,GAAG,QAAQ,OAAM,KAAK,IAAI,KAAK,CAAE;AACvC,mBAAK,KAAK,IAAI;AAAA,YAClB;AAAA,UACJ,OACK;AACD,iBAAK,EAAE,IAAI;AACX,kBAAM,SACF,MAAM,UAAU,CAAC,KAAK,OAAO,MAAM,MAAM,KAAK;AAClD,gBAAI,MAAM,QAAQ;AAEd,mBAAK,IAAI,EAAE,gBAAgB,KAAK;AAChC,mBAAK,KAAK,IAAI,MAAM,SAAS,WAAW;AACxC,oBAAM,OAAM;AAAA,YAChB,OACK;AACD,kBAAI,MAAM,QAAQ;AACd,qBAAK,KAAK,IAAI;AAAA,cAClB,OACK;AACD,qBAAK,KAAK,IAAI;AACd,sBAAM,IAAG;AAAA,cACb;AACA,kBAAI,CAAC,KAAK,SAAS,GAAG;AAClB,qBAAKC,OAAK,EAAE,KAAK,KAAK;AACtB,qBAAK,SAAS,EAAC;AAAA,cACnB,OACK;AACD,qBAAKA,OAAK,EAAE,KAAK,KAAK;AAAA,cAC1B;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,CAAC,WAAW,IAAI;AACZ,mBAAe,MAAM,KAAK,KAAK,OAAO,CAAC;AAAA,EAC3C;AAAA,EACA,CAAC,YAAY,EAAE,OAAO;AAClB,QAAI,KAAK;AACT,QAAI,CAAC,OAAO;AACR,WAAK,SAAS,IAAI;AAClB,WAAK;AAAA,IACT,WACS,MAAM,QAAQ,KAAK,GAAG;AAC3B,YAAM,CAAC,IAAI,GAAG,IAAI,IAAI;AACtB,WAAK,KAAK,IAAI,GAAG,IAAI;AAAA,IACzB,OACK;AACD,WAAK,SAAS,IAAI;AAClB,WAAK,KAAK,SAAS,KAAK;AACxB,UAAI,CAAC,MAAM,YAAY;AACnB,cAAM,GAAG,OAAO,MAAM,KAAK,SAAS,EAAC,CAAE;AACvC,aAAK;AAAA,MACT;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,CAAC,SAAS,IAAI;AACV,OAAG;AAAA,IAAE,SAAS,KAAK,YAAY,EAAE,KAAKA,OAAK,EAAE,OAAO;AACpD,QAAI,CAAC,KAAKA,OAAK,EAAE,QAAQ;AAQrB,YAAM,KAAK,KAAK,SAAS;AACzB,YAAM,WAAW,CAAC,MAAM,GAAG,WAAW,GAAG,SAAS,GAAG;AACrD,UAAI,UAAU;AACV,YAAI,CAAC,KAAK,OAAO,GAAG;AAChB,eAAK,KAAK,OAAO;AAAA,QACrB;AAAA,MACJ,OACK;AACD,WAAG,KAAK,SAAS,MAAM,KAAK,KAAK,OAAO,CAAC;AAAA,MAC7C;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,CAAC,WAAW,EAAE,OAAO,UAAU;AAE3B,UAAM,QAAQ,KAAK,UAAU;AAE7B,QAAI,CAAC,OAAO;AACR,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC7D;AACA,UAAM,KAAK,MAAM,eAAe;AAEhC,UAAM,IAAI,MAAM,MAAM,UAAU,aAAa,IACzC,QACE,MAAM,SAAS,UAAU,WAAW,EAAE;AAC5C,UAAM,MAAM,CAAC;AACb,QAAI,CAAC,MAAM,aAAa;AACpB,WAAK,KAAK,IAAI;AACd,WAAK,UAAU,IAAI;AACnB,YAAM,IAAG;AAAA,IACb;AACA,WAAO,EAAE;AAAA,EACb;AAAA,EACA,CAAC,WAAW,EAAE,OAAO,UAAU;AAC3B,UAAM,QAAQ,KAAK,UAAU;AAC7B,UAAM,MAAM,KAAK,WAAW,EAAE,OAAO,QAAQ;AAE7C,QAAI,CAAC,KAAK,UAAU,KAAK,OAAO;AAC5B,WAAK,QAAQ,EAAE,KAAK;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AAAA,EACA,CAAC,IAAI,EAAE,IAAI,MAAM,OAAO;AACpB,QAAI,CAAC,KAAKA,OAAK,EAAE,UAAU,CAAC,KAAK,SAAS,GAAG;AACzC,WAAK,KAAK,IAAI,MAAM,KAAK;AAAA,IAC7B,OACK;AACD,WAAKA,OAAK,EAAE,KAAK,CAAC,IAAI,MAAM,KAAK,CAAC;AAAA,IACtC;AAAA,EACJ;AAAA,EACA,CAAC,QAAQ,EAAE,OAAO;AACd,SAAK,IAAI,EAAE,QAAQ,KAAK,IAAI,CAAC;AAC7B,YAAQ,MAAM,MAAI;AAAA,MACd,KAAK;AAAA,MACL,KAAK;AACD,aAAK,EAAE,IAAI,IAAI,MAAM,KAAK,IAAI,GAAG,KAAK,EAAE,GAAG,KAAK;AAChD;AAAA,MACJ,KAAK;AACD,aAAK,GAAG,IAAI,IAAI,MAAM,KAAK,IAAI,GAAG,KAAK,GAAG,GAAG,IAAI;AACjD;AAAA,MACJ,KAAK;AAAA,MACL,KAAK,kBAAkB;AACnB,cAAM,KAAK,KAAK,EAAE,KAAK,uBAAO,OAAO,IAAI;AACzC,aAAK,EAAE,IAAI;AACX,WAAG,OAAO,KAAK,IAAI,EAAE,QAAQ,QAAQ,EAAE;AACvC;AAAA,MACJ;AAAA,MACA,KAAK,2BAA2B;AAC5B,cAAM,KAAK,KAAK,EAAE,KAAK,uBAAO,OAAO,IAAI;AACzC,aAAK,EAAE,IAAI;AACX,WAAG,WAAW,KAAK,IAAI,EAAE,QAAQ,QAAQ,EAAE;AAC3C;AAAA,MACJ;AAAA;AAAA,MAEA;AACI,cAAM,IAAI,MAAM,mBAAmB,MAAM,IAAI;AAAA,IAE7D;AAAA,EACI;AAAA,EACA,MAAM,OAAO;AACT,SAAK,OAAO,IAAI;AAChB,SAAK,KAAK,SAAS,KAAK;AAExB,SAAK,KAAK,aAAa,OAAO,EAAE,aAAa,OAAO;AAAA,EACxD;AAAA,EACA,MAAM,OAAO,UAAU,IAAI;AACvB,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AACA,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,OAAO;AAAA,QAAK;AAAA;AAAA,QAEpB,OAAO,aAAa,WAAW,WAAW;AAAA,MAAM;AAAA,IACpD;AACA,QAAI,KAAK,OAAO,GAAG;AAEf,WAAE;AACF,aAAO;AAAA,IACX;AAEA,UAAM,YAAY,KAAK,KAAK,MAAM,UAC7B,KAAK,WAAW,UAAa,KAAK,KAAK,MAAM;AAClD,QAAI,aAAa,OAAO;AACpB,UAAI,KAAK,MAAM,GAAG;AACd,gBAAQ,OAAO,OAAO,CAAC,KAAK,MAAM,GAAG,KAAK,CAAC;AAC3C,aAAK,MAAM,IAAI;AAAA,MACnB;AACA,UAAI,MAAM,SAAS,gBAAgB;AAC/B,aAAK,MAAM,IAAI;AAEf,aAAE;AACF,eAAO;AAAA,MACX;AAEA,eAAS,IAAI,GAAG,KAAK,KAAK,MAAM,UAAa,IAAI,WAAW,QAAQ,KAAK;AACrE,YAAI,MAAM,CAAC,MAAM,WAAW,CAAC,GAAG;AAC5B,eAAK,KAAK,IAAI;AAAA,QAClB;AAAA,MACJ;AAEA,UAAI,SAAS;AACb,UAAI,KAAK,KAAK,MAAM,SAAS,KAAK,SAAS,OAAO;AAC9C,iBAAS;AACT,iBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACxC,cAAI,MAAM,CAAC,MAAM,WAAW,CAAC,GAAG;AAC5B,qBAAS;AACT;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,YAAM,cAAc,KAAK,WAAW,UAAa,CAAC;AAClD,UAAI,KAAK,KAAK,MAAM,SAAS,aAAa;AAKtC,YAAI,MAAM,SAAS,KAAK;AACpB,cAAI,KAAKC,OAAK,GAAG;AACb,iBAAK,SAAS;AAAA,UAClB,OACK;AACD,iBAAK,MAAM,IAAI;AAEf,iBAAE;AACF,mBAAO;AAAA,UACX;AAAA,QACJ,OACK;AAGD,cAAI;AACA,gBAAI,OAAO,MAAM,SAAS,GAAG,GAAG,CAAC;AACjC,iBAAK,SAAS;AAAA,UAClB,SACO,GAAG;AACN,iBAAK,SAAS;AAAA,UAClB;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,KAAK,KAAK,MAAM,UACf,KAAK,KAAK,MAAM,UAAU,KAAK,UAAU,SAAU;AACpD,cAAM,QAAQ,KAAKA,OAAK;AACxB,aAAKA,OAAK,IAAI;AACd,aAAK,KAAK,IACN,KAAK,KAAK,MAAM,SACZ,IAAI,MAAM,CAAA,CAAE,IACV,SACE,IAAI,eAAe,CAAA,CAAE,IACnB,IAAI,iBAAiB,CAAA,CAAE;AACrC,aAAK,KAAK,EAAE,GAAG,QAAQ,CAAAE,WAAS,KAAK,YAAY,EAAEA,MAAK,CAAC;AACzD,aAAK,KAAK,EAAE,GAAG,SAAS,QAAM,KAAK,MAAM,EAAE,CAAC;AAC5C,aAAK,KAAK,EAAE,GAAG,OAAO,MAAM;AACxB,eAAKF,OAAK,IAAI;AACd,eAAK,YAAY,EAAC;AAAA,QACtB,CAAC;AACD,aAAK,OAAO,IAAI;AAChB,cAAMjB,OAAM,CAAC,CAAC,KAAK,KAAK,EAAE,QAAQ,QAAQ,OAAO,EAAE,KAAK;AACxD,aAAK,OAAO,IAAI;AAChB,aAAE;AACF,eAAOA;AAAA,MACX;AAAA,IACJ;AACA,SAAK,OAAO,IAAI;AAChB,QAAI,KAAK,KAAK,GAAG;AACb,WAAK,KAAK,EAAE,MAAM,KAAK;AAAA,IAC3B,OACK;AACD,WAAK,YAAY,EAAE,KAAK;AAAA,IAC5B;AACA,SAAK,OAAO,IAAI;AAEhB,UAAM,MAAM,KAAKgB,OAAK,EAAE,SAAS,QAC3B,KAAK,SAAS,IAAI,KAAK,SAAS,EAAE,UAC9B;AAEV,QAAI,CAAC,OAAO,CAAC,KAAKA,OAAK,EAAE,QAAQ;AAC7B,WAAK,SAAS,GAAG,KAAK,SAAS,MAAM,KAAK,KAAK,OAAO,CAAC;AAAA,IAC3D;AAEA,SAAE;AACF,WAAO;AAAA,EACX;AAAA,EACA,CAAC,YAAY,EAAE,GAAG;AACd,QAAI,KAAK,CAAC,KAAK,OAAO,GAAG;AACrB,WAAK,MAAM,IACP,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,KAAK,MAAM,GAAG,CAAC,CAAC,IAAI;AAAA,IAC1D;AAAA,EACJ;AAAA,EACA,CAAC,QAAQ,IAAI;AACT,QAAI,KAAKC,OAAK,KACV,CAAC,KAAK,UAAU,KAChB,CAAC,KAAK,OAAO,KACb,CAAC,KAAK,SAAS,GAAG;AAClB,WAAK,UAAU,IAAI;AACnB,YAAM,QAAQ,KAAK,UAAU;AAC7B,UAAI,SAAS,MAAM,aAAa;AAE5B,cAAM,OAAO,KAAK,MAAM,IAAI,KAAK,MAAM,EAAE,SAAS;AAClD,aAAK,KAAK,mBAAmB,2BAA2B,MAAM,WAAW,qBAAqB,IAAI,eAAe,EAAE,MAAK,CAAE;AAC1H,YAAI,KAAK,MAAM,GAAG;AACd,gBAAM,MAAM,KAAK,MAAM,CAAC;AAAA,QAC5B;AACA,cAAM,IAAG;AAAA,MACb;AACA,WAAK,IAAI,EAAE,IAAI;AAAA,IACnB;AAAA,EACJ;AAAA,EACA,CAAC,YAAY,EAAE,OAAO;AAClB,QAAI,KAAK,SAAS,KAAK,OAAO;AAC1B,WAAK,YAAY,EAAE,KAAK;AAAA,IAC5B,WACS,CAAC,SAAS,CAAC,KAAK,MAAM,GAAG;AAC9B,WAAK,QAAQ,EAAC;AAAA,IAClB,WACS,OAAO;AACZ,WAAK,SAAS,IAAI;AAClB,UAAI,KAAK,MAAM,GAAG;AACd,aAAK,YAAY,EAAE,KAAK;AACxB,cAAM,IAAI,KAAK,MAAM;AACrB,aAAK,MAAM,IAAI;AACf,aAAK,eAAe,EAAE,CAAC;AAAA,MAC3B,OACK;AACD,aAAK,eAAe,EAAE,KAAK;AAAA,MAC/B;AACA,aAAO,KAAK,MAAM,KACd,KAAK,MAAM,GAAG,UAAU,OACxB,CAAC,KAAK,OAAO,KACb,CAAC,KAAK,OAAO,GAAG;AAChB,cAAM,IAAI,KAAK,MAAM;AACrB,aAAK,MAAM,IAAI;AACf,aAAK,eAAe,EAAE,CAAC;AAAA,MAC3B;AACA,WAAK,SAAS,IAAI;AAAA,IACtB;AACA,QAAI,CAAC,KAAK,MAAM,KAAK,KAAKA,OAAK,GAAG;AAC9B,WAAK,QAAQ,EAAC;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,CAAC,eAAe,EAAE,OAAO;AAGrB,QAAI,WAAW;AACf,UAAM,SAAS,MAAM;AACrB,WAAO,WAAW,OAAO,UACrB,CAAC,KAAK,OAAO,KACb,CAAC,KAAK,OAAO,GAAG;AAChB,cAAQ,KAAK,KAAK,GAAC;AAAA,QACf,KAAK;AAAA,QACL,KAAK;AACD,eAAK,aAAa,EAAE,OAAO,QAAQ;AACnC,sBAAY;AACZ;AAAA,QACJ,KAAK;AAAA,QACL,KAAK;AACD,sBAAY,KAAK,WAAW,EAAE,OAAO,QAAQ;AAC7C;AAAA,QACJ,KAAK;AACD,sBAAY,KAAK,WAAW,EAAE,OAAO,QAAQ;AAC7C;AAAA;AAAA,QAEJ;AACI,gBAAM,IAAI,MAAM,oBAAoB,KAAK,KAAK,CAAC;AAAA,MAEnE;AAAA,IACQ;AACA,QAAI,WAAW,QAAQ;AACnB,UAAI,KAAK,MAAM,GAAG;AACd,aAAK,MAAM,IAAI,OAAO,OAAO;AAAA,UACzB,MAAM,SAAS,QAAQ;AAAA,UACvB,KAAK,MAAM;AAAA,QAC/B,CAAiB;AAAA,MACL,OACK;AACD,aAAK,MAAM,IAAI,MAAM,SAAS,QAAQ;AAAA,MAC1C;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,IAAI,OAAO,UAAU,IAAI;AACrB,QAAI,OAAO,UAAU,YAAY;AAC7B,WAAK;AACL,iBAAW;AACX,cAAQ;AAAA,IACZ;AACA,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AACA,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,OAAO,KAAK,OAAO,QAAQ;AAAA,IACvC;AACA,QAAI;AACA,WAAK,KAAK,UAAU,EAAE;AAC1B,QAAI,CAAC,KAAK,OAAO,GAAG;AAChB,UAAI,KAAK,KAAK,GAAG;AAEb,YAAI;AACA,eAAK,KAAK,EAAE,MAAM,KAAK;AAE3B,aAAK,KAAK,EAAE,IAAG;AAAA,MACnB,OACK;AACD,aAAKA,OAAK,IAAI;AACd,YAAI,KAAK,WAAW,UAAa,KAAK,SAAS;AAC3C,kBAAQ,SAAS,OAAO,MAAM,CAAC;AACnC,YAAI;AACA,eAAK,MAAM,KAAK;AACpB,aAAK,QAAQ,EAAC;AAAA,MAClB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;ACpmBO,MAAM,uBAAuB,CAAC,QAAQ;AACzC,MAAI,IAAI,IAAI,SAAS;AACrB,MAAI,eAAe;AACnB,SAAO,IAAI,MAAM,IAAI,OAAO,CAAC,MAAM,KAAK;AACpC,mBAAe;AACf;AAAA,EACJ;AACA,SAAO,iBAAiB,KAAK,MAAM,IAAI,MAAM,GAAG,YAAY;AAChE;ACLA,MAAM,sBAAsB,CAAC,QAAQ;AACjC,QAAM,cAAc,IAAI;AACxB,MAAI,cACA,cACI,OAAK;AACD,gBAAY,CAAC;AACb,MAAE,OAAM;AAAA,EACZ,IACE,OAAK,EAAE,OAAM;AAC3B;AAGO,MAAM,cAAc,CAAC,KAAK,UAAU;AACvC,QAAM,MAAM,IAAI,IAAI,MAAM,IAAI,OAAK,CAAC,qBAAqB,CAAC,GAAG,IAAI,CAAC,CAAC;AACnE,QAAM,SAAS,IAAI;AACnB,QAAM,SAAS,CAAC,MAAM,IAAI,OAAO;AAC7B,UAAM,OAAO,KAAKV,QAAM,IAAI,EAAE,QAAQ;AACtC,QAAI;AACJ,QAAI,SAAS;AACT,YAAM;AAAA,SACL;AACD,YAAM,IAAI,IAAI,IAAI,IAAI;AACtB,UAAI,MAAM,QAAW;AACjB,cAAM;AAAA,MACV,OACK;AACD,cAAM,OAAO,QAAQ,IAAI,GAAG,IAAI;AAAA,MACpC;AAAA,IACJ;AACA,QAAI,IAAI,MAAM,GAAG;AACjB,WAAO;AAAA,EACX;AACA,MAAI,SACA,SACI,CAAC,MAAM,UAAU,OAAO,MAAM,KAAK,KAAK,OAAO,qBAAqB,IAAI,CAAC,IACvE,UAAQ,OAAO,qBAAqB,IAAI,CAAC;AACvD;AACA,MAAM,eAAe,CAAC,QAAQ;AAC1B,QAAM,IAAI,IAAI,OAAO,GAAG;AACxB,QAAM,OAAO,IAAI;AACjB,MAAI;AACJ,MAAI;AACA,SAAKa,YAAG,SAAS,MAAM,GAAG;AAC1B,UAAM,OAAOA,YAAG,UAAU,EAAE;AAC5B,UAAM,WAAW,IAAI,eAAe,KAAK,OAAO;AAChD,QAAI,KAAK,OAAO,UAAU;AACtB,YAAM,MAAM,OAAO,YAAY,KAAK,IAAI;AACxCA,kBAAG,SAAS,IAAI,KAAK,GAAG,KAAK,MAAM,CAAC;AACpC,QAAE,IAAI,GAAG;AAAA,IACb,OACK;AACD,UAAIC,OAAM;AACV,YAAM,MAAM,OAAO,YAAY,QAAQ;AACvC,aAAOA,OAAM,KAAK,MAAM;AACpB,cAAM,YAAYD,YAAG,SAAS,IAAI,KAAK,GAAG,UAAUC,IAAG;AACvD,QAAAA,QAAO;AACP,UAAE,MAAM,IAAI,SAAS,GAAG,SAAS,CAAC;AAAA,MACtC;AACA,QAAE,IAAG;AAAA,IACT;AAAA,EACJ,UACJ;AACQ,QAAI,OAAO,OAAO,UAAU;AACxB,UAAI;AACAD,oBAAG,UAAU,EAAE;AAAA,MAEnB,SACO,IAAI;AAAA,MAAE;AAAA,IACjB;AAAA,EACJ;AACJ;AACA,MAAM,WAAW,CAAC,KAAK,WAAW;AAC9B,QAAMb,SAAQ,IAAI,OAAO,GAAG;AAC5B,QAAM,WAAW,IAAI,eAAe,KAAK,OAAO;AAChD,QAAM,OAAO,IAAI;AACjB,QAAM,IAAI,IAAI,QAAQ,CAACN,UAAS,WAAW;AACvC,IAAAM,OAAM,GAAG,SAAS,MAAM;AACxB,IAAAA,OAAM,GAAG,OAAON,QAAO;AACvBmB,gBAAG,KAAK,MAAM,CAAC,IAAI,SAAS;AACxB,UAAI,IAAI;AACJ,eAAO,EAAE;AAAA,MACb,OACK;AACD,cAAM,SAAS,IAAIE,WAAe,MAAM;AAAA,UACpC;AAAA,UACA,MAAM,KAAK;AAAA,QAC/B,CAAiB;AACD,eAAO,GAAG,SAAS,MAAM;AACzB,eAAO,KAAKf,MAAK;AAAA,MACrB;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACD,SAAO;AACX;AACO,MAAM,OAAO,YAAY,cAAc,UAAU,SAAO,IAAI,OAAO,GAAG,GAAG,SAAO,IAAI,OAAO,GAAG,GAAG,CAAC,KAAK,UAAU;AACpH,MAAI,OAAO;AACP,gBAAY,KAAK,KAAK;AAC1B,MAAI,CAAC,IAAI;AACL,wBAAoB,GAAG;AAC/B,CAAC;AC1GM,MAAM,UAAU,CAAC,MAAM,OAAO,aAAa;AAC9C,UAAQ;AAMR,MAAI,UAAU;AACV,YAAQ,OAAO,OAAS;AAAA,EAC5B;AAEA,MAAI,OAAO;AACP,QAAI,OAAO,KAAO;AACd,cAAQ;AAAA,IACZ;AACA,QAAI,OAAO,IAAM;AACb,cAAQ;AAAA,IACZ;AACA,QAAI,OAAO,GAAK;AACZ,cAAQ;AAAA,IACZ;AAAA,EACJ;AACA,SAAO;AACX;ACrBA,MAAM,EAAE,YAAY,MAAK,IAAK;AAOvB,MAAM,oBAAoB,CAAC,SAAS;AACvC,MAAI,IAAI;AACR,MAAI,SAAS,MAAM,IAAI;AACvB,SAAO,WAAW,IAAI,KAAK,OAAO,MAAM;AAGpC,UAAM,OAAO,KAAK,OAAO,CAAC,MAAM,OAAO,KAAK,MAAM,GAAG,CAAC,MAAM,SACxD,MACE,OAAO;AACb,WAAO,KAAK,MAAM,KAAK,MAAM;AAC7B,SAAK;AACL,aAAS,MAAM,IAAI;AAAA,EACvB;AACA,SAAO,CAAC,GAAG,IAAI;AACnB;ACrBA,MAAM,MAAM,CAAC,KAAK,KAAK,KAAK,KAAK,GAAG;AACpC,MAAM,MAAM,IAAI,IAAI,UAAQ,OAAO,aAAa,QAAS,KAAK,WAAW,CAAC,CAAC,CAAC;AAC5E,MAAM,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;AAC1D,MAAM,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;AACnD,MAAM,SAAS,CAAC,MAAM,IAAI,OAAO,CAACgB,IAAG,MAAMA,GAAE,MAAM,CAAC,EAAE,KAAK,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC;AAC3E,MAAM,SAAS,CAAC,MAAM,IAAI,OAAO,CAACA,IAAG,MAAMA,GAAE,MAAM,CAAC,EAAE,KAAK,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC;ACKlF,MAAM,aAAa,CAAC,MAAM,WAAW;AACjC,MAAI,CAAC,QAAQ;AACT,WAAO,qBAAqB,IAAI;AAAA,EACpC;AACA,SAAO,qBAAqB,IAAI,EAAE,QAAQ,aAAa,EAAE;AACzD,SAAO,qBAAqB,MAAM,IAAI,MAAM;AAChD;AACA,MAAM,cAAc,KAAK,OAAO;AAChC,MAAMC,YAAU,OAAO,SAAS;AAChC,MAAMC,SAAO,OAAO,MAAM;AAC1B,MAAMC,cAAY,OAAO,WAAW;AACpC,MAAMC,YAAU,OAAO,SAAS;AAChC,MAAMC,aAAW,OAAO,UAAU;AAClC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,aAAa,OAAO,YAAY;AACtC,MAAMC,YAAU,OAAO,SAAS;AAChC,MAAM,SAAS,OAAO,QAAQ;AACvB,MAAM,mBAAmB,SAAS;AAAA,EACrC;AAAA,EACA;AAAA,EACA,QAAS,QAAQ,UAAU,QAAQ,OAAM,KAAO;AAAA;AAAA,EAEhD,SAAS,QAAQ,IAAI,QAAQ;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW;AAAA,EACX,cAAc;AAAA,EACd;AAAA,EACA,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY;AAAA,EACZ,YAAY,GAAG,OAAO,IAAI;AACtB,UAAM,MAAM,QAAQ,IAAI;AACxB,UAAK;AACL,SAAK,OAAO,qBAAqB,CAAC;AAElC,SAAK,WAAW,CAAC,CAAC,IAAI;AACtB,SAAK,cAAc,IAAI,eAAe;AACtC,SAAK,YAAY,IAAI,aAAa,oBAAI,IAAG;AACzC,SAAK,YAAY,IAAI,aAAa,oBAAI,IAAG;AACzC,SAAK,gBAAgB,CAAC,CAAC,IAAI;AAC3B,SAAK,MAAM,qBAAqB,IAAI,OAAO,QAAQ,KAAK;AACxD,SAAK,SAAS,CAAC,CAAC,IAAI;AACpB,SAAK,QAAQ,CAAC,CAAC,IAAI;AACnB,SAAK,UAAU,CAAC,CAAC,IAAI;AACrB,SAAK,QAAQ,IAAI;AACjB,SAAK,SACD,IAAI,SAAS,qBAAqB,IAAI,MAAM,IAAI;AACpD,SAAK,eAAe,IAAI;AACxB,QAAI,OAAO,IAAI,WAAW,YAAY;AAClC,WAAK,GAAG,QAAQ,IAAI,MAAM;AAAA,IAC9B;AACA,QAAI,WAAW;AACf,QAAI,CAAC,KAAK,eAAe;AACrB,YAAM,CAAC,MAAM,QAAQ,IAAI,kBAAkB,KAAK,IAAI;AACpD,UAAI,QAAQ,OAAO,aAAa,UAAU;AACtC,aAAK,OAAO;AACZ,mBAAW;AAAA,MACf;AAAA,IACJ;AACA,SAAK,QAAQ,CAAC,CAAC,IAAI,SAAS,QAAQ,aAAa;AACjD,QAAI,KAAK,OAAO;AAGZ,WAAK,OAAOC,OAAgB,KAAK,KAAK,QAAQ,OAAO,GAAG,CAAC;AACzD,UAAI,EAAE,QAAQ,OAAO,GAAG;AAAA,IAC5B;AACA,SAAK,WAAW,qBAAqB,IAAI,YAAYC,WAAK,QAAQ,KAAK,KAAK,CAAC,CAAC;AAC9E,QAAI,KAAK,SAAS,IAAI;AAClB,WAAK,OAAO;AAAA,IAChB;AACA,QAAI,UAAU;AACV,WAAK,KAAK,kBAAkB,aAAa,QAAQ,uBAAuB;AAAA,QACpE,OAAO;AAAA,QACP,MAAM,WAAW,KAAK;AAAA,MACtC,CAAa;AAAA,IACL;AACA,UAAM,KAAK,KAAK,UAAU,IAAI,KAAK,QAAQ;AAC3C,QAAI,IAAI;AACJ,WAAK,OAAO,EAAE,EAAE;AAAA,IACpB,OACK;AACD,WAAK,KAAK,EAAC;AAAA,IACf;AAAA,EACJ;AAAA,EACA,KAAKhB,OAAM,SAAS,OAAO,CAAA,GAAI;AAC3B,WAAO,WAAW,MAAMA,OAAM,SAAS,IAAI;AAAA,EAC/C;AAAA,EACA,KAAK,OAAO,MAAM;AACd,QAAI,OAAO,SAAS;AAChB,WAAK,YAAY;AAAA,IACrB;AACA,WAAO,MAAM,KAAK,IAAI,GAAG,IAAI;AAAA,EACjC;AAAA,EACA,CAAC,KAAK,IAAI;AACN,OAAG,MAAM,KAAK,UAAU,CAAC,IAAI,SAAS;AAClC,UAAI,IAAI;AACJ,eAAO,KAAK,KAAK,SAAS,EAAE;AAAA,MAChC;AACA,WAAK,OAAO,EAAE,IAAI;AAAA,IACtB,CAAC;AAAA,EACL;AAAA,EACA,CAAC,OAAO,EAAE,MAAM;AACZ,SAAK,UAAU,IAAI,KAAK,UAAU,IAAI;AACtC,SAAK,OAAO;AACZ,QAAI,CAAC,KAAK,UAAU;AAChB,WAAK,OAAO;AAAA,IAChB;AACA,SAAK,OAAO,QAAQ,IAAI;AACxB,SAAK,KAAK,QAAQ,IAAI;AACtB,SAAKS,SAAO,EAAC;AAAA,EACjB;AAAA,EACA,CAACA,SAAO,IAAI;AACR,YAAQ,KAAK,MAAI;AAAA,MACb,KAAK;AACD,eAAO,KAAKC,MAAI,EAAC;AAAA,MACrB,KAAK;AACD,eAAO,KAAKC,WAAS,EAAC;AAAA,MAC1B,KAAK;AACD,eAAO,KAAKC,SAAO,EAAC;AAAA;AAAA,MAExB;AACI,eAAO,KAAK,IAAG;AAAA,IAC/B;AAAA,EACI;AAAA,EACA,CAAC,IAAI,EAAE,MAAM;AACT,WAAO,QAAQ,MAAM,KAAK,SAAS,aAAa,KAAK,QAAQ;AAAA,EACjE;AAAA,EACA,CAAC,MAAM,EAAE,MAAM;AACX,WAAO,WAAW,MAAM,KAAK,MAAM;AAAA,EACvC;AAAA,EACA,CAAC,MAAM,IAAI;AAEP,QAAI,CAAC,KAAK,MAAM;AACZ,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACrD;AAEA,QAAI,KAAK,SAAS,eAAe,KAAK,UAAU;AAC5C,WAAK,UAAU;AAAA,IACnB;AACA,SAAK,eAAe,IAAI;AACxB,SAAK,SAAS,IAAI,OAAO;AAAA,MACrB,MAAM,KAAK,MAAM,EAAE,KAAK,IAAI;AAAA;AAAA,MAE5B,UAAU,KAAK,SAAS,UAAU,KAAK,aAAa,SAChD,KAAK,MAAM,EAAE,KAAK,QAAQ,IACxB,KAAK;AAAA;AAAA;AAAA,MAGX,MAAM,KAAK,IAAI,EAAE,KAAK,KAAK,IAAI;AAAA,MAC/B,KAAK,KAAK,WAAW,SAAY,KAAK,KAAK;AAAA,MAC3C,KAAK,KAAK,WAAW,SAAY,KAAK,KAAK;AAAA,MAC3C,MAAM,KAAK,KAAK;AAAA,MAChB,OAAO,KAAK,UAAU,SAAY,KAAK,SAAS,KAAK,KAAK;AAAA;AAAA,MAE1D,MAAM,KAAK,SAAS,gBAAgB,SAAY,KAAK;AAAA,MACrD,OAAO,KAAK,WAAW,SACjB,KAAK,KAAK,QAAQ,KAAK,QAAQ,KAAK,SAChC;AAAA,MACV,OAAO,KAAK,WAAW,SAAY,KAAK,KAAK;AAAA,MAC7C,OAAO,KAAK,WAAW,SAAY,KAAK,KAAK;AAAA,IACzD,CAAS;AACD,QAAI,KAAK,OAAO,OAAM,KAAM,CAAC,KAAK,OAAO;AACrC,YAAM,MAAM,IAAI,IAAI;AAAA,QAChB,OAAO,KAAK,WAAW,SAAY,KAAK,OAAO;AAAA,QAC/C,OAAO,KAAK,WAAW,SAAY,KAAK,OAAO;AAAA,QAC/C,KAAK,KAAK,WAAW,SAAY,KAAK,OAAO;AAAA,QAC7C,OAAO,KAAK,UAAU,SAAa,KAAK,SAAS,KAAK,OAAO;AAAA,QAC7D,MAAM,KAAK,MAAM,EAAE,KAAK,IAAI;AAAA,QAC5B,UAAU,KAAK,SAAS,UAAU,KAAK,aAAa,SAChD,KAAK,MAAM,EAAE,KAAK,QAAQ,IACxB,KAAK;AAAA,QACX,MAAM,KAAK,OAAO;AAAA,QAClB,KAAK,KAAK,WAAW,SAAY,KAAK,OAAO;AAAA,QAC7C,OAAO,KAAK,WAAW,SAAY,KAAK,OAAO;AAAA,QAC/C,KAAK,KAAK,WAAW,SAAY,KAAK,KAAK;AAAA,QAC3C,KAAK,KAAK,WAAW,SAAY,KAAK,KAAK;AAAA,QAC3C,OAAO,KAAK,WAAW,SAAY,KAAK,KAAK;AAAA,MAC7D,CAAa,EAAE,OAAM,CAAE;AAAA,IACf;AACA,UAAM,QAAQ,KAAK,QAAQ;AAE3B,QAAI,CAAC,OAAO;AACR,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC7C;AAEA,UAAM,MAAM,KAAK;AAAA,EACrB;AAAA,EACA,CAACD,WAAS,IAAI;AAEV,QAAI,CAAC,KAAK,MAAM;AACZ,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAChE;AAEA,QAAI,KAAK,KAAK,MAAM,EAAE,MAAM,KAAK;AAC7B,WAAK,QAAQ;AAAA,IACjB;AACA,SAAK,KAAK,OAAO;AACjB,SAAK,MAAM,EAAC;AACZ,SAAK,IAAG;AAAA,EACZ;AAAA,EACA,CAACC,SAAO,IAAI;AACR,OAAG,SAAS,KAAK,UAAU,CAAC,IAAI,aAAa;AACzC,UAAI,IAAI;AACJ,eAAO,KAAK,KAAK,SAAS,EAAE;AAAA,MAChC;AACA,WAAK,UAAU,EAAE,QAAQ;AAAA,IAC7B,CAAC;AAAA,EACL;AAAA,EACA,CAAC,UAAU,EAAE,UAAU;AACnB,SAAK,WAAW,qBAAqB,QAAQ;AAC7C,SAAK,MAAM,EAAC;AACZ,SAAK,IAAG;AAAA,EACZ;AAAA,EACA,CAACC,UAAQ,EAAE,UAAU;AAEjB,QAAI,CAAC,KAAK,MAAM;AACZ,YAAM,IAAI,MAAM,uCAAuC;AAAA,IAC3D;AAEA,SAAK,OAAO;AACZ,SAAK,WAAW,qBAAqBG,WAAK,SAAS,KAAK,KAAK,QAAQ,CAAC;AACtE,SAAK,KAAK,OAAO;AACjB,SAAK,MAAM,EAAC;AACZ,SAAK,IAAG;AAAA,EACZ;AAAA,EACA,CAACN,MAAI,IAAI;AAEL,QAAI,CAAC,KAAK,MAAM;AACZ,YAAM,IAAI,MAAM,uCAAuC;AAAA,IAC3D;AAEA,QAAI,KAAK,KAAK,QAAQ,GAAG;AACrB,YAAM,UAAU,GAAG,KAAK,KAAK,GAAG,IAAI,KAAK,KAAK,GAAG;AACjD,YAAM,WAAW,KAAK,UAAU,IAAI,OAAO;AAC3C,UAAI,UAAU,QAAQ,KAAK,GAAG,MAAM,GAAG;AACnC,eAAO,KAAKG,UAAQ,EAAE,QAAQ;AAAA,MAClC;AACA,WAAK,UAAU,IAAI,SAAS,KAAK,QAAQ;AAAA,IAC7C;AACA,SAAK,MAAM,EAAC;AACZ,QAAI,KAAK,KAAK,SAAS,GAAG;AACtB,aAAO,KAAK,IAAG;AAAA,IACnB;AACA,SAAK,QAAQ,EAAC;AAAA,EAClB;AAAA,EACA,CAAC,QAAQ,IAAI;AACT,OAAG,KAAK,KAAK,UAAU,KAAK,CAAC,IAAI,OAAO;AACpC,UAAI,IAAI;AACJ,eAAO,KAAK,KAAK,SAAS,EAAE;AAAA,MAChC;AACA,WAAK,UAAU,EAAE,EAAE;AAAA,IACvB,CAAC;AAAA,EACL;AAAA,EACA,CAAC,UAAU,EAAE,IAAI;AACb,SAAK,KAAK;AACV,QAAI,KAAK,WAAW;AAChB,aAAO,KAAK,KAAK,EAAC;AAAA,IACtB;AAEA,QAAI,CAAC,KAAK,MAAM;AACZ,YAAM,IAAI,MAAM,uCAAuC;AAAA,IAC3D;AAEA,SAAK,WAAW,MAAM,KAAK,KAAK,KAAK,KAAK,OAAO,GAAG;AACpD,SAAK,cAAc,KAAK;AACxB,UAAM,SAAS,KAAK,IAAI,KAAK,UAAU,KAAK,WAAW;AACvD,SAAK,MAAM,OAAO,YAAY,MAAM;AACpC,SAAK,SAAS;AACd,SAAK,MAAM;AACX,SAAK,SAAS,KAAK,KAAK;AACxB,SAAK,SAAS,KAAK,IAAI;AACvB,SAAK,IAAI,EAAC;AAAA,EACd;AAAA,EACA,CAAC,IAAI,IAAI;AACL,UAAM,EAAE,IAAI,KAAK,QAAQ,QAAQ,KAAAP,KAAG,IAAK;AACzC,QAAI,OAAO,UAAa,QAAQ,QAAW;AACvC,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC5D;AACA,OAAG,KAAK,IAAI,KAAK,QAAQ,QAAQA,MAAK,CAAC,IAAI,cAAc;AACrD,UAAI,IAAI;AAGJ,eAAO,KAAK,KAAK,EAAE,MAAM,KAAK,KAAK,SAAS,EAAE,CAAC;AAAA,MACnD;AACA,WAAK,MAAM,EAAE,SAAS;AAAA,IAC1B,CAAC;AAAA,EACL;AAAA;AAAA,EAEA,CAAC,KAAK,EAAE,KAAK,MAAM;AAAA,EAAE,GAAG;AAEpB,QAAI,KAAK,OAAO;AACZ,SAAG,MAAM,KAAK,IAAI,EAAE;AAAA,EAC5B;AAAA,EACA,CAAC,MAAM,EAAE,WAAW;AAChB,QAAI,aAAa,KAAK,KAAK,SAAS,GAAG;AACnC,YAAM,KAAK,OAAO,OAAO,IAAI,MAAM,4BAA4B,GAAG;AAAA,QAC9D,MAAM,KAAK;AAAA,QACX,SAAS;AAAA,QACT,MAAM;AAAA,MACtB,CAAa;AACD,aAAO,KAAK,KAAK,EAAE,MAAM,KAAK,KAAK,SAAS,EAAE,CAAC;AAAA,IACnD;AACA,QAAI,YAAY,KAAK,QAAQ;AACzB,YAAM,KAAK,OAAO,OAAO,IAAI,MAAM,gCAAgC,GAAG;AAAA,QAClE,MAAM,KAAK;AAAA,QACX,SAAS;AAAA,QACT,MAAM;AAAA,MACtB,CAAa;AACD,aAAO,KAAK,KAAK,EAAE,MAAM,KAAK,KAAK,SAAS,EAAE,CAAC;AAAA,IACnD;AAEA,QAAI,CAAC,KAAK,KAAK;AACX,YAAM,IAAI,MAAM,6CAA6C;AAAA,IACjE;AAQA,QAAI,cAAc,KAAK,QAAQ;AAC3B,eAAS,IAAI,WAAW,IAAI,KAAK,UAAU,YAAY,KAAK,aAAa,KAAK;AAC1E,aAAK,IAAI,IAAI,KAAK,MAAM,IAAI;AAC5B;AACA,aAAK;AAAA,MACT;AAAA,IACJ;AACA,UAAM,QAAQ,KAAK,WAAW,KAAK,cAAc,KAAK,IAAI,SACtD,KAAK,MACH,KAAK,IAAI,SAAS,KAAK,QAAQ,KAAK,SAAS,SAAS;AAC5D,UAAM,UAAU,KAAK,MAAM,KAAK;AAChC,QAAI,CAAC,SAAS;AACV,WAAK,UAAU,EAAE,MAAM,KAAKQ,SAAO,EAAC,CAAE;AAAA,IAC1C,OACK;AACD,WAAKA,SAAO,EAAC;AAAA,IACjB;AAAA,EACJ;AAAA,EACA,CAAC,UAAU,EAAE,IAAI;AACb,SAAK,KAAK,SAAS,EAAE;AAAA,EACzB;AAAA,EACA,MAAM,OAAO,UAAU,IAAI;AAEvB,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AACA,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,OAAO,KAAK,OAAO,OAAO,aAAa,WAAW,WAAW,MAAM;AAAA,IAC/E;AAEA,QAAI,KAAK,cAAc,MAAM,QAAQ;AACjC,YAAM,KAAK,OAAO,OAAO,IAAI,MAAM,iCAAiC,GAAG;AAAA,QACnE,MAAM,KAAK;AAAA,MAC3B,CAAa;AACD,aAAO,KAAK,KAAK,SAAS,EAAE;AAAA,IAChC;AACA,SAAK,UAAU,MAAM;AACrB,SAAK,eAAe,MAAM;AAC1B,SAAK,OAAO,MAAM;AAClB,SAAK,UAAU,MAAM;AACrB,WAAO,MAAM,MAAM,OAAO,MAAM,EAAE;AAAA,EACtC;AAAA,EACA,CAACA,SAAO,IAAI;AACR,QAAI,CAAC,KAAK,QAAQ;AACd,UAAI,KAAK,aAAa;AAClB,cAAM,MAAM,OAAO,MAAM,KAAK,WAAW,CAAC;AAAA,MAC9C;AACA,aAAO,KAAK,KAAK,EAAE,QAAM,KAAK,KAAK,KAAK,SAAS,EAAE,IAAI,KAAK,IAAG,CAAE;AAAA,IACrE;AAEA,QAAI,CAAC,KAAK,KAAK;AACX,YAAM,IAAI,MAAM,gCAAgC;AAAA,IACpD;AAEA,QAAI,KAAK,UAAU,KAAK,QAAQ;AAG5B,WAAK,MAAM,OAAO,YAAY,KAAK,IAAI,KAAK,aAAa,KAAK,IAAI,MAAM,CAAC;AACzE,WAAK,SAAS;AAAA,IAClB;AACA,SAAK,SAAS,KAAK,IAAI,SAAS,KAAK;AACrC,SAAK,IAAI,EAAC;AAAA,EACd;AACJ;AACO,MAAM,uBAAuB,WAAW;AAAA,EAC3C,OAAO;AAAA,EACP,CAAC,KAAK,IAAI;AACN,SAAK,OAAO,EAAE,GAAG,UAAU,KAAK,QAAQ,CAAC;AAAA,EAC7C;AAAA,EACA,CAACF,SAAO,IAAI;AACR,SAAK,UAAU,EAAE,GAAG,aAAa,KAAK,QAAQ,CAAC;AAAA,EACnD;AAAA,EACA,CAAC,QAAQ,IAAI;AACT,SAAK,UAAU,EAAE,GAAG,SAAS,KAAK,UAAU,GAAG,CAAC;AAAA,EACpD;AAAA,EACA,CAAC,IAAI,IAAI;AACL,QAAI,QAAQ;AACZ,QAAI;AACA,YAAM,EAAE,IAAI,KAAK,QAAQ,QAAQ,KAAAN,KAAG,IAAK;AAEzC,UAAI,OAAO,UAAa,QAAQ,QAAW;AACvC,cAAM,IAAI,MAAM,uCAAuC;AAAA,MAC3D;AAEA,YAAM,YAAY,GAAG,SAAS,IAAI,KAAK,QAAQ,QAAQA,IAAG;AAC1D,WAAK,MAAM,EAAE,SAAS;AACtB,cAAQ;AAAA,IACZ,UACR;AAGY,UAAI,OAAO;AACP,YAAI;AACA,eAAK,KAAK,EAAE,MAAM;AAAA,UAAE,CAAC;AAAA,QACzB,SACO,IAAI;AAAA,QAAE;AAAA,MACjB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,CAAC,UAAU,EAAE,IAAI;AACb,OAAE;AAAA,EACN;AAAA;AAAA,EAEA,CAAC,KAAK,EAAE,KAAK,MAAM;AAAA,EAAE,GAAG;AAEpB,QAAI,KAAK,OAAO;AACZ,SAAG,UAAU,KAAK,EAAE;AACxB,OAAE;AAAA,EACN;AACJ;AACO,MAAM,sBAAsB,SAAS;AAAA,EACxC,WAAW;AAAA,EACX,cAAc;AAAA,EACd,MAAM;AAAA,EACN,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,KAAKN,OAAM,SAAS,OAAO,CAAA,GAAI;AAC3B,WAAO,WAAW,MAAMA,OAAM,SAAS,IAAI;AAAA,EAC/C;AAAA,EACA,YAAY,WAAW,OAAO,IAAI;AAC9B,UAAM,MAAM,QAAQ,IAAI;AACxB,UAAK;AACL,SAAK,gBAAgB,CAAC,CAAC,IAAI;AAC3B,SAAK,WAAW,CAAC,CAAC,IAAI;AACtB,SAAK,SAAS,CAAC,CAAC,IAAI;AACpB,SAAK,QAAQ,CAAC,CAAC,IAAI;AACnB,SAAK,UAAU,CAAC,CAAC,IAAI;AACrB,SAAK,eAAe,IAAI;AACxB,SAAK,YAAY;AACjB,UAAM,EAAE,KAAI,IAAK;AAEjB,QAAI,SAAS,eAAe;AACxB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IAC1D;AAEA,SAAK,OAAO;AACZ,QAAI,KAAK,SAAS,eAAe,KAAK,UAAU;AAC5C,WAAK,UAAU;AAAA,IACnB;AACA,SAAK,SAAS,IAAI;AAClB,SAAK,OAAO,qBAAqB,UAAU,IAAI;AAC/C,SAAK,OACD,UAAU,SAAS,SACf,KAAK,IAAI,EAAE,UAAU,IAAI,IACvB;AACV,SAAK,MAAM,KAAK,WAAW,SAAY,UAAU;AACjD,SAAK,MAAM,KAAK,WAAW,SAAY,UAAU;AACjD,SAAK,QAAQ,KAAK,WAAW,SAAY,UAAU;AACnD,SAAK,QAAQ,KAAK,WAAW,SAAY,UAAU;AACnD,SAAK,OAAO,UAAU;AACtB,SAAK,QACD,KAAK,UAAU,SAAY,IAAI,SAAS,UAAU;AACtD,SAAK,QAAQ,KAAK,WAAW,SAAY,UAAU;AACnD,SAAK,QAAQ,KAAK,WAAW,SAAY,UAAU;AACnD,SAAK,WACD,UAAU,aAAa,SACnB,qBAAqB,UAAU,QAAQ,IACrC;AACV,QAAI,OAAO,IAAI,WAAW,YAAY;AAClC,WAAK,GAAG,QAAQ,IAAI,MAAM;AAAA,IAC9B;AACA,QAAI,WAAW;AACf,QAAI,CAAC,KAAK,eAAe;AACrB,YAAM,CAAC,MAAM,QAAQ,IAAI,kBAAkB,KAAK,IAAI;AACpD,UAAI,QAAQ,OAAO,aAAa,UAAU;AACtC,aAAK,OAAO;AACZ,mBAAW;AAAA,MACf;AAAA,IACJ;AACA,SAAK,SAAS,UAAU;AACxB,SAAK,cAAc,UAAU;AAC7B,SAAK,eAAe,IAAI;AACxB,SAAK,SAAS,IAAI,OAAO;AAAA,MACrB,MAAM,KAAK,MAAM,EAAE,KAAK,IAAI;AAAA,MAC5B,UAAU,KAAK,SAAS,UAAU,KAAK,aAAa,SAChD,KAAK,MAAM,EAAE,KAAK,QAAQ,IACxB,KAAK;AAAA;AAAA;AAAA,MAGX,MAAM,KAAK;AAAA,MACX,KAAK,KAAK,WAAW,SAAY,KAAK;AAAA,MACtC,KAAK,KAAK,WAAW,SAAY,KAAK;AAAA,MACtC,MAAM,KAAK;AAAA,MACX,OAAO,KAAK,UAAU,SAAY,KAAK;AAAA,MACvC,MAAM,KAAK;AAAA,MACX,OAAO,KAAK,WAAW,SAAY,KAAK;AAAA,MACxC,OAAO,KAAK,WAAW,SAAY,KAAK;AAAA,MACxC,OAAO,KAAK,WAAW,SAAY,KAAK;AAAA,IACpD,CAAS;AACD,QAAI,UAAU;AACV,WAAK,KAAK,kBAAkB,aAAa,QAAQ,uBAAuB;AAAA,QACpE,OAAO;AAAA,QACP,MAAM,WAAW,KAAK;AAAA,MACtC,CAAa;AAAA,IACL;AACA,QAAI,KAAK,OAAO,OAAM,KAAM,CAAC,KAAK,OAAO;AACrC,YAAM,MAAM,IAAI,IAAI;AAAA,QAChB,OAAO,KAAK,WAAW,SAAY,KAAK;AAAA,QACxC,OAAO,KAAK,WAAW,SAAY,KAAK;AAAA,QACxC,KAAK,KAAK,WAAW,SAAY,KAAK;AAAA,QACtC,OAAO,KAAK,UAAU,SAAY,KAAK;AAAA,QACvC,MAAM,KAAK,MAAM,EAAE,KAAK,IAAI;AAAA,QAC5B,UAAU,KAAK,SAAS,UAAU,KAAK,aAAa,SAChD,KAAK,MAAM,EAAE,KAAK,QAAQ,IACxB,KAAK;AAAA,QACX,MAAM,KAAK;AAAA,QACX,KAAK,KAAK,WAAW,SAAY,KAAK;AAAA,QACtC,OAAO,KAAK,WAAW,SAAY,KAAK;AAAA,QACxC,KAAK,KAAK,WAAW,SAAY,KAAK,UAAU;AAAA,QAChD,KAAK,KAAK,WAAW,SAAY,KAAK,UAAU;AAAA,QAChD,OAAO,KAAK,WAAW,SAAY,KAAK,UAAU;AAAA,MAClE,CAAa,EAAE,OAAM,CAAE;AAAA,IACf;AACA,UAAM,IAAI,KAAK,QAAQ;AAEvB,QAAI,CAAC;AACD,YAAM,IAAI,MAAM,yBAAyB;AAE7C,UAAM,MAAM,CAAC;AACb,cAAU,KAAK,IAAI;AAAA,EACvB;AAAA,EACA,CAAC,MAAM,EAAE,MAAM;AACX,WAAO,WAAW,MAAM,KAAK,MAAM;AAAA,EACvC;AAAA,EACA,CAAC,IAAI,EAAE,MAAM;AACT,WAAO,QAAQ,MAAM,KAAK,SAAS,aAAa,KAAK,QAAQ;AAAA,EACjE;AAAA,EACA,MAAM,OAAO,UAAU,IAAI;AAEvB,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AACA,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,OAAO,KAAK,OAAO,OAAO,aAAa,WAAW,WAAW,MAAM;AAAA,IAC/E;AAEA,UAAM,WAAW,MAAM;AACvB,QAAI,WAAW,KAAK,aAAa;AAC7B,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC/D;AACA,SAAK,eAAe;AACpB,WAAO,MAAM,MAAM,OAAO,EAAE;AAAA,EAChC;AAAA,EACA,IAAI,OAAO,UAAU,IAAI;AACrB,QAAI,KAAK,aAAa;AAClB,YAAM,MAAM,OAAO,MAAM,KAAK,WAAW,CAAC;AAAA,IAC9C;AAEA,QAAI,OAAO,UAAU,YAAY;AAC7B,WAAK;AACL,iBAAW;AACX,cAAQ;AAAA,IACZ;AACA,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AACA,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,OAAO,KAAK,OAAO,YAAY,MAAM;AAAA,IACjD;AACA,QAAI;AACA,WAAK,KAAK,UAAU,EAAE;AAC1B,YAAQ,MAAM,IAAI,OAAO,EAAE,IAAI,MAAM,IAAI,EAAE;AAE3C,WAAO;AAAA,EACX;AACJ;AACA,MAAM,UAAU,CAAC,SAAS,KAAK,OAAM,IAAK,SACpC,KAAK,YAAW,IAAK,cACjB,KAAK,eAAc,IAAK,iBACpB;AC/oBP,MAAM,QAAQ;AAAA,EACjB;AAAA,EACA;AAAA,EACA,SAAS;AAAA,EACT,OAAO,OAAOiB,QAAO,IAAI;AACrB,WAAO,IAAI,QAAQA,KAAI;AAAA,EAC3B;AAAA,EACA,YAAYA,QAAO,IAAI;AACnB,eAAW,QAAQA,OAAM;AACrB,WAAK,KAAK,IAAI;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,EAAE,OAAO,QAAQ,IAAI;AACjB,aAAS,SAAS,KAAK,MAAM,QAAQ,SAAS,OAAO,MAAM;AACvD,YAAM,OAAO;AAAA,IACjB;AAAA,EACJ;AAAA,EACA,WAAW,MAAM;AACb,QAAI,KAAK,SAAS,MAAM;AACpB,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACtE;AACA,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,QAAI,MAAM;AACN,WAAK,OAAO;AAAA,IAChB;AACA,QAAI,MAAM;AACN,WAAK,OAAO;AAAA,IAChB;AACA,QAAI,SAAS,KAAK,MAAM;AACpB,WAAK,OAAO;AAAA,IAChB;AACA,QAAI,SAAS,KAAK,MAAM;AACpB,WAAK,OAAO;AAAA,IAChB;AACA,SAAK;AACL,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,WAAO;AAAA,EACX;AAAA,EACA,YAAY,MAAM;AACd,QAAI,SAAS,KAAK,MAAM;AACpB;AAAA,IACJ;AACA,QAAI,KAAK,MAAM;AACX,WAAK,KAAK,WAAW,IAAI;AAAA,IAC7B;AACA,UAAM,OAAO,KAAK;AAClB,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,QAAI,MAAM;AACN,WAAK,OAAO;AAAA,IAChB;AACA,SAAK,OAAO;AACZ,QAAI,CAAC,KAAK,MAAM;AACZ,WAAK,OAAO;AAAA,IAChB;AACA,SAAK;AAAA,EACT;AAAA,EACA,SAAS,MAAM;AACX,QAAI,SAAS,KAAK,MAAM;AACpB;AAAA,IACJ;AACA,QAAI,KAAK,MAAM;AACX,WAAK,KAAK,WAAW,IAAI;AAAA,IAC7B;AACA,UAAM,OAAO,KAAK;AAClB,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,QAAI,MAAM;AACN,WAAK,OAAO;AAAA,IAChB;AACA,SAAK,OAAO;AACZ,QAAI,CAAC,KAAK,MAAM;AACZ,WAAK,OAAO;AAAA,IAChB;AACA,SAAK;AAAA,EACT;AAAA,EACA,QAAQ,MAAM;AACV,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AACzC,WAAK,MAAM,KAAK,CAAC,CAAC;AAAA,IACtB;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,WAAW,MAAM;AACb,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AACzC,cAAQ,MAAM,KAAK,CAAC,CAAC;AAAA,IACzB;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,MAAM;AACF,QAAI,CAAC,KAAK,MAAM;AACZ,aAAO;AAAA,IACX;AACA,UAAM,MAAM,KAAK,KAAK;AACtB,UAAM,IAAI,KAAK;AACf,SAAK,OAAO,KAAK,KAAK;AACtB,QAAI,KAAK,MAAM;AACX,WAAK,KAAK,OAAO;AAAA,IACrB,OACK;AACD,WAAK,OAAO;AAAA,IAChB;AACA,MAAE,OAAO;AACT,SAAK;AACL,WAAO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,QAAI,CAAC,KAAK,MAAM;AACZ,aAAO;AAAA,IACX;AACA,UAAM,MAAM,KAAK,KAAK;AACtB,UAAM,IAAI,KAAK;AACf,SAAK,OAAO,KAAK,KAAK;AACtB,QAAI,KAAK,MAAM;AACX,WAAK,KAAK,OAAO;AAAA,IACrB,OACK;AACD,WAAK,OAAO;AAAA,IAChB;AACA,MAAE,OAAO;AACT,SAAK;AACL,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,IAAI,OAAO;AACf,YAAQ,SAAS;AACjB,aAAS,SAAS,KAAK,MAAM,IAAI,GAAG,CAAC,CAAC,QAAQ,KAAK;AAC/C,SAAG,KAAK,OAAO,OAAO,OAAO,GAAG,IAAI;AACpC,eAAS,OAAO;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,eAAe,IAAI,OAAO;AACtB,YAAQ,SAAS;AACjB,aAAS,SAAS,KAAK,MAAM,IAAI,KAAK,SAAS,GAAG,CAAC,CAAC,QAAQ,KAAK;AAC7D,SAAG,KAAK,OAAO,OAAO,OAAO,GAAG,IAAI;AACpC,eAAS,OAAO;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,IAAI,GAAG;AACH,QAAI,IAAI;AACR,QAAI,SAAS,KAAK;AAClB,WAAO,CAAC,CAAC,UAAU,IAAI,GAAG,KAAK;AAC3B,eAAS,OAAO;AAAA,IACpB;AACA,QAAI,MAAM,KAAK,CAAC,CAAC,QAAQ;AACrB,aAAO,OAAO;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,WAAW,GAAG;AACV,QAAI,IAAI;AACR,QAAI,SAAS,KAAK;AAClB,WAAO,CAAC,CAAC,UAAU,IAAI,GAAG,KAAK;AAE3B,eAAS,OAAO;AAAA,IACpB;AACA,QAAI,MAAM,KAAK,CAAC,CAAC,QAAQ;AACrB,aAAO,OAAO;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,IAAI,IAAI,OAAO;AACX,YAAQ,SAAS;AACjB,UAAM,MAAM,IAAI,QAAO;AACvB,aAAS,SAAS,KAAK,MAAM,CAAC,CAAC,UAAS;AACpC,UAAI,KAAK,GAAG,KAAK,OAAO,OAAO,OAAO,IAAI,CAAC;AAC3C,eAAS,OAAO;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,IAAI,OAAO;AAClB,YAAQ,SAAS;AACjB,QAAI,MAAM,IAAI,QAAO;AACrB,aAAS,SAAS,KAAK,MAAM,CAAC,CAAC,UAAS;AACpC,UAAI,KAAK,GAAG,KAAK,OAAO,OAAO,OAAO,IAAI,CAAC;AAC3C,eAAS,OAAO;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO,IAAI,SAAS;AAChB,QAAI;AACJ,QAAI,SAAS,KAAK;AAClB,QAAI,UAAU,SAAS,GAAG;AACtB,YAAM;AAAA,IACV,WACS,KAAK,MAAM;AAChB,eAAS,KAAK,KAAK;AACnB,YAAM,KAAK,KAAK;AAAA,IACpB,OACK;AACD,YAAM,IAAI,UAAU,4CAA4C;AAAA,IACpE;AACA,aAAS,IAAI,GAAG,CAAC,CAAC,QAAQ,KAAK;AAC3B,YAAM,GAAG,KAAK,OAAO,OAAO,CAAC;AAC7B,eAAS,OAAO;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA,EACA,cAAc,IAAI,SAAS;AACvB,QAAI;AACJ,QAAI,SAAS,KAAK;AAClB,QAAI,UAAU,SAAS,GAAG;AACtB,YAAM;AAAA,IACV,WACS,KAAK,MAAM;AAChB,eAAS,KAAK,KAAK;AACnB,YAAM,KAAK,KAAK;AAAA,IACpB,OACK;AACD,YAAM,IAAI,UAAU,4CAA4C;AAAA,IACpE;AACA,aAAS,IAAI,KAAK,SAAS,GAAG,CAAC,CAAC,QAAQ,KAAK;AACzC,YAAM,GAAG,KAAK,OAAO,OAAO,CAAC;AAC7B,eAAS,OAAO;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA,EACA,UAAU;AACN,UAAM,MAAM,IAAI,MAAM,KAAK,MAAM;AACjC,aAAS,IAAI,GAAG,SAAS,KAAK,MAAM,CAAC,CAAC,QAAQ,KAAK;AAC/C,UAAI,CAAC,IAAI,OAAO;AAChB,eAAS,OAAO;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA,EACA,iBAAiB;AACb,UAAM,MAAM,IAAI,MAAM,KAAK,MAAM;AACjC,aAAS,IAAI,GAAG,SAAS,KAAK,MAAM,CAAC,CAAC,QAAQ,KAAK;AAC/C,UAAI,CAAC,IAAI,OAAO;AAChB,eAAS,OAAO;AAAA,IACpB;AACA,WAAO;AAAA,EACX;AAAA,EACA,MAAM,OAAO,GAAG,KAAK,KAAK,QAAQ;AAC9B,QAAI,KAAK,GAAG;AACR,YAAM,KAAK;AAAA,IACf;AACA,QAAI,OAAO,GAAG;AACV,cAAQ,KAAK;AAAA,IACjB;AACA,UAAM,MAAM,IAAI,QAAO;AACvB,QAAI,KAAK,QAAQ,KAAK,GAAG;AACrB,aAAO;AAAA,IACX;AACA,QAAI,OAAO,GAAG;AACV,aAAO;AAAA,IACX;AACA,QAAI,KAAK,KAAK,QAAQ;AAClB,WAAK,KAAK;AAAA,IACd;AACA,QAAI,SAAS,KAAK;AAClB,QAAI,IAAI;AACR,SAAK,IAAI,GAAG,CAAC,CAAC,UAAU,IAAI,MAAM,KAAK;AACnC,eAAS,OAAO;AAAA,IACpB;AACA,WAAO,CAAC,CAAC,UAAU,IAAI,IAAI,KAAK,SAAS,OAAO,MAAM;AAClD,UAAI,KAAK,OAAO,KAAK;AAAA,IACzB;AACA,WAAO;AAAA,EACX;AAAA,EACA,aAAa,OAAO,GAAG,KAAK,KAAK,QAAQ;AACrC,QAAI,KAAK,GAAG;AACR,YAAM,KAAK;AAAA,IACf;AACA,QAAI,OAAO,GAAG;AACV,cAAQ,KAAK;AAAA,IACjB;AACA,UAAM,MAAM,IAAI,QAAO;AACvB,QAAI,KAAK,QAAQ,KAAK,GAAG;AACrB,aAAO;AAAA,IACX;AACA,QAAI,OAAO,GAAG;AACV,aAAO;AAAA,IACX;AACA,QAAI,KAAK,KAAK,QAAQ;AAClB,WAAK,KAAK;AAAA,IACd;AACA,QAAI,IAAI,KAAK;AACb,QAAI,SAAS,KAAK;AAClB,WAAO,CAAC,CAAC,UAAU,IAAI,IAAI,KAAK;AAC5B,eAAS,OAAO;AAAA,IACpB;AACA,WAAO,CAAC,CAAC,UAAU,IAAI,MAAM,KAAK,SAAS,OAAO,MAAM;AACpD,UAAI,KAAK,OAAO,KAAK;AAAA,IACzB;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO,OAAO,cAAc,MAAM,OAAO;AACrC,QAAI,QAAQ,KAAK,QAAQ;AACrB,cAAQ,KAAK,SAAS;AAAA,IAC1B;AACA,QAAI,QAAQ,GAAG;AACX,cAAQ,KAAK,SAAS;AAAA,IAC1B;AACA,QAAI,SAAS,KAAK;AAClB,aAAS,IAAI,GAAG,CAAC,CAAC,UAAU,IAAI,OAAO,KAAK;AACxC,eAAS,OAAO;AAAA,IACpB;AACA,UAAM,MAAM,CAAA;AACZ,aAAS,IAAI,GAAG,CAAC,CAAC,UAAU,IAAI,aAAa,KAAK;AAC9C,UAAI,KAAK,OAAO,KAAK;AACrB,eAAS,KAAK,WAAW,MAAM;AAAA,IACnC;AACA,QAAI,CAAC,QAAQ;AACT,eAAS,KAAK;AAAA,IAClB,WACS,WAAW,KAAK,MAAM;AAC3B,eAAS,OAAO;AAAA,IACpB;AACA,eAAW,KAAK,OAAO;AACnB,eAAS,YAAY,MAAM,QAAQ,CAAC;AAAA,IACxC;AACA,WAAO;AAAA,EACX;AAAA,EACA,UAAU;AACN,UAAM,OAAO,KAAK;AAClB,UAAM,OAAO,KAAK;AAClB,aAAS,SAAS,MAAM,CAAC,CAAC,QAAQ,SAAS,OAAO,MAAM;AACpD,YAAM,IAAI,OAAO;AACjB,aAAO,OAAO,OAAO;AACrB,aAAO,OAAO;AAAA,IAClB;AACA,SAAK,OAAO;AACZ,SAAK,OAAO;AACZ,WAAO;AAAA,EACX;AACJ;AAEA,SAAS,YAAY,MAAM,MAAM,OAAO;AACpC,QAAM,OAAO;AACb,QAAM,OAAO,OAAO,KAAK,OAAO,KAAK;AACrC,QAAM,WAAW,IAAI,KAAK,OAAO,MAAM,MAAM,IAAI;AACjD,MAAI,SAAS,SAAS,QAAW;AAC7B,SAAK,OAAO;AAAA,EAChB;AACA,MAAI,SAAS,SAAS,QAAW;AAC7B,SAAK,OAAO;AAAA,EAChB;AACA,OAAK;AACL,SAAO;AACX;AACA,SAAS,KAAK,MAAM,MAAM;AACtB,OAAK,OAAO,IAAI,KAAK,MAAM,KAAK,MAAM,QAAW,IAAI;AACrD,MAAI,CAAC,KAAK,MAAM;AACZ,SAAK,OAAO,KAAK;AAAA,EACrB;AACA,OAAK;AACT;AACA,SAAS,QAAQ,MAAM,MAAM;AACzB,OAAK,OAAO,IAAI,KAAK,MAAM,QAAW,KAAK,MAAM,IAAI;AACrD,MAAI,CAAC,KAAK,MAAM;AACZ,SAAK,OAAO,KAAK;AAAA,EACrB;AACA,OAAK;AACT;AACO,MAAM,KAAK;AAAA,EACd;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,OAAO,MAAM,MAAMA,OAAM;AACjC,SAAK,OAAOA;AACZ,SAAK,QAAQ;AACb,QAAI,MAAM;AACN,WAAK,OAAO;AACZ,WAAK,OAAO;AAAA,IAChB,OACK;AACD,WAAK,OAAO;AAAA,IAChB;AACA,QAAI,MAAM;AACN,WAAK,OAAO;AACZ,WAAK,OAAO;AAAA,IAChB,OACK;AACD,WAAK,OAAO;AAAA,IAChB;AAAA,EACJ;AACJ;AC/WO,MAAM,QAAQ;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,UAAU;AAAA,EACV,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,YAAY,MAAM,UAAU;AACxB,SAAK,OAAO,QAAQ;AACpB,SAAK,WAAW;AAAA,EACpB;AACJ;AAMA,MAAM,MAAM,OAAO,MAAM,IAAI;AAC7B,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAMf,UAAQ,OAAO,OAAO;AAC5B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,cAAc,OAAO,aAAa;AACxC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,kBAAkB,OAAO,iBAAiB;AAChD,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,UAAU,OAAO,SAAS;AAGzB,MAAM,aAAa,SAAS;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,CAAC,eAAe;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,CAAC,KAAK;AAAA,EACN,CAAC,IAAI,IAAI;AAAA,EACT,CAAC,UAAU,IAAI;AAAA,EACf,CAACA,OAAK,IAAI;AAAA,EACV,YAAY,MAAM,IAAI;AAElB,UAAK;AACL,SAAK,MAAM;AACX,SAAK,OAAO,IAAI,QAAQ;AACxB,SAAK,MAAM,IAAI,OAAO,QAAQ,IAAG;AACjC,SAAK,cAAc,IAAI;AACvB,SAAK,gBAAgB,CAAC,CAAC,IAAI;AAC3B,SAAK,SAAS,CAAC,CAAC,IAAI;AACpB,SAAK,QAAQ,CAAC,CAAC,IAAI;AACnB,SAAK,SAAS,qBAAqB,IAAI,UAAU,EAAE;AACnD,SAAK,YAAY,IAAI,aAAa,oBAAI,IAAG;AACzC,SAAK,YAAY,IAAI,aAAa,oBAAI,IAAG;AACzC,SAAK,eAAe,IAAI,gBAAgB,oBAAI,IAAG;AAC/C,SAAK,eAAe,IAAI;AACxB,SAAK,eAAe,IAAI;AACxB,QAAI,OAAO,IAAI,WAAW,YAAY;AAClC,WAAK,GAAG,QAAQ,IAAI,MAAM;AAAA,IAC9B;AACA,SAAK,WAAW,CAAC,CAAC,IAAI;AACtB,QAAI,IAAI,QAAQ,IAAI,UAAU,IAAI,MAAM;AACpC,WAAK,IAAI,OAAO,IAAI,MAAM,IAAI,SAAS,IAAI,MAAM,IAAI,OAAO,IAAI,KAAK,GAAG;AACpE,cAAM,IAAI,UAAU,2CAA2C;AAAA,MACnE;AACA,UAAI,IAAI,MAAM;AACV,YAAI,OAAO,IAAI,SAAS,UAAU;AAC9B,cAAI,OAAO,CAAA;AAAA,QACf;AACA,YAAI,KAAK,UAAU;AACf,cAAI,KAAK,WAAW;AAAA,QACxB;AACA,aAAK,MAAM,IAAIgB,KAAU,IAAI,IAAI;AAAA,MACrC;AACA,UAAI,IAAI,QAAQ;AACZ,YAAI,OAAO,IAAI,WAAW,UAAU;AAChC,cAAI,SAAS,CAAA;AAAA,QACjB;AACA,aAAK,MAAM,IAAIC,eAAoB,IAAI,MAAM;AAAA,MACjD;AACA,UAAI,IAAI,MAAM;AACV,YAAI,OAAO,IAAI,SAAS,UAAU;AAC9B,cAAI,OAAO,CAAA;AAAA,QACf;AACA,aAAK,MAAM,IAAIC,aAAkB,IAAI,IAAI;AAAA,MAC7C;AAEA,UAAI,CAAC,KAAK;AACN,cAAM,IAAI,MAAM,YAAY;AAChC,YAAM,MAAM,KAAK;AACjB,UAAI,GAAG,QAAQ,WAAS,MAAM,MAAM,KAAK,CAAC;AAC1C,UAAI,GAAG,OAAO,MAAM,MAAM,IAAG,CAAE;AAC/B,UAAI,GAAG,SAAS,MAAM,KAAK,OAAO,EAAC,CAAE;AACrC,WAAK,GAAG,UAAU,MAAM,IAAI,OAAM,CAAE;AAAA,IACxC,OACK;AACD,WAAK,GAAG,SAAS,KAAK,OAAO,CAAC;AAAA,IAClC;AACA,SAAK,eAAe,CAAC,CAAC,IAAI;AAC1B,SAAK,SAAS,CAAC,CAAC,IAAI;AACpB,SAAK,UAAU,CAAC,CAAC,IAAI;AACrB,QAAI,IAAI;AACJ,WAAK,QAAQ,IAAI;AACrB,SAAK,SACD,OAAO,IAAI,WAAW,aAAa,IAAI,SAAS,MAAM;AAC1D,SAAK,KAAK,IAAI,IAAI,QAAO;AACzB,SAAK,IAAI,IAAI;AACb,SAAK,OAAO,OAAO,IAAI,IAAI,KAAK;AAChC,SAAK,UAAU,IAAI;AACnB,SAAKlB,OAAK,IAAI;AAAA,EAClB;AAAA,EACA,CAAC,KAAK,EAAE,OAAO;AACX,WAAO,MAAM,MAAM,KAAK;AAAA,EAC5B;AAAA,EACA,IAAI,MAAM;AACN,SAAK,MAAM,IAAI;AACf,WAAO;AAAA,EACX;AAAA,EACA,IAAI,MAAM,UAAU,IAAI;AAEpB,QAAI,OAAO,SAAS,YAAY;AAC5B,WAAK;AACL,aAAO;AAAA,IACX;AACA,QAAI,OAAO,aAAa,YAAY;AAChC,WAAK;AACL,iBAAW;AAAA,IACf;AAEA,QAAI,MAAM;AACN,WAAK,IAAI,IAAI;AAAA,IACjB;AACA,SAAKA,OAAK,IAAI;AACd,SAAK,OAAO,EAAC;AAEb,QAAI;AACA,SAAE;AACN,WAAO;AAAA,EACX;AAAA,EACA,MAAM,MAAM;AACR,QAAI,KAAKA,OAAK,GAAG;AACb,YAAM,IAAI,MAAM,iBAAiB;AAAA,IACrC;AACA,QAAI,gBAAgB,WAAW;AAC3B,WAAK,WAAW,EAAE,IAAI;AAAA,IAC1B,OACK;AACD,WAAK,UAAU,EAAE,IAAI;AAAA,IACzB;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,CAAC,WAAW,EAAE,GAAG;AACb,UAAM,WAAW,qBAAqBc,WAAK,QAAQ,KAAK,KAAK,EAAE,IAAI,CAAC;AAEpE,QAAI,CAAC,KAAK,OAAO,EAAE,MAAM,CAAC,GAAG;AACzB,QAAE,OAAM;AAAA,IACZ,OACK;AACD,YAAM,MAAM,IAAI,QAAQ,EAAE,MAAM,QAAQ;AACxC,UAAI,QAAQ,IAAI,cAAc,GAAG,KAAK,QAAQ,EAAE,GAAG,CAAC;AACpD,UAAI,MAAM,GAAG,OAAO,MAAM,KAAK,OAAO,EAAE,GAAG,CAAC;AAC5C,WAAK,IAAI,KAAK;AACd,WAAK,KAAK,EAAE,KAAK,GAAG;AAAA,IACxB;AACA,SAAK,OAAO,EAAC;AAAA,EACjB;AAAA,EACA,CAAC,UAAU,EAAE,GAAG;AACZ,UAAM,WAAW,qBAAqBA,WAAK,QAAQ,KAAK,KAAK,CAAC,CAAC;AAC/D,SAAK,KAAK,EAAE,KAAK,IAAI,QAAQ,GAAG,QAAQ,CAAC;AACzC,SAAK,OAAO,EAAC;AAAA,EACjB;AAAA,EACA,CAAC,IAAI,EAAE,KAAK;AACR,QAAI,UAAU;AACd,SAAK,IAAI,KAAK;AACd,UAAM,OAAO,KAAK,SAAS,SAAS;AACpC,OAAG,IAAI,EAAE,IAAI,UAAU,CAAC,IAAIK,UAAS;AACjC,UAAI,UAAU;AACd,WAAK,IAAI,KAAK;AACd,UAAI,IAAI;AACJ,aAAK,KAAK,SAAS,EAAE;AAAA,MACzB,OACK;AACD,aAAK,MAAM,EAAE,KAAKA,KAAI;AAAA,MAC1B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,CAAC,MAAM,EAAE,KAAK,MAAM;AAChB,SAAK,UAAU,IAAI,IAAI,UAAU,IAAI;AACrC,QAAI,OAAO;AAEX,QAAI,CAAC,KAAK,OAAO,IAAI,MAAM,IAAI,GAAG;AAC9B,UAAI,SAAS;AAAA,IACjB;AACA,SAAK,OAAO,EAAC;AAAA,EACjB;AAAA,EACA,CAAC,OAAO,EAAE,KAAK;AACX,QAAI,UAAU;AACd,SAAK,IAAI,KAAK;AACd,OAAG,QAAQ,IAAI,UAAU,CAAC,IAAI,YAAY;AACtC,UAAI,UAAU;AACd,WAAK,IAAI,KAAK;AACd,UAAI,IAAI;AACJ,eAAO,KAAK,KAAK,SAAS,EAAE;AAAA,MAChC;AACA,WAAK,SAAS,EAAE,KAAK,OAAO;AAAA,IAChC,CAAC;AAAA,EACL;AAAA,EACA,CAAC,SAAS,EAAE,KAAK,SAAS;AACtB,SAAK,aAAa,IAAI,IAAI,UAAU,OAAO;AAC3C,QAAI,UAAU;AACd,SAAK,OAAO,EAAC;AAAA,EACjB;AAAA,EACA,CAAC,OAAO,IAAI;AACR,QAAI,KAAK,UAAU,GAAG;AAClB;AAAA,IACJ;AACA,SAAK,UAAU,IAAI;AACnB,aAAS,IAAI,KAAK,KAAK,EAAE,MAAM,CAAC,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,MAAM,IAAI,EAAE,MAAM;AACtE,WAAK,UAAU,EAAE,EAAE,KAAK;AACxB,UAAI,EAAE,MAAM,QAAQ;AAChB,cAAM,IAAI,EAAE;AACZ,aAAK,KAAK,EAAE,WAAW,CAAC;AACxB,UAAE,OAAO;AAAA,MACb;AAAA,IACJ;AACA,SAAK,UAAU,IAAI;AACnB,QAAI,KAAKnB,OAAK,KAAK,CAAC,KAAK,KAAK,EAAE,UAAU,KAAK,IAAI,MAAM,GAAG;AACxD,UAAI,KAAK,KAAK;AACV,aAAK,IAAI,IAAI,GAAG;AAAA,MACpB,OACK;AACD,cAAM,MAAM,GAAG;AACf,cAAM,IAAG;AAAA,MACb;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,KAAK,OAAO,IAAI;AACZ,WAAO,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE,QAAQ,KAAK,KAAK,EAAE,KAAK;AAAA,EAC/D;AAAA,EACA,CAAC,OAAO,EAAE,MAAM;AACZ,SAAK,KAAK,EAAE,MAAK;AACjB,SAAK,IAAI,KAAK;AACd,SAAK,OAAO,EAAC;AAAA,EACjB;AAAA,EACA,CAAC,UAAU,EAAE,KAAK;AACd,QAAI,IAAI,SAAS;AACb;AAAA,IACJ;AACA,QAAI,IAAI,OAAO;AACX,UAAI,QAAQ,KAAK,OAAO,KAAK,CAAC,IAAI,OAAO;AACrC,aAAK,IAAI,EAAE,GAAG;AAAA,MAClB;AACA;AAAA,IACJ;AACA,QAAI,CAAC,IAAI,MAAM;AACX,YAAM,KAAK,KAAK,UAAU,IAAI,IAAI,QAAQ;AAC1C,UAAI,IAAI;AACJ,aAAK,MAAM,EAAE,KAAK,EAAE;AAAA,MACxB,OACK;AACD,aAAK,IAAI,EAAE,GAAG;AAAA,MAClB;AAAA,IACJ;AACA,QAAI,CAAC,IAAI,MAAM;AACX;AAAA,IACJ;AAEA,QAAI,IAAI,QAAQ;AACZ;AAAA,IACJ;AACA,QAAI,CAAC,KAAK,gBACN,IAAI,KAAK,YAAW,KACpB,CAAC,IAAI,SAAS;AACd,YAAM,KAAK,KAAK,aAAa,IAAI,IAAI,QAAQ;AAC7C,UAAI,IAAI;AACJ,aAAK,SAAS,EAAE,KAAK,EAAE;AAAA,MAC3B,OACK;AACD,aAAK,OAAO,EAAE,GAAG;AAAA,MACrB;AACA,UAAI,CAAC,IAAI,SAAS;AACd;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,QAAQ,KAAK,KAAK,EAAE,GAAG;AAC3B,QAAI,CAAC,IAAI,OAAO;AACZ,UAAI,SAAS;AACb;AAAA,IACJ;AACA,QAAI,QAAQ,KAAK,OAAO,KAAK,CAAC,IAAI,OAAO;AACrC,WAAK,IAAI,EAAE,GAAG;AAAA,IAClB;AAAA,EACJ;AAAA,EACA,CAAC,QAAQ,EAAE,KAAK;AACZ,WAAO;AAAA,MACH,QAAQ,CAACF,OAAM,KAAK,SAAS,KAAK,KAAKA,OAAM,KAAK,IAAI;AAAA,MACtD,OAAO,KAAK;AAAA,MACZ,KAAK,KAAK;AAAA,MACV,UAAU,IAAI;AAAA,MACd,eAAe,KAAK;AAAA,MACpB,aAAa,KAAK;AAAA,MAClB,QAAQ,KAAK;AAAA,MACb,UAAU,KAAK;AAAA,MACf,WAAW,KAAK;AAAA,MAChB,WAAW,KAAK;AAAA,MAChB,SAAS,KAAK;AAAA,MACd,OAAO,KAAK;AAAA,MACZ,QAAQ,KAAK;AAAA,MACb,cAAc,KAAK;AAAA,IAC/B;AAAA,EACI;AAAA,EACA,CAAC,KAAK,EAAE,KAAK;AACT,SAAK,IAAI,KAAK;AACd,QAAI;AACA,YAAM,IAAI,IAAI,KAAK,eAAe,EAAE,IAAI,MAAM,KAAK,QAAQ,EAAE,GAAG,CAAC;AACjE,aAAO,EACF,GAAG,OAAO,MAAM,KAAK,OAAO,EAAE,GAAG,CAAC,EAClC,GAAG,SAAS,QAAM,KAAK,KAAK,SAAS,EAAE,CAAC;AAAA,IACjD,SACO,IAAI;AACP,WAAK,KAAK,SAAS,EAAE;AAAA,IACzB;AAAA,EACJ;AAAA,EACA,CAAC,OAAO,IAAI;AACR,QAAI,KAAK,OAAO,KAAK,KAAK,OAAO,EAAE,OAAO;AACtC,WAAK,OAAO,EAAE,MAAM,OAAM;AAAA,IAC9B;AAAA,EACJ;AAAA;AAAA,EAEA,CAAC,IAAI,EAAE,KAAK;AACR,QAAI,QAAQ;AACZ,QAAI,IAAI,SAAS;AACb,UAAI,QAAQ,QAAQ,WAAS;AACzB,cAAM,IAAI,IAAI;AACd,cAAM,OAAO,MAAM,OAAO,KAAK,EAAE,QAAQ,QAAQ,GAAG;AACpD,aAAK,UAAU,EAAE,OAAO,KAAK;AAAA,MACjC,CAAC;AAAA,IACL;AACA,UAAM,SAAS,IAAI;AACnB,UAAM,MAAM,KAAK;AAEjB,QAAI,CAAC;AACD,YAAM,IAAI,MAAM,4BAA4B;AAEhD,QAAI,KAAK;AACL,aAAO,GAAG,QAAQ,WAAS;AACvB,YAAI,CAAC,IAAI,MAAM,KAAK,GAAG;AACnB,iBAAO,MAAK;AAAA,QAChB;AAAA,MACJ,CAAC;AAAA,IACL,OACK;AACD,aAAO,GAAG,QAAQ,WAAS;AACvB,YAAI,CAAC,MAAM,MAAM,KAAK,GAAG;AACrB,iBAAO,MAAK;AAAA,QAChB;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EACA,QAAQ;AACJ,QAAI,KAAK,KAAK;AACV,WAAK,IAAI,MAAK;AAAA,IAClB;AACA,WAAO,MAAM,MAAK;AAAA,EACtB;AAAA,EACA,KAAKA,OAAM,SAAS,OAAO,CAAA,GAAI;AAC3B,eAAW,MAAMA,OAAM,SAAS,IAAI;AAAA,EACxC;AACJ;AACO,MAAM,iBAAiB,KAAK;AAAA,EAC/B,OAAO;AAAA,EACP,YAAY,KAAK;AACb,UAAM,GAAG;AACT,SAAK,eAAe,IAAI;AAAA,EAC5B;AAAA;AAAA,EAEA,QAAQ;AAAA,EAAE;AAAA,EACV,SAAS;AAAA,EAAE;AAAA,EACX,CAAC,IAAI,EAAE,KAAK;AACR,UAAM,OAAO,KAAK,SAAS,aAAa;AACxC,SAAK,MAAM,EAAE,KAAK,GAAG,IAAI,EAAE,IAAI,QAAQ,CAAC;AAAA,EAC5C;AAAA,EACA,CAAC,OAAO,EAAE,KAAK;AACX,SAAK,SAAS,EAAE,KAAK,GAAG,YAAY,IAAI,QAAQ,CAAC;AAAA,EACrD;AAAA;AAAA,EAEA,CAAC,IAAI,EAAE,KAAK;AACR,UAAM,SAAS,IAAI;AACnB,UAAM,MAAM,KAAK;AACjB,QAAI,IAAI,SAAS;AACb,UAAI,QAAQ,QAAQ,WAAS;AACzB,cAAM,IAAI,IAAI;AACd,cAAM,OAAO,MAAM,OAAO,KAAK,EAAE,QAAQ,QAAQ,GAAG;AACpD,aAAK,UAAU,EAAE,OAAO,KAAK;AAAA,MACjC,CAAC;AAAA,IACL;AAEA,QAAI,CAAC;AACD,YAAM,IAAI,MAAM,4BAA4B;AAEhD,QAAI,KAAK;AACL,aAAO,GAAG,QAAQ,WAAS;AACvB,YAAI,MAAM,KAAK;AAAA,MACnB,CAAC;AAAA,IACL,OACK;AACD,aAAO,GAAG,QAAQ,WAAS;AACvB,cAAM,KAAK,EAAE,KAAK;AAAA,MACtB,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;ACpcA,MAAM,iBAAiB,CAAC,KAAK,UAAU;AACnC,QAAM,IAAI,IAAI,SAAS,GAAG;AAC1B,QAAM,SAAS,IAAI,gBAAgB,IAAI,MAAM;AAAA,IACzC,MAAM,IAAI,QAAQ;AAAA,EAC1B,CAAK;AACD,IAAE,KAAK,MAAM;AACbsB,iBAAa,GAAG,KAAK;AACzB;AACA,MAAM,aAAa,CAAC,KAAK,UAAU;AAC/B,QAAM,IAAI,IAAI,KAAK,GAAG;AACtB,QAAM,SAAS,IAAI,YAAY,IAAI,MAAM;AAAA,IACrC,MAAM,IAAI,QAAQ;AAAA,EAC1B,CAAK;AACD,IAAE,KAAK,MAAM;AACb,QAAM,UAAU,IAAI,QAAQ,CAAC,KAAK,QAAQ;AACtC,WAAO,GAAG,SAAS,GAAG;AACtB,WAAO,GAAG,SAAS,GAAG;AACtB,MAAE,GAAG,SAAS,GAAG;AAAA,EACrB,CAAC;AACDC,kBAAc,GAAG,KAAK;AACtB,SAAO;AACX;AACA,MAAMD,iBAAe,CAAC,GAAG,UAAU;AAC/B,QAAM,QAAQ,UAAQ;AAClB,QAAI,KAAK,OAAO,CAAC,MAAM,KAAK;AACxB,WAAK;AAAA,QACD,MAAMN,cAAK,QAAQ,EAAE,KAAK,KAAK,MAAM,CAAC,CAAC;AAAA,QACvC,MAAM;AAAA,QACN,UAAU;AAAA,QACV,aAAa,WAAS,EAAE,IAAI,KAAK;AAAA,MACjD,CAAa;AAAA,IACL,OACK;AACD,QAAE,IAAI,IAAI;AAAA,IACd;AAAA,EACJ,CAAC;AACD,IAAE,IAAG;AACT;AACA,MAAMO,kBAAgB,OAAO,GAAG,UAAU;AACtC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,UAAM,OAAO,OAAO,MAAM,CAAC,CAAC;AAC5B,QAAI,KAAK,OAAO,CAAC,MAAM,KAAK;AACxB,YAAM,KAAK;AAAA,QACP,MAAMP,cAAK,QAAQ,OAAO,EAAE,GAAG,GAAG,KAAK,MAAM,CAAC,CAAC;AAAA,QAC/C,UAAU;AAAA,QACV,aAAa,WAAS;AAClB,YAAE,IAAI,KAAK;AAAA,QACf;AAAA,MAChB,CAAa;AAAA,IACL,OACK;AACD,QAAE,IAAI,IAAI;AAAA,IACd;AAAA,EACJ;AACA,IAAE,IAAG;AACT;AACA,MAAM,aAAa,CAAC,KAAK,UAAU;AAC/B,QAAM,IAAI,IAAI,SAAS,GAAG;AAC1BM,iBAAa,GAAG,KAAK;AACrB,SAAO;AACX;AACA,MAAM,cAAc,CAAC,KAAK,UAAU;AAChC,QAAM,IAAI,IAAI,KAAK,GAAG;AACtBC,kBAAc,GAAG,KAAK;AACtB,SAAO;AACX;AACsB,YAAY,gBAAgB,YAAY,YAAY,aAAa,CAAC,MAAM,UAAU;AACpG,MAAI,CAAC,OAAO,QAAQ;AAChB,UAAM,IAAI,UAAU,sCAAsC;AAAA,EAC9D;AACJ,CAAC;ACnED,MAAMxB,aAAW,QAAQ,IAAI,qBAAqB,QAAQ;AAC1D,MAAMyB,cAAYzB,eAAa;AAE/B,MAAM,EAAE,SAAS,SAAS,SAAQ,IAAK,GAAG;AAC1C,MAAM,kBAAkB,OAAO,QAAQ,IAAI,sBAAsB,KAC7D,GAAG,UAAU,mBACb;AAEJ,MAAM,cAAcyB,eAAa,CAAC,CAAC;AACnC,MAAM,YAAY,MAAM;AACxB,MAAM,WAAW,kBAAkB,UAAU,UAAU;AAChD,MAAM,eAAe,CAAC,cACzB,MAAM,MACJ,CAAC,SAAU,OAAO,YAAY,WAAW;ACnB/C,MAAM,aAAa,CAAC,MAAM,KAAK,QAAQ;AACnC,MAAI;AACA,WAAOnB,YAAG,WAAW,MAAM,KAAK,GAAG;AAAA,EACvC,SACO,IAAI;AACP,QAAI,IAAI,SAAS;AACb,YAAM;AAAA,EACd;AACJ;AACA,MAAM,QAAQ,CAAC,OAAO,KAAK,KAAK,OAAO;AACnCA,cAAG,OAAO,OAAO,KAAK,KAAK,QAAM;AAE7B,OAAG,MAAM,IAAI,SAAS,WAAW,KAAK,IAAI;AAAA,EAC9C,CAAC;AACL;AACA,MAAM,YAAY,CAAC,GAAG,OAAO,KAAK,KAAK,OAAO;AAC1C,MAAI,MAAM,eAAe;AACrB,WAAOW,cAAK,QAAQ,GAAG,MAAM,IAAI,GAAG,KAAK,KAAK,CAAC,OAAO;AAClD,UAAI;AACA,eAAO,GAAG,EAAE;AAChB,YAAM,QAAQA,cAAK,QAAQ,GAAG,MAAM,IAAI;AACxC,YAAM,OAAO,KAAK,KAAK,EAAE;AAAA,IAC7B,CAAC;AAAA,EACL,OACK;AACD,UAAM,QAAQA,cAAK,QAAQ,GAAG,MAAM,IAAI;AACxC,UAAM,OAAO,KAAK,KAAK,EAAE;AAAA,EAC7B;AACJ;AACO,MAAM,SAAS,CAAC,GAAG,KAAK,KAAK,OAAO;AACvCX,cAAG,QAAQ,GAAG,EAAE,eAAe,QAAQ,CAAC,IAAI,aAAa;AAGrD,QAAI,IAAI;AACJ,UAAI,GAAG,SAAS;AACZ,eAAO,GAAE;AAAA,eACJ,GAAG,SAAS,aAAa,GAAG,SAAS;AAC1C,eAAO,GAAG,EAAE;AAAA,IACpB;AACA,QAAI,MAAM,CAAC,SAAS;AAChB,aAAO,MAAM,GAAG,KAAK,KAAK,EAAE;AAChC,QAAI,MAAM,SAAS;AACnB,QAAI,WAAW;AACf,UAAM,OAAO,CAACoB,QAAO;AAEjB,UAAI;AACA;AAEJ,UAAIA;AACA,eAAO,GAAI,WAAWA,GAAE;AAC5B,UAAI,EAAE,QAAQ;AACV,eAAO,MAAM,GAAG,KAAK,KAAK,EAAE;AAAA,IACpC;AACA,eAAW,SAAS,UAAU;AAC1B,gBAAU,GAAG,OAAO,KAAK,KAAK,IAAI;AAAA,IACtC;AAAA,EACJ,CAAC;AACL;AACA,MAAM,gBAAgB,CAAC,GAAG,OAAO,KAAK,QAAQ;AAC1C,MAAI,MAAM,YAAW;AACjB,eAAWT,cAAK,QAAQ,GAAG,MAAM,IAAI,GAAG,KAAK,GAAG;AACpD,aAAWA,cAAK,QAAQ,GAAG,MAAM,IAAI,GAAG,KAAK,GAAG;AACpD;AACO,MAAM,aAAa,CAAC,GAAG,KAAK,QAAQ;AACvC,MAAI;AACJ,MAAI;AACA,eAAWX,YAAG,YAAY,GAAG,EAAE,eAAe,MAAM;AAAA,EACxD,SACO,IAAI;AACP,UAAM,IAAI;AACV,QAAI,GAAG,SAAS;AACZ;AAAA,aACK,GAAG,SAAS,aAAa,GAAG,SAAS;AAC1C,aAAO,WAAW,GAAG,KAAK,GAAG;AAAA;AAE7B,YAAM;AAAA,EACd;AACA,aAAW,SAAS,UAAU;AAC1B,kBAAc,GAAG,OAAO,KAAK,GAAG;AAAA,EACpC;AACA,SAAO,WAAW,GAAG,KAAK,GAAG;AACjC;ACnFO,MAAM,iBAAiB,MAAM;AAAA,EAChC;AAAA,EACA;AAAA,EACA,UAAU;AAAA,EACV,YAAY,MAAML,OAAM;AACpB,UAAM,GAAGA,KAAI,qBAAqB,IAAI,GAAG;AACzC,SAAK,OAAO;AACZ,SAAK,OAAOA;AAAA,EAChB;AAAA,EACA,IAAI,OAAO;AACP,WAAO;AAAA,EACX;AACJ;ACZO,MAAM,qBAAqB,MAAM;AAAA,EACpC;AAAA,EACA;AAAA,EACA,UAAU;AAAA,EACV,OAAO;AAAA,EACP,YAAY,SAAS,MAAM;AACvB,UAAM,yDAAyD;AAC/D,SAAK,UAAU;AACf,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,IAAI,OAAO;AACP,WAAO;AAAA,EACX;AACJ;ACNA,MAAM,WAAW,CAAC,KAAK,OAAO;AAC1BK,cAAG,KAAK,KAAK,CAAC,IAAI,OAAO;AACrB,QAAI,MAAM,CAAC,GAAG,eAAe;AACzB,WAAK,IAAI,SAAS,KAAK,IAAI,QAAQ,SAAS;AAAA,IAChD;AACA,OAAG,EAAE;AAAA,EACT,CAAC;AACL;AASO,MAAM,QAAQ,CAAC,KAAK,KAAK,OAAO;AACnC,QAAM,qBAAqB,GAAG;AAI9B,QAAM,QAAQ,IAAI,SAAS;AAC3B,QAAM,OAAO,IAAI,OAAO;AACxB,QAAM,aAAa,OAAO,WAAW;AACrC,QAAM,MAAM,IAAI;AAChB,QAAM,MAAM,IAAI;AAChB,QAAM,UAAU,OAAO,QAAQ,YAC3B,OAAO,QAAQ,aACd,QAAQ,IAAI,cAAc,QAAQ,IAAI;AAC3C,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,IAAI;AACnB,QAAM,MAAM,qBAAqB,IAAI,GAAG;AACxC,QAAM,OAAO,CAAC,IAAI,YAAY;AAC1B,QAAI,IAAI;AACJ,SAAG,EAAE;AAAA,IACT,OACK;AACD,UAAI,WAAW,SAAS;AACpB,eAAO,SAAS,KAAK,KAAK,CAAAoB,QAAM,KAAKA,GAAE,CAAC;AAAA,MAC5C,WACS,WAAW;AAChBpB,oBAAG,MAAM,KAAK,MAAM,EAAE;AAAA,MAC1B,OACK;AACD,WAAE;AAAA,MACN;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,QAAQ,KAAK;AACb,WAAO,SAAS,KAAK,IAAI;AAAA,EAC7B;AACA,MAAI,UAAU;AACV,WAAO,IAAI,MAAM,KAAK,EAAE,MAAM,WAAW,KAAI,CAAE,EAAE;AAAA,MAAK,UAAQ,KAAK,MAAM,QAAQ,MAAS;AAAA;AAAA,MAC1F;AAAA,IAAI;AAAA,EACR;AACA,QAAM,MAAM,qBAAqBW,cAAK,SAAS,KAAK,GAAG,CAAC;AACxD,QAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,SAAO,KAAK,OAAO,MAAM,QAAQ,KAAK,QAAW,IAAI;AACzD;AACA,MAAM,SAAS,CAAC,MAAM,OAAO,MAAM,QAAQ,KAAK,SAAS,OAAO;AAC5D,MAAI,CAAC,MAAM,QAAQ;AACf,WAAO,GAAG,MAAM,OAAO;AAAA,EAC3B;AACA,QAAM,IAAI,MAAM,MAAK;AACrB,QAAM,OAAO,qBAAqBA,cAAK,QAAQ,OAAO,MAAM,CAAC,CAAC;AAC9DX,cAAG,MAAM,MAAM,MAAM,QAAQ,MAAM,OAAO,MAAM,QAAQ,KAAK,SAAS,EAAE,CAAC;AAC7E;AACA,MAAM,UAAU,CAAC,MAAM,OAAO,MAAM,QAAQ,KAAK,SAAS,OAAO,CAAC,OAAO;AACrE,MAAI,IAAI;AACJA,gBAAG,MAAM,MAAM,CAAC,QAAQ,OAAO;AAC3B,UAAI,QAAQ;AACR,eAAO,OACH,OAAO,QAAQ,qBAAqB,OAAO,IAAI;AACnD,WAAG,MAAM;AAAA,MACb,WACS,GAAG,eAAe;AACvB,eAAO,MAAM,OAAO,MAAM,QAAQ,KAAK,SAAS,EAAE;AAAA,MACtD,WACS,QAAQ;AACbA,oBAAG,OAAO,MAAM,CAAAoB,QAAM;AAClB,cAAIA,KAAI;AACJ,mBAAO,GAAGA,GAAE;AAAA,UAChB;AACApB,sBAAG,MAAM,MAAM,MAAM,QAAQ,MAAM,OAAO,MAAM,QAAQ,KAAK,SAAS,EAAE,CAAC;AAAA,QAC7E,CAAC;AAAA,MACL,WACS,GAAG,kBAAkB;AAC1B,eAAO,GAAG,IAAI,aAAa,MAAM,OAAO,MAAM,MAAM,KAAK,GAAG,CAAC,CAAC;AAAA,MAClE,OACK;AACD,WAAG,EAAE;AAAA,MACT;AAAA,IACJ,CAAC;AAAA,EACL,OACK;AACD,cAAU,WAAW;AACrB,WAAO,MAAM,OAAO,MAAM,QAAQ,KAAK,SAAS,EAAE;AAAA,EACtD;AACJ;AACA,MAAM,eAAe,CAAC,QAAQ;AAC1B,MAAI,KAAK;AACT,MAAIL,QAAO;AACX,MAAI;AACA,SAAKK,YAAG,SAAS,GAAG,EAAE,YAAW;AAAA,EACrC,SACO,IAAI;AACP,IAAAL,QAAO,IAAI;AAAA,EACf,UACJ;AACQ,QAAI,CAAC,IAAI;AACL,YAAM,IAAI,SAAS,KAAKA,SAAQ,SAAS;AAAA,IAC7C;AAAA,EACJ;AACJ;AACO,MAAM,YAAY,CAAC,KAAK,QAAQ;AACnC,QAAM,qBAAqB,GAAG;AAI9B,QAAM,QAAQ,IAAI,SAAS;AAC3B,QAAM,OAAO,IAAI,OAAO;AACxB,QAAM,aAAa,OAAO,WAAW;AACrC,QAAM,MAAM,IAAI;AAChB,QAAM,MAAM,IAAI;AAChB,QAAM,UAAU,OAAO,QAAQ,YAC3B,OAAO,QAAQ,aACd,QAAQ,IAAI,cAAc,QAAQ,IAAI;AAC3C,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,IAAI;AACnB,QAAM,MAAM,qBAAqB,IAAI,GAAG;AACxC,QAAM,OAAO,CAAC0B,aAAY;AACtB,QAAIA,YAAW,SAAS;AACpB,iBAAWA,UAAS,KAAK,GAAG;AAAA,IAChC;AACA,QAAI,WAAW;AACXrB,kBAAG,UAAU,KAAK,IAAI;AAAA,IAC1B;AAAA,EACJ;AACA,MAAI,QAAQ,KAAK;AACb,iBAAa,GAAG;AAChB,WAAO,KAAI;AAAA,EACf;AACA,MAAI,UAAU;AACV,WAAO,KAAKA,YAAG,UAAU,KAAK,EAAE,MAAM,WAAW,MAAM,KAAK,MAAS;AAAA,EACzE;AACA,QAAM,MAAM,qBAAqBW,cAAK,SAAS,KAAK,GAAG,CAAC;AACxD,QAAM,QAAQ,IAAI,MAAM,GAAG;AAC3B,MAAI,UAAU;AACd,WAAS,IAAI,MAAM,MAAK,GAAI,OAAO,KAAK,MAAM,QAAQ,MAAM,IAAI,IAAI,MAAM,MAAK,GAAI;AAC/E,WAAO,qBAAqBA,cAAK,QAAQ,IAAI,CAAC;AAC9C,QAAI;AACAX,kBAAG,UAAU,MAAM,IAAI;AACvB,gBAAU,WAAW;AAAA,IACzB,SACO,IAAI;AACP,YAAM,KAAKA,YAAG,UAAU,IAAI;AAC5B,UAAI,GAAG,eAAe;AAClB;AAAA,MACJ,WACS,QAAQ;AACbA,oBAAG,WAAW,IAAI;AAClBA,oBAAG,UAAU,MAAM,IAAI;AACvB,kBAAU,WAAW;AACrB;AAAA,MACJ,WACS,GAAG,kBAAkB;AAC1B,eAAO,IAAI,aAAa,MAAM,OAAO,MAAM,MAAM,KAAK,GAAG,CAAC;AAAA,MAC9D;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,KAAK,OAAO;AACvB;AC9KA,MAAM,iBAAiB,uBAAO,OAAO,IAAI;AAEzC,MAAM,MAAM;AACZ,MAAM,QAAQ,oBAAI,IAAG;AACd,MAAM,mBAAmB,CAAC,MAAM;AACnC,MAAI,CAAC,MAAM,IAAI,CAAC,GAAG;AACf,mBAAe,CAAC,IAAI,EAAE,UAAU,KAAK;AAAA,EACzC,OACK;AACD,UAAM,OAAO,CAAC;AAAA,EAClB;AACA,QAAM,IAAI,CAAC;AACX,QAAM,MAAM,eAAe,CAAC;AAC5B,MAAI,IAAI,MAAM,OAAO;AAErB,MAAI,IAAI,MAAM,IAAI;AACd,eAAWG,MAAK,OAAO;AACnB,YAAM,OAAOA,EAAC;AACd,aAAO,eAAeA,EAAC;AACvB,UAAI,EAAE,KAAK;AACP;AAAA,IACR;AAAA,EACJ;AACA,SAAO;AACX;AClBA,MAAMT,aAAW,QAAQ,IAAI,6BAA6B,QAAQ;AAClE,MAAMyB,cAAYzB,eAAa;AAG/B,MAAM,UAAU,CAAC,SAAS;AACtB,QAAM,OAAO,KACR,MAAM,GAAG,EACT,MAAM,GAAG,EAAE,EACX,OAAO,CAAC,KAAKiB,UAAS;AACvB,UAAM,IAAI,IAAI,IAAI,SAAS,CAAC;AAC5B,QAAI,MAAM,QAAW;AACjB,MAAAA,QAAO,KAAK,GAAGA,KAAI;AAAA,IACvB;AACA,QAAI,KAAKA,SAAQ,GAAG;AACpB,WAAO;AAAA,EACX,GAAG,CAAA,CAAE;AACL,SAAO;AACX;AACO,MAAM,iBAAiB;AAAA;AAAA;AAAA;AAAA,EAI1B,UAAU,oBAAI,IAAG;AAAA;AAAA,EAEjB,gBAAgB,oBAAI,IAAG;AAAA;AAAA,EAEvB,WAAW,oBAAI,IAAG;AAAA,EAClB,QAAQ,OAAO,IAAI;AACf,YACIQ,cACI,CAAC,gCAAgC,IAC/B,MAAM,IAAI,OAAK;AAEb,aAAO,qBAAqB,KAAK,iBAAiB,CAAC,CAAC,CAAC,EAAE,YAAW;AAAA,IACtE,CAAC;AACT,UAAM,OAAO,IAAI,IAAI,MAAM,IAAI,UAAQ,QAAQ,IAAI,CAAC,EAAE,OAAO,CAAC,GAAG,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC;AACnF,SAAK,cAAc,IAAI,IAAI,EAAE,MAAM,OAAO;AAC1C,eAAW,KAAK,OAAO;AACnB,YAAM,IAAI,KAAK,QAAQ,IAAI,CAAC;AAC5B,UAAI,CAAC,GAAG;AACJ,aAAK,QAAQ,IAAI,GAAG,CAAC,EAAE,CAAC;AAAA,MAC5B,OACK;AACD,UAAE,KAAK,EAAE;AAAA,MACb;AAAA,IACJ;AACA,eAAW,OAAO,MAAM;AACpB,YAAM,IAAI,KAAK,QAAQ,IAAI,GAAG;AAC9B,UAAI,CAAC,GAAG;AACJ,aAAK,QAAQ,IAAI,KAAK,CAAC,oBAAI,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;AAAA,MACzC,OACK;AACD,cAAM,IAAI,EAAE,EAAE,SAAS,CAAC;AACxB,YAAI,aAAa,KAAK;AAClB,YAAE,IAAI,EAAE;AAAA,QACZ,OACK;AACD,YAAE,KAAK,oBAAI,IAAI,CAAC,EAAE,CAAC,CAAC;AAAA,QACxB;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,KAAK,KAAK,EAAE;AAAA,EACvB;AAAA;AAAA;AAAA,EAGA,WAAW,IAAI;AACX,UAAM,MAAM,KAAK,cAAc,IAAI,EAAE;AAErC,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAClE;AAEA,WAAO;AAAA,MACH,OAAO,IAAI,MAAM,IAAI,CAAC,SAAS,KAAK,QAAQ,IAAI,IAAI,CAAC;AAAA,MACrD,MAAM,CAAC,GAAG,IAAI,IAAI,EAAE,IAAI,UAAQ,KAAK,QAAQ,IAAI,IAAI,CAAC;AAAA,IAClE;AAAA,EACI;AAAA;AAAA;AAAA,EAGA,MAAM,IAAI;AACN,UAAM,EAAE,OAAO,KAAI,IAAK,KAAK,WAAW,EAAE;AAC1C,WAAQ,MAAM,MAAM,OAAK,KAAK,EAAE,CAAC,MAAM,EAAE,KACrC,KAAK,MAAM,OAAK,KAAK,EAAE,CAAC,aAAa,OAAO,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC;AAAA,EAChE;AAAA;AAAA,EAEA,KAAK,IAAI;AACL,QAAI,KAAK,SAAS,IAAI,EAAE,KAAK,CAAC,KAAK,MAAM,EAAE,GAAG;AAC1C,aAAO;AAAA,IACX;AACA,SAAK,SAAS,IAAI,EAAE;AACpB,OAAG,MAAM,KAAK,OAAO,EAAE,CAAC;AACxB,WAAO;AAAA,EACX;AAAA,EACA,OAAO,IAAI;AACP,QAAI,CAAC,KAAK,SAAS,IAAI,EAAE,GAAG;AACxB,aAAO;AAAA,IACX;AACA,UAAM,MAAM,KAAK,cAAc,IAAI,EAAE;AAErC,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACzC;AAEA,UAAM,EAAE,OAAO,KAAI,IAAK;AACxB,UAAM,OAAO,oBAAI,IAAG;AACpB,eAAW,QAAQ,OAAO;AACtB,YAAM,IAAI,KAAK,QAAQ,IAAI,IAAI;AAE/B,UAAI,CAAC,KAAK,IAAI,CAAC,MAAM,IAAI;AACrB;AAAA,MACJ;AAEA,YAAM,KAAK,EAAE,CAAC;AACd,UAAI,CAAC,IAAI;AACL,aAAK,QAAQ,OAAO,IAAI;AACxB;AAAA,MACJ;AACA,QAAE,MAAK;AACP,UAAI,OAAO,OAAO,YAAY;AAC1B,aAAK,IAAI,EAAE;AAAA,MACf,OACK;AACD,mBAAW,KAAK,IAAI;AAChB,eAAK,IAAI,CAAC;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AACA,eAAW,OAAO,MAAM;AACpB,YAAM,IAAI,KAAK,QAAQ,IAAI,GAAG;AAC9B,YAAM,KAAK,IAAI,CAAC;AAEhB,UAAI,CAAC,KAAK,EAAE,cAAc;AACtB;AACJ,UAAI,GAAG,SAAS,KAAK,EAAE,WAAW,GAAG;AACjC,aAAK,QAAQ,OAAO,GAAG;AACvB;AAAA,MACJ,WACS,GAAG,SAAS,GAAG;AACpB,UAAE,MAAK;AAGP,cAAM,IAAI,EAAE,CAAC;AACb,YAAI,OAAO,MAAM,YAAY;AACzB,eAAK,IAAI,CAAC;AAAA,QACd;AAAA,MACJ,OACK;AACD,WAAG,OAAO,EAAE;AAAA,MAChB;AAAA,IACJ;AACA,SAAK,SAAS,OAAO,EAAE;AACvB,SAAK,QAAQ,CAAAG,QAAM,KAAK,KAAKA,GAAE,CAAC;AAChC,WAAO;AAAA,EACX;AACJ;ACnJA,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,WAAW,OAAO,UAAU;AAClC,MAAM,cAAc,OAAO,aAAa;AACxC,MAAM,YAAY,OAAO,WAAW;AACpC,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,SAAS,OAAO,QAAQ;AAC9B,MAAM,QAAQ,OAAO,OAAO;AAC5B,MAAM,aAAa,OAAO,YAAY;AACtC,MAAM,OAAO,OAAO,MAAM;AAC1B,MAAM,UAAU,OAAO,SAAS;AAChC,MAAM,MAAM,OAAO,KAAK;AACxB,MAAM,MAAM,OAAO,KAAK;AACxB,MAAM,cAAc,OAAO,YAAY;AACvC,MAAM,WAAW,QAAQ,IAAI,6BAA6B,QAAQ;AAClE,MAAM,YAAY,aAAa;AAC/B,MAAM,oBAAoB;AAiB1B,MAAM,aAAa,CAAC,MAAM,OAAO;AAC7B,MAAI,CAAC,WAAW;AACZ,WAAOtB,YAAG,OAAO,MAAM,EAAE;AAAA,EAC7B;AACA,QAAMuB,QAAO,OAAO,aAAa,YAAY,EAAE,EAAE,SAAS,KAAK;AAC/DvB,cAAG,OAAO,MAAMuB,OAAM,QAAM;AACxB,QAAI,IAAI;AACJ,aAAO,GAAG,EAAE;AAAA,IAChB;AACAvB,gBAAG,OAAOuB,OAAM,EAAE;AAAA,EACtB,CAAC;AACL;AAGA,MAAM,iBAAiB,CAAC,SAAS;AAC7B,MAAI,CAAC,WAAW;AACZ,WAAOvB,YAAG,WAAW,IAAI;AAAA,EAC7B;AACA,QAAMuB,QAAO,OAAO,aAAa,YAAY,EAAE,EAAE,SAAS,KAAK;AAC/DvB,cAAG,WAAW,MAAMuB,KAAI;AACxBvB,cAAG,WAAWuB,KAAI;AACtB;AAGA,MAAM,SAAS,CAAC,GAAG,GAAG,MAAM,MAAM,UAAa,MAAM,MAAM,IAAI,IACzD,MAAM,UAAa,MAAM,MAAM,IAAI,IAC/B;AACH,MAAM,eAAe,OAAO;AAAA,EAC/B,CAAC,KAAK,IAAI;AAAA,EACV,CAAC,WAAW,IAAI;AAAA,EAChB,CAAC,OAAO,IAAI;AAAA,EACZ,eAAe,IAAI,iBAAgB;AAAA,EACnC;AAAA,EACA,WAAW;AAAA,EACX,WAAW;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,MAAM,IAAI;AAClB,QAAI,SAAS,MAAM;AACf,WAAK,KAAK,IAAI;AACd,WAAK,UAAU,EAAC;AAAA,IACpB;AACA,UAAM,GAAG;AACT,SAAK,YAAY,IAAI;AACrB,SAAK,QAAQ,CAAC,CAAC,IAAI;AACnB,QAAI,OAAO,IAAI,QAAQ,YAAY,OAAO,IAAI,QAAQ,UAAU;AAE5D,UAAI,OAAO,IAAI,QAAQ,YACnB,OAAO,IAAI,QAAQ,UAAU;AAC7B,cAAM,IAAI,UAAU,6CAA6C;AAAA,MACrE;AACA,UAAI,IAAI,eAAe;AACnB,cAAM,IAAI,UAAU,gEAAgE;AAAA,MACxF;AACA,WAAK,MAAM,IAAI;AACf,WAAK,MAAM,IAAI;AACf,WAAK,WAAW;AAAA,IACpB,OACK;AACD,WAAK,MAAM;AACX,WAAK,MAAM;AACX,WAAK,WAAW;AAAA,IACpB;AAEA,QAAI,IAAI,kBAAkB,UACtB,OAAO,IAAI,QAAQ,UAAU;AAC7B,WAAK,gBAAgB,CAAC,EAAE,QAAQ,UAAU,QAAQ,OAAM,MAAO;AAAA,IACnE,OACK;AACD,WAAK,gBAAgB,CAAC,CAAC,IAAI;AAAA,IAC/B;AACA,SAAK,cACA,KAAK,iBAAiB,KAAK,aAAa,QAAQ,SAC7C,QAAQ,OAAM,IACZ;AACV,SAAK,cACA,KAAK,iBAAiB,KAAK,aAAa,QAAQ,SAC7C,QAAQ,OAAM,IACZ;AAGV,SAAK,WACD,OAAO,IAAI,aAAa,WACpB,IAAI,WACF;AAGV,SAAK,aAAa,IAAI,eAAe;AAErC,SAAK,QAAQ,CAAC,CAAC,IAAI,SAAS;AAE5B,SAAK,QAAQ,CAAC,CAAC,IAAI;AAEnB,SAAK,OAAO,CAAC,CAAC,IAAI;AAElB,SAAK,UAAU,CAAC,CAAC,IAAI;AAIrB,SAAK,gBAAgB,CAAC,CAAC,IAAI;AAG3B,SAAK,SAAS,CAAC,CAAC,IAAI;AACpB,SAAK,MAAM,qBAAqBZ,cAAK,QAAQ,IAAI,OAAO,QAAQ,IAAG,CAAE,CAAC;AACtE,SAAK,QAAQ,OAAO,IAAI,KAAK,KAAK;AAElC,SAAK,eACD,CAAC,KAAK,QAAQ,IACR,OAAO,IAAI,iBAAiB,WAAW,IAAI,eACvC,QAAQ,MAAK;AAC3B,SAAK,QACD,OAAO,IAAI,UAAU,WAAW,IAAI,QAAQ,KAAK;AAErD,SAAK,QAAQ,IAAI,SAAS,MAAS,CAAC,KAAK;AACzC,SAAK,QAAQ,IAAI,SAAS,MAAS,CAAC,KAAK;AACzC,SAAK,GAAG,SAAS,WAAS,KAAK,OAAO,EAAE,KAAK,CAAC;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAIA,KAAKhB,OAAM,KAAK,OAAO,CAAA,GAAI;AACvB,QAAIA,UAAS,qBAAqBA,UAAS,aAAa;AACpD,WAAK,cAAc;AAAA,IACvB;AACA,WAAO,MAAM,KAAKA,OAAM,KAAK,IAAI;AAAA,EACrC;AAAA,EACA,CAAC,UAAU,IAAI;AACX,QAAI,KAAK,KAAK,KAAK,KAAK,OAAO,MAAM,GAAG;AACpC,WAAK,KAAK,WAAW;AACrB,WAAK,KAAK,QAAQ;AAClB,WAAK,KAAK,KAAK;AAAA,IACnB;AAAA,EACJ;AAAA,EACA,CAAC,SAAS,EAAE,OAAO;AACf,UAAM,IAAI,qBAAqB,MAAM,IAAI;AACzC,UAAM,QAAQ,EAAE,MAAM,GAAG;AACzB,QAAI,KAAK,OAAO;AACZ,UAAI,MAAM,SAAS,KAAK,OAAO;AAC3B,eAAO;AAAA,MACX;AACA,UAAI,MAAM,SAAS,QAAQ;AACvB,cAAM,YAAY,qBAAqB,OAAO,MAAM,QAAQ,CAAC,EAAE,MAAM,GAAG;AACxE,YAAI,UAAU,UAAU,KAAK,OAAO;AAChC,gBAAM,WAAW,UAAU,MAAM,KAAK,KAAK,EAAE,KAAK,GAAG;AAAA,QACzD,OACK;AACD,iBAAO;AAAA,QACX;AAAA,MACJ;AACA,YAAM,OAAO,GAAG,KAAK,KAAK;AAC1B,YAAM,OAAO,MAAM,KAAK,GAAG;AAAA,IAC/B;AACA,QAAI,SAAS,KAAK,QAAQ,KAAK,MAAM,SAAS,KAAK,UAAU;AACzD,WAAK,KAAK,mBAAmB,yBAAyB;AAAA,QAClD;AAAA,QACA,MAAM;AAAA,QACN,OAAO,MAAM;AAAA,QACb,UAAU,KAAK;AAAA,MAC/B,CAAa;AACD,aAAO;AAAA,IACX;AACA,QAAI,CAAC,KAAK,eAAe;AACrB,UAAI,MAAM,SAAS,IAAI;AAAA,MAElB,aAAa,gBAAgB,KAAK,MAAM,CAAC,KAAK,EAAE,GAAI;AACrD,aAAK,KAAK,mBAAmB,sBAAsB;AAAA,UAC/C;AAAA,UACA,MAAM;AAAA,QAC1B,CAAiB;AACD,eAAO;AAAA,MACX;AAEA,YAAM,CAAC,MAAM,QAAQ,IAAI,kBAAkB,CAAC;AAC5C,UAAI,MAAM;AACN,cAAM,OAAO,OAAO,QAAQ;AAC5B,aAAK,KAAK,kBAAkB,aAAa,IAAI,uBAAuB;AAAA,UAChE;AAAA,UACA,MAAM;AAAA,QAC1B,CAAiB;AAAA,MACL;AAAA,IACJ;AACA,QAAIgB,cAAK,WAAW,MAAM,IAAI,GAAG;AAC7B,YAAM,WAAW,qBAAqBA,cAAK,QAAQ,MAAM,IAAI,CAAC;AAAA,IAClE,OACK;AACD,YAAM,WAAW,qBAAqBA,cAAK,QAAQ,KAAK,KAAK,MAAM,IAAI,CAAC;AAAA,IAC5E;AAKA,QAAI,CAAC,KAAK,iBACN,OAAO,MAAM,aAAa,YAC1B,MAAM,SAAS,QAAQ,KAAK,MAAM,GAAG,MAAM,KAC3C,MAAM,aAAa,KAAK,KAAK;AAC7B,WAAK,KAAK,mBAAmB,kCAAkC;AAAA,QAC3D;AAAA,QACA,MAAM,qBAAqB,MAAM,IAAI;AAAA,QACrC,cAAc,MAAM;AAAA,QACpB,KAAK,KAAK;AAAA,MAC1B,CAAa;AACD,aAAO;AAAA,IACX;AAIA,QAAI,MAAM,aAAa,KAAK,OACxB,MAAM,SAAS,eACf,MAAM,SAAS,cAAc;AAC7B,aAAO;AAAA,IACX;AAEA,QAAI,KAAK,OAAO;AACZ,YAAM,EAAE,MAAM,MAAK,IAAKA,cAAK,MAAM,MAAM,OAAO,MAAM,QAAQ,CAAC;AAC/D,YAAM,WACF,QAAQa,OAAU,OAAO,MAAM,QAAQ,EAAE,MAAM,MAAM,MAAM,CAAC;AAChE,YAAM,EAAE,MAAM,UAAUb,cAAK,MAAM,MAAM,MAAM,IAAI;AACnD,YAAM,OAAO,QAAQa,OAAU,MAAM,KAAK,MAAM,MAAM,MAAM,CAAC;AAAA,IACjE;AACA,WAAO;AAAA,EACX;AAAA,EACA,CAAC,OAAO,EAAE,OAAO;AACb,QAAI,CAAC,KAAK,SAAS,EAAE,KAAK,GAAG;AACzB,aAAO,MAAM,OAAM;AAAA,IACvB;AACAC,aAAO,MAAM,OAAO,MAAM,UAAU,QAAQ;AAC5C,YAAQ,MAAM,MAAI;AAAA,MACd,KAAK;AAAA,MACL,KAAK;AACD,YAAI,MAAM,MAAM;AACZ,gBAAM,OAAO,MAAM,OAAO;AAAA,QAC9B;AAAA;AAAA,MAEJ,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,eAAO,KAAK,OAAO,EAAE,KAAK;AAAA,MAC9B,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AACI,eAAO,KAAK,WAAW,EAAE,KAAK;AAAA,IAC9C;AAAA,EACI;AAAA,EACA,CAAC,OAAO,EAAE,IAAI,OAAO;AAIjB,QAAI,GAAG,SAAS,YAAY;AACxB,WAAK,KAAK,SAAS,EAAE;AAAA,IACzB,OACK;AACD,WAAK,KAAK,mBAAmB,IAAI,EAAE,MAAK,CAAE;AAC1C,WAAK,MAAM,EAAC;AACZ,YAAM,OAAM;AAAA,IAChB;AAAA,EACJ;AAAA,EACA,CAAC,KAAK,EAAE,KAAK,MAAM,IAAI;AACnB,UAAM,qBAAqB,GAAG,GAAG;AAAA,MAC7B,KAAK,KAAK;AAAA,MACV,KAAK,KAAK;AAAA,MACV,YAAY,KAAK;AAAA,MACjB,YAAY,KAAK;AAAA,MACjB,OAAO,KAAK;AAAA,MACZ,UAAU,KAAK;AAAA,MACf,QAAQ,KAAK;AAAA,MACb,KAAK,KAAK;AAAA,MACV;AAAA,IACZ,GAAW,EAAE;AAAA,EACT;AAAA,EACA,CAAC,OAAO,EAAE,OAAO;AAGb,WAAQ,KAAK,cACR,KAAK,kBACA,OAAO,MAAM,QAAQ,YACnB,MAAM,QAAQ,KAAK,cAClB,OAAO,MAAM,QAAQ,YAClB,MAAM,QAAQ,KAAK,eAC9B,OAAO,KAAK,QAAQ,YACjB,KAAK,QAAQ,KAAK,cACrB,OAAO,KAAK,QAAQ,YAAY,KAAK,QAAQ,KAAK;AAAA,EAC3D;AAAA,EACA,CAAC,GAAG,EAAE,OAAO;AACT,WAAO,OAAO,KAAK,KAAK,MAAM,KAAK,KAAK,UAAU;AAAA,EACtD;AAAA,EACA,CAAC,GAAG,EAAE,OAAO;AACT,WAAO,OAAO,KAAK,KAAK,MAAM,KAAK,KAAK,UAAU;AAAA,EACtD;AAAA,EACA,CAAC,IAAI,EAAE,OAAO,WAAW;AACrB,UAAM,OAAO,OAAO,MAAM,SAAS,WAC/B,MAAM,OAAO,OACX,KAAK;AACX,UAAM,SAAS,IAAIC,YAAgB,OAAO,MAAM,QAAQ,GAAG;AAAA;AAAA,MAEvD,OAAO,aAAa,MAAM,IAAI;AAAA,MAC9B;AAAA,MACA,WAAW;AAAA,IACvB,CAAS;AACD,WAAO,GAAG,SAAS,CAAC,OAAO;AACvB,UAAI,OAAO,IAAI;AACX1B,oBAAG,MAAM,OAAO,IAAI,MAAM;AAAA,QAAE,CAAC;AAAA,MACjC;AAIA,aAAO,QAAQ,MAAM;AACrB,WAAK,OAAO,EAAE,IAAI,KAAK;AACvB,gBAAS;AAAA,IACb,CAAC;AACD,QAAI,UAAU;AACd,UAAM,OAAO,CAAC,OAAO;AACjB,UAAI,IAAI;AAEJ,YAAI,OAAO,IAAI;AACXA,sBAAG,MAAM,OAAO,IAAI,MAAM;AAAA,UAAE,CAAC;AAAA,QACjC;AAEA,aAAK,OAAO,EAAE,IAAI,KAAK;AACvB,kBAAS;AACT;AAAA,MACJ;AACA,UAAI,EAAE,YAAY,GAAG;AACjB,YAAI,OAAO,OAAO,QAAW;AACzBA,sBAAG,MAAM,OAAO,IAAI,CAAAoB,QAAM;AACtB,gBAAIA,KAAI;AACJ,mBAAK,OAAO,EAAEA,KAAI,KAAK;AAAA,YAC3B,OACK;AACD,mBAAK,MAAM,EAAC;AAAA,YAChB;AACA,sBAAS;AAAA,UACb,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,GAAG,UAAU,MAAM;AAItB,YAAM,MAAM,OAAO,MAAM,QAAQ;AACjC,YAAM,KAAK,OAAO;AAClB,UAAI,OAAO,OAAO,YAAY,MAAM,SAAS,CAAC,KAAK,SAAS;AACxD;AACA,cAAM,QAAQ,MAAM,SAAS,oBAAI,KAAI;AACrC,cAAM,QAAQ,MAAM;AACpBpB,oBAAG,QAAQ,IAAI,OAAO,OAAO,QAAM,KAC/BA,YAAG,OAAO,KAAK,OAAO,OAAO,SAAO,KAAK,OAAO,EAAE,CAAC,IACjD,MAAM;AAAA,MAChB;AACA,UAAI,OAAO,OAAO,YAAY,KAAK,OAAO,EAAE,KAAK,GAAG;AAChD;AACA,cAAM,MAAM,KAAK,GAAG,EAAE,KAAK;AAC3B,cAAM,MAAM,KAAK,GAAG,EAAE,KAAK;AAC3B,YAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;AACpDA,sBAAG,OAAO,IAAI,KAAK,KAAK,QAAM,KAC1BA,YAAG,MAAM,KAAK,KAAK,KAAK,SAAO,KAAK,OAAO,EAAE,CAAC,IAC5C,MAAM;AAAA,QAChB;AAAA,MACJ;AACA,WAAI;AAAA,IACR,CAAC;AACD,UAAM,KAAK,KAAK,YAAY,KAAK,UAAU,KAAK,KAAK,QAAQ;AAC7D,QAAI,OAAO,OAAO;AACd,SAAG,GAAG,SAAS,CAAC,OAAO;AACnB,aAAK,OAAO,EAAE,IAAI,KAAK;AACvB,kBAAS;AAAA,MACb,CAAC;AACD,YAAM,KAAK,EAAE;AAAA,IACjB;AACA,OAAG,KAAK,MAAM;AAAA,EAClB;AAAA,EACA,CAAC,SAAS,EAAE,OAAO,WAAW;AAC1B,UAAM,OAAO,OAAO,MAAM,SAAS,WAC/B,MAAM,OAAO,OACX,KAAK;AACX,SAAK,KAAK,EAAE,OAAO,MAAM,QAAQ,GAAG,MAAM,QAAM;AAC5C,UAAI,IAAI;AACJ,aAAK,OAAO,EAAE,IAAI,KAAK;AACvB,kBAAS;AACT;AAAA,MACJ;AACA,UAAI,UAAU;AACd,YAAM,OAAO,MAAM;AACf,YAAI,EAAE,YAAY,GAAG;AACjB,oBAAS;AACT,eAAK,MAAM,EAAC;AACZ,gBAAM,OAAM;AAAA,QAChB;AAAA,MACJ;AACA,UAAI,MAAM,SAAS,CAAC,KAAK,SAAS;AAC9B;AACAA,oBAAG,OAAO,OAAO,MAAM,QAAQ,GAAG,MAAM,SAAS,oBAAI,KAAI,GAAI,MAAM,OAAO,IAAI;AAAA,MAClF;AACA,UAAI,KAAK,OAAO,EAAE,KAAK,GAAG;AACtB;AACAA,oBAAG,MAAM,OAAO,MAAM,QAAQ,GAAG,OAAO,KAAK,GAAG,EAAE,KAAK,CAAC,GAAG,OAAO,KAAK,GAAG,EAAE,KAAK,CAAC,GAAG,IAAI;AAAA,MAC7F;AACA,WAAI;AAAA,IACR,CAAC;AAAA,EACL;AAAA,EACA,CAAC,WAAW,EAAE,OAAO;AACjB,UAAM,cAAc;AACpB,SAAK,KAAK,yBAAyB,2BAA2B,MAAM,IAAI,IAAI,EAAE,OAAO;AACrF,UAAM,OAAM;AAAA,EAChB;AAAA,EACA,CAAC,OAAO,EAAE,OAAO,MAAM;AACnB,SAAK,IAAI,EAAE,OAAO,OAAO,MAAM,QAAQ,GAAG,WAAW,IAAI;AAAA,EAC7D;AAAA,EACA,CAAC,QAAQ,EAAE,OAAO,MAAM;AACpB,UAAM,WAAW,qBAAqBW,cAAK,QAAQ,KAAK,KAAK,OAAO,MAAM,QAAQ,CAAC,CAAC;AACpF,SAAK,IAAI,EAAE,OAAO,UAAU,QAAQ,IAAI;AAAA,EAC5C;AAAA,EACA,CAAC,IAAI,IAAI;AACL,SAAK,OAAO;AAAA,EAChB;AAAA,EACA,CAAC,MAAM,IAAI;AACP,SAAK,OAAO;AACZ,SAAK,UAAU,EAAC;AAAA,EACpB;AAAA,EACA,CAAC,IAAI,EAAE,OAAO;AACV,SAAK,MAAM,EAAC;AACZ,UAAM,OAAM;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAIA,CAAC,UAAU,EAAE,OAAO,IAAI;AACpB,WAAQ,MAAM,SAAS,UACnB,CAAC,KAAK,UACN,GAAG,OAAM,KACT,GAAG,SAAS,KACZ,CAAC;AAAA,EACT;AAAA;AAAA,EAEA,CAAC,OAAO,EAAE,OAAO;AACb,SAAK,IAAI,EAAC;AACV,UAAM,QAAQ,CAAC,MAAM,IAAI;AACzB,QAAI,MAAM,UAAU;AAChB,YAAM,KAAK,MAAM,QAAQ;AAAA,IAC7B;AACA,SAAK,aAAa,QAAQ,OAAO,UAAQ,KAAK,QAAQ,EAAE,OAAO,IAAI,CAAC;AAAA,EACxE;AAAA,EACA,CAAC,QAAQ,EAAE,OAAO,WAAW;AACzB,UAAM,OAAO,CAAC,OAAO;AACjB,gBAAU,EAAE;AAAA,IAChB;AACA,UAAMgB,YAAW,MAAM;AACnB,WAAK,KAAK,EAAE,KAAK,KAAK,KAAK,OAAO,QAAM;AACpC,YAAI,IAAI;AACJ,eAAK,OAAO,EAAE,IAAI,KAAK;AACvB,eAAI;AACJ;AAAA,QACJ;AACA,aAAK,WAAW,IAAI;AACpB,cAAK;AAAA,MACT,CAAC;AAAA,IACL;AACA,UAAM,QAAQ,MAAM;AAChB,UAAI,MAAM,aAAa,KAAK,KAAK;AAC7B,cAAM,SAAS,qBAAqBhB,cAAK,QAAQ,OAAO,MAAM,QAAQ,CAAC,CAAC;AACxE,YAAI,WAAW,KAAK,KAAK;AACrB,iBAAO,KAAK,KAAK,EAAE,QAAQ,KAAK,OAAO,QAAM;AACzC,gBAAI,IAAI;AACJ,mBAAK,OAAO,EAAE,IAAI,KAAK;AACvB,mBAAI;AACJ;AAAA,YACJ;AACA,4BAAe;AAAA,UACnB,CAAC;AAAA,QACL;AAAA,MACJ;AACA,sBAAe;AAAA,IACnB;AACA,UAAM,kBAAkB,MAAM;AAC1BX,kBAAG,MAAM,OAAO,MAAM,QAAQ,GAAG,CAAC,SAAS,OAAO;AAC9C,YAAI,OACC,KAAK;AAAA,QAED,KAAK,SAAS,GAAG,SAAS,MAAM,SAAS,GAAG,SAAU;AAC3D,eAAK,IAAI,EAAE,KAAK;AAChB,eAAI;AACJ;AAAA,QACJ;AACA,YAAI,WAAW,KAAK,UAAU,EAAE,OAAO,EAAE,GAAG;AACxC,iBAAO,KAAK,MAAM,EAAE,MAAM,OAAO,IAAI;AAAA,QACzC;AACA,YAAI,GAAG,eAAe;AAClB,cAAI,MAAM,SAAS,aAAa;AAC5B,kBAAM,YAAY,KAAK,SACnB,MAAM,SACL,GAAG,OAAO,UAAY,MAAM;AACjC,kBAAM,aAAa,CAAC,OAAO,KAAK,MAAM,EAAE,MAAM,MAAM,OAAO,IAAI;AAC/D,gBAAI,CAAC,WAAW;AACZ,qBAAO,WAAU;AAAA,YACrB;AACA,mBAAOA,YAAG,MAAM,OAAO,MAAM,QAAQ,GAAG,OAAO,MAAM,IAAI,GAAG,UAAU;AAAA,UAC1E;AAQA,cAAI,MAAM,aAAa,KAAK,KAAK;AAC7B,mBAAOA,YAAG,MAAM,OAAO,MAAM,QAAQ,GAAG,CAAC,OAAO,KAAK,MAAM,EAAE,MAAM,MAAM,OAAO,IAAI,CAAC;AAAA,UACzF;AAAA,QACJ;AAGA,YAAI,MAAM,aAAa,KAAK,KAAK;AAC7B,iBAAO,KAAK,MAAM,EAAE,MAAM,OAAO,IAAI;AAAA,QACzC;AACA,mBAAW,OAAO,MAAM,QAAQ,GAAG,QAAM,KAAK,MAAM,EAAE,MAAM,MAAM,OAAO,IAAI,CAAC;AAAA,MAClF,CAAC;AAAA,IACL;AACA,QAAI,KAAK,WAAW,GAAG;AACnB,YAAK;AAAA,IACT,OACK;AACD,MAAA2B,UAAQ;AAAA,IACZ;AAAA,EACJ;AAAA,EACA,CAAC,MAAM,EAAE,IAAI,OAAO,MAAM;AACtB,QAAI,IAAI;AACJ,WAAK,OAAO,EAAE,IAAI,KAAK;AACvB,WAAI;AACJ;AAAA,IACJ;AACA,YAAQ,MAAM,MAAI;AAAA,MACd,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACD,eAAO,KAAK,IAAI,EAAE,OAAO,IAAI;AAAA,MACjC,KAAK;AACD,eAAO,KAAK,QAAQ,EAAE,OAAO,IAAI;AAAA,MACrC,KAAK;AACD,eAAO,KAAK,OAAO,EAAE,OAAO,IAAI;AAAA,MACpC,KAAK;AAAA,MACL,KAAK;AACD,eAAO,KAAK,SAAS,EAAE,OAAO,IAAI;AAAA,IAClD;AAAA,EACI;AAAA,EACA,CAAC,IAAI,EAAE,OAAO,UAAU,MAAM,MAAM;AAEhC3B,gBAAG,IAAI,EAAE,UAAU,OAAO,MAAM,QAAQ,GAAG,QAAM;AAC7C,UAAI,IAAI;AACJ,aAAK,OAAO,EAAE,IAAI,KAAK;AAAA,MAC3B,OACK;AACD,aAAK,MAAM,EAAC;AACZ,cAAM,OAAM;AAAA,MAChB;AACA,WAAI;AAAA,IACR,CAAC;AAAA,EACL;AACJ;AACA,MAAM,WAAW,CAAC,OAAO;AACrB,MAAI;AACA,WAAO,CAAC,MAAM,IAAI;AAAA,EACtB,SACO,IAAI;AACP,WAAO,CAAC,IAAI,IAAI;AAAA,EACpB;AACJ;AACO,MAAM,mBAAmB,OAAO;AAAA,EACnC,OAAO;AAAA,EACP,CAAC,MAAM,EAAE,IAAI,OAAO;AAChB,WAAO,MAAM,MAAM,EAAE,IAAI,OAAO,MAAM;AAAA,IAAE,CAAC;AAAA,EAC7C;AAAA,EACA,CAAC,OAAO,EAAE,OAAO;AACb,QAAI,CAAC,KAAK,WAAW,GAAG;AACpB,YAAMoB,MAAK,KAAK,KAAK,EAAE,KAAK,KAAK,KAAK,KAAK;AAC3C,UAAIA,KAAI;AACJ,eAAO,KAAK,OAAO,EAAEA,KAAI,KAAK;AAAA,MAClC;AACA,WAAK,WAAW,IAAI;AAAA,IACxB;AAGA,QAAI,MAAM,aAAa,KAAK,KAAK;AAC7B,YAAM,SAAS,qBAAqBT,cAAK,QAAQ,OAAO,MAAM,QAAQ,CAAC,CAAC;AACxE,UAAI,WAAW,KAAK,KAAK;AACrB,cAAM,WAAW,KAAK,KAAK,EAAE,QAAQ,KAAK,KAAK;AAC/C,YAAI,UAAU;AACV,iBAAO,KAAK,OAAO,EAAE,UAAU,KAAK;AAAA,QACxC;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,CAAC,SAAS,EAAE,IAAI,SAAS,MAAMX,YAAG,UAAU,OAAO,MAAM,QAAQ,CAAC,CAAC;AACzE,QAAI,OACC,KAAK;AAAA,IAED,KAAK,SAAS,GAAG,SAAS,MAAM,SAAS,GAAG,SAAU;AAC3D,aAAO,KAAK,IAAI,EAAE,KAAK;AAAA,IAC3B;AACA,QAAI,WAAW,KAAK,UAAU,EAAE,OAAO,EAAE,GAAG;AACxC,aAAO,KAAK,MAAM,EAAE,MAAM,KAAK;AAAA,IACnC;AACA,QAAI,GAAG,eAAe;AAClB,UAAI,MAAM,SAAS,aAAa;AAC5B,cAAM,YAAY,KAAK,SACnB,MAAM,SACL,GAAG,OAAO,UAAY,MAAM;AACjC,cAAM,CAACoB,GAAE,IAAI,YACT,SAAS,MAAM;AACXpB,sBAAG,UAAU,OAAO,MAAM,QAAQ,GAAG,OAAO,MAAM,IAAI,CAAC;AAAA,QAC3D,CAAC,IACC,CAAA;AACN,eAAO,KAAK,MAAM,EAAEoB,KAAI,KAAK;AAAA,MACjC;AAEA,YAAM,CAACA,GAAE,IAAI,SAAS,MAAMpB,YAAG,UAAU,OAAO,MAAM,QAAQ,CAAC,CAAC;AAChE,WAAK,MAAM,EAAEoB,KAAI,KAAK;AAAA,IAC1B;AAGA,UAAM,CAAC,EAAE,IAAI,MAAM,aAAa,KAAK,MACjC,CAAA,IACE,SAAS,MAAM,eAAe,OAAO,MAAM,QAAQ,CAAC,CAAC;AAC3D,SAAK,MAAM,EAAE,IAAI,KAAK;AAAA,EAC1B;AAAA,EACA,CAAC,IAAI,EAAE,OAAO,MAAM;AAChB,UAAM,OAAO,OAAO,MAAM,SAAS,WAC/B,MAAM,OAAO,OACX,KAAK;AACX,UAAM,OAAO,CAAC,OAAO;AACjB,UAAI;AACJ,UAAI;AACApB,oBAAG,UAAU,EAAE;AAAA,MACnB,SACO,GAAG;AACN,qBAAa;AAAA,MACjB;AACA,UAAI,MAAM,YAAY;AAClB,aAAK,OAAO,EAAE,MAAM,YAAY,KAAK;AAAA,MACzC;AACA,WAAI;AAAA,IACR;AACA,QAAI;AACJ,QAAI;AACA,WAAKA,YAAG,SAAS,OAAO,MAAM,QAAQ,GAAG,aAAa,MAAM,IAAI,GAAG,IAAI;AAAA,IAK3E,SACO,IAAI;AACP,aAAO,KAAK,EAAE;AAAA,IAClB;AAEA,UAAM,KAAK,KAAK,YAAY,KAAK,UAAU,KAAK,KAAK,QAAQ;AAC7D,QAAI,OAAO,OAAO;AACd,SAAG,GAAG,SAAS,CAAC,OAAO,KAAK,OAAO,EAAE,IAAI,KAAK,CAAC;AAC/C,YAAM,KAAK,EAAE;AAAA,IACjB;AACA,OAAG,GAAG,QAAQ,CAAC,UAAU;AACrB,UAAI;AACAA,oBAAG,UAAU,IAAI,OAAO,GAAG,MAAM,MAAM;AAAA,MAC3C,SACO,IAAI;AACP,aAAK,EAAE;AAAA,MACX;AAAA,IACJ,CAAC;AACD,OAAG,GAAG,OAAO,MAAM;AACf,UAAI,KAAK;AAGT,UAAI,MAAM,SAAS,CAAC,KAAK,SAAS;AAC9B,cAAM,QAAQ,MAAM,SAAS,oBAAI,KAAI;AACrC,cAAM,QAAQ,MAAM;AACpB,YAAI;AACAA,sBAAG,YAAY,IAAI,OAAO,KAAK;AAAA,QACnC,SACO,WAAW;AACd,cAAI;AACAA,wBAAG,WAAW,OAAO,MAAM,QAAQ,GAAG,OAAO,KAAK;AAAA,UACtD,SACO,UAAU;AACb,iBAAK;AAAA,UACT;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,KAAK,OAAO,EAAE,KAAK,GAAG;AACtB,cAAM,MAAM,KAAK,GAAG,EAAE,KAAK;AAC3B,cAAM,MAAM,KAAK,GAAG,EAAE,KAAK;AAC3B,YAAI;AACAA,sBAAG,WAAW,IAAI,OAAO,GAAG,GAAG,OAAO,GAAG,CAAC;AAAA,QAC9C,SACO,UAAU;AACb,cAAI;AACAA,wBAAG,UAAU,OAAO,MAAM,QAAQ,GAAG,OAAO,GAAG,GAAG,OAAO,GAAG,CAAC;AAAA,UACjE,SACO,SAAS;AACZ,iBAAK,MAAM;AAAA,UACf;AAAA,QACJ;AAAA,MACJ;AACA,WAAK,EAAE;AAAA,IACX,CAAC;AAAA,EACL;AAAA,EACA,CAAC,SAAS,EAAE,OAAO,MAAM;AACrB,UAAM,OAAO,OAAO,MAAM,SAAS,WAC/B,MAAM,OAAO,OACX,KAAK;AACX,UAAM,KAAK,KAAK,KAAK,EAAE,OAAO,MAAM,QAAQ,GAAG,IAAI;AACnD,QAAI,IAAI;AACJ,WAAK,OAAO,EAAE,IAAI,KAAK;AACvB,WAAI;AACJ;AAAA,IACJ;AACA,QAAI,MAAM,SAAS,CAAC,KAAK,SAAS;AAC9B,UAAI;AACAA,oBAAG,WAAW,OAAO,MAAM,QAAQ,GAAG,MAAM,SAAS,oBAAI,QAAQ,MAAM,KAAK;AAAA,MAEhF,SACOoB,KAAI;AAAA,MAAE;AAAA,IACjB;AACA,QAAI,KAAK,OAAO,EAAE,KAAK,GAAG;AACtB,UAAI;AACApB,oBAAG,UAAU,OAAO,MAAM,QAAQ,GAAG,OAAO,KAAK,GAAG,EAAE,KAAK,CAAC,GAAG,OAAO,KAAK,GAAG,EAAE,KAAK,CAAC,CAAC;AAAA,MAC3F,SACOoB,KAAI;AAAA,MAAE;AAAA,IACjB;AACA,SAAI;AACJ,UAAM,OAAM;AAAA,EAChB;AAAA,EACA,CAAC,KAAK,EAAE,KAAK,MAAM;AACf,QAAI;AACA,aAAO,UAAU,qBAAqB,GAAG,GAAG;AAAA,QACxC,KAAK,KAAK;AAAA,QACV,KAAK,KAAK;AAAA,QACV,YAAY,KAAK;AAAA,QACjB,YAAY,KAAK;AAAA,QACjB,OAAO,KAAK;AAAA,QACZ,UAAU,KAAK;AAAA,QACf,QAAQ,KAAK;AAAA,QACb,KAAK,KAAK;AAAA,QACV;AAAA,MAChB,CAAa;AAAA,IACL,SACO,IAAI;AACP,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,CAAC,IAAI,EAAE,OAAO,UAAU,MAAM,MAAM;AAChC,UAAM,KAAK,GAAG,IAAI;AAClB,QAAI;AACApB,kBAAG,EAAE,EAAE,UAAU,OAAO,MAAM,QAAQ,CAAC;AACvC,WAAI;AACJ,YAAM,OAAM;AAAA,IAChB,SACO,IAAI;AACP,aAAO,KAAK,OAAO,EAAE,IAAI,KAAK;AAAA,IAClC;AAAA,EACJ;AACJ;ACh0BA,MAAM,kBAAkB,CAAC,QAAQ;AAC7B,QAAM,IAAI,IAAI,WAAW,GAAG;AAC5B,QAAM,OAAO,IAAI;AACjB,QAAM,OAAOA,YAAG,SAAS,IAAI;AAG7B,QAAM,WAAW,IAAI,eAAe,KAAK,OAAO;AAChD,QAAM,SAAS,IAAI4B,eAAmB,MAAM;AAAA,IACxC;AAAA,IACA,MAAM,KAAK;AAAA,EACnB,CAAK;AACD,SAAO,KAAK,CAAC;AACjB;AACA,MAAM,cAAc,CAAC,KAAK,MAAM;AAC5B,QAAM,IAAI,IAAI,OAAO,GAAG;AACxB,QAAM,WAAW,IAAI,eAAe,KAAK,OAAO;AAChD,QAAM,OAAO,IAAI;AACjB,QAAM,IAAI,IAAI,QAAQ,CAAC/C,UAAS,WAAW;AACvC,MAAE,GAAG,SAAS,MAAM;AACpB,MAAE,GAAG,SAASA,QAAO;AAGrBmB,gBAAG,KAAK,MAAM,CAAC,IAAI,SAAS;AACxB,UAAI,IAAI;AACJ,eAAO,EAAE;AAAA,MACb,OACK;AACD,cAAM,SAAS,IAAIE,WAAe,MAAM;AAAA,UACpC;AAAA,UACA,MAAM,KAAK;AAAA,QAC/B,CAAiB;AACD,eAAO,GAAG,SAAS,MAAM;AACzB,eAAO,KAAK,CAAC;AAAA,MACjB;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACD,SAAO;AACX;AACO,MAAM,UAAU,YAAY,iBAAiB,aAAa,SAAO,IAAI,WAAW,GAAG,GAAG,SAAO,IAAI,OAAO,GAAG,GAAG,CAAC,KAAK,UAAU;AACjI,MAAI,OAAO;AACP,gBAAY,KAAK,KAAK;AAC9B,CAAC;ACjCD,MAAM,cAAc,CAAC,KAAK,UAAU;AAChC,QAAM,IAAI,IAAI,SAAS,GAAG;AAC1B,MAAI,QAAQ;AACZ,MAAI;AACJ,MAAI;AACJ,MAAI;AACA,QAAI;AACA,WAAKF,YAAG,SAAS,IAAI,MAAM,IAAI;AAAA,IACnC,SACO,IAAI;AACP,UAAI,IAAI,SAAS,UAAU;AACvB,aAAKA,YAAG,SAAS,IAAI,MAAM,IAAI;AAAA,MACnC,OACK;AACD,cAAM;AAAA,MACV;AAAA,IACJ;AACA,UAAM,KAAKA,YAAG,UAAU,EAAE;AAC1B,UAAM,UAAU,OAAO,MAAM,GAAG;AAChC,aAAU,MAAK,WAAW,GAAG,WAAW,GAAG,MAAM,YAAY,KAAK;AAC9D,eAAS,SAAS,GAAG,QAAQ,GAAG,SAAS,KAAK,UAAU,OAAO;AAC3D,gBAAQA,YAAG,SAAS,IAAI,SAAS,QAAQ,QAAQ,SAAS,QAAQ,WAAW,MAAM;AACnF,YAAI,aAAa,KACb,QAAQ,CAAC,MAAM,MACf,QAAQ,CAAC,MAAM,KAAM;AACrB,gBAAM,IAAI,MAAM,sCAAsC;AAAA,QAC1D;AACA,YAAI,CAAC,OAAO;AACR,gBAAM;AAAA,QACV;AAAA,MACJ;AACA,YAAM,IAAI,IAAI,OAAO,OAAO;AAC5B,UAAI,CAAC,EAAE,YAAY;AACf;AAAA,MACJ;AACA,YAAM,iBAAiB,MAAM,KAAK,MAAM,EAAE,QAAQ,KAAK,GAAG;AAC1D,UAAI,WAAW,iBAAiB,MAAM,GAAG,MAAM;AAC3C;AAAA,MACJ;AAGA,kBAAY;AACZ,UAAI,IAAI,cAAc,EAAE,OAAO;AAC3B,YAAI,WAAW,IAAI,OAAO,EAAE,IAAI,GAAG,EAAE,KAAK;AAAA,MAC9C;AAAA,IACJ;AACA,YAAQ;AACR,eAAW,KAAK,GAAG,UAAU,IAAI,KAAK;AAAA,EAC1C,UACJ;AACQ,QAAI,OAAO;AACP,UAAI;AACAA,oBAAG,UAAU,EAAE;AAAA,MACnB,SACO,IAAI;AAAA,MAAE;AAAA,IACjB;AAAA,EACJ;AACJ;AACA,MAAM,aAAa,CAAC,KAAK,GAAG,UAAU,IAAI,UAAU;AAChD,QAAM,SAAS,IAAI,gBAAgB,IAAI,MAAM;AAAA,IACzC;AAAA,IACA,OAAO;AAAA,EACf,CAAK;AACD,IAAE,KAAK,MAAM;AACb,eAAa,GAAG,KAAK;AACzB;AACA,MAAM,eAAe,CAAC,KAAK,UAAU;AACjC,UAAQ,MAAM,KAAK,KAAK;AACxB,QAAM,IAAI,IAAI,KAAK,GAAG;AACtB,QAAM,SAAS,CAAC,IAAI,MAAM,QAAQ;AAC9B,UAAM,KAAK,CAAC,IAAIC,SAAQ;AACpB,UAAI,IAAI;AACJD,oBAAG,MAAM,IAAI,OAAK,IAAI,EAAE,CAAC;AAAA,MAC7B,OACK;AACD,YAAI,MAAMC,IAAG;AAAA,MACjB;AAAA,IACJ;AACA,QAAI,WAAW;AACf,QAAI,SAAS,GAAG;AACZ,aAAO,GAAG,MAAM,CAAC;AAAA,IACrB;AACA,QAAI,SAAS;AACb,UAAM,UAAU,OAAO,MAAM,GAAG;AAChC,UAAM,SAAS,CAAC,IAAI,UAAU;AAC1B,UAAI,MAAM,OAAO,UAAU,aAAa;AACpC,eAAO,GAAG,EAAE;AAAA,MAChB;AACA,gBAAU;AACV,UAAI,SAAS,OAAO,OAAO;AACvB,eAAOD,YAAG,KAAK,IAAI,SAAS,QAAQ,QAAQ,SAAS,QAAQ,WAAW,QAAQ,MAAM;AAAA,MAC1F;AACA,UAAI,aAAa,KACb,QAAQ,CAAC,MAAM,MACf,QAAQ,CAAC,MAAM,KAAM;AACrB,eAAO,GAAG,IAAI,MAAM,sCAAsC,CAAC;AAAA,MAC/D;AAEA,UAAI,SAAS,KAAK;AACd,eAAO,GAAG,MAAM,QAAQ;AAAA,MAC5B;AACA,YAAM,IAAI,IAAI,OAAO,OAAO;AAC5B,UAAI,CAAC,EAAE,YAAY;AACf,eAAO,GAAG,MAAM,QAAQ;AAAA,MAC5B;AAEA,YAAM,iBAAiB,MAAM,KAAK,MAAM,EAAE,QAAQ,KAAK,GAAG;AAC1D,UAAI,WAAW,iBAAiB,MAAM,MAAM;AACxC,eAAO,GAAG,MAAM,QAAQ;AAAA,MAC5B;AACA,kBAAY,iBAAiB;AAC7B,UAAI,YAAY,MAAM;AAClB,eAAO,GAAG,MAAM,QAAQ;AAAA,MAC5B;AACA,UAAI,IAAI,cAAc,EAAE,OAAO;AAC3B,YAAI,WAAW,IAAI,OAAO,EAAE,IAAI,GAAG,EAAE,KAAK;AAAA,MAC9C;AACA,eAAS;AACTA,kBAAG,KAAK,IAAI,SAAS,GAAG,KAAK,UAAU,MAAM;AAAA,IACjD;AACAA,gBAAG,KAAK,IAAI,SAAS,GAAG,KAAK,UAAU,MAAM;AAAA,EACjD;AACA,QAAM,UAAU,IAAI,QAAQ,CAACnB,UAAS,WAAW;AAC7C,MAAE,GAAG,SAAS,MAAM;AACpB,QAAI,OAAO;AACX,UAAM,SAAS,CAAC,IAAI,OAAO;AACvB,UAAI,MAAM,GAAG,SAAS,YAAY,SAAS,MAAM;AAC7C,eAAO;AACP,eAAOmB,YAAG,KAAK,IAAI,MAAM,MAAM,MAAM;AAAA,MACzC;AACA,UAAI,MAAM,CAAC,IAAI;AACX,eAAO,OAAO,EAAE;AAAA,MACpB;AACAA,kBAAG,MAAM,IAAI,CAACoB,KAAI,OAAO;AACrB,YAAIA,KAAI;AACJ,iBAAOpB,YAAG,MAAM,IAAI,MAAM,OAAOoB,GAAE,CAAC;AAAA,QACxC;AACA,eAAO,IAAI,GAAG,MAAM,CAACA,KAAI,aAAa;AAClC,cAAIA,KAAI;AACJ,mBAAO,OAAOA,GAAE;AAAA,UACpB;AACA,gBAAM,SAAS,IAAI,YAAY,IAAI,MAAM;AAAA,YACrC;AAAA,YACA,OAAO;AAAA,UAC/B,CAAqB;AACD,YAAE,KAAK,MAAM;AACb,iBAAO,GAAG,SAAS,MAAM;AACzB,iBAAO,GAAG,SAASvC,QAAO;AAC1B,wBAAc,GAAG,KAAK;AAAA,QAC1B,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACAmB,gBAAG,KAAK,IAAI,MAAM,MAAM,MAAM;AAAA,EAClC,CAAC;AACD,SAAO;AACX;AACA,MAAM,eAAe,CAAC,GAAG,UAAU;AAC/B,QAAM,QAAQ,UAAQ;AAClB,QAAI,KAAK,OAAO,CAAC,MAAM,KAAK;AACxB,WAAK;AAAA,QACD,MAAMW,cAAK,QAAQ,EAAE,KAAK,KAAK,MAAM,CAAC,CAAC;AAAA,QACvC,MAAM;AAAA,QACN,UAAU;AAAA,QACV,aAAa,WAAS,EAAE,IAAI,KAAK;AAAA,MACjD,CAAa;AAAA,IACL,OACK;AACD,QAAE,IAAI,IAAI;AAAA,IACd;AAAA,EACJ,CAAC;AACD,IAAE,IAAG;AACT;AACA,MAAM,gBAAgB,OAAO,GAAG,UAAU;AACtC,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,UAAM,OAAO,OAAO,MAAM,CAAC,CAAC;AAC5B,QAAI,KAAK,OAAO,CAAC,MAAM,KAAK;AACxB,YAAM,KAAK;AAAA,QACP,MAAMA,cAAK,QAAQ,OAAO,EAAE,GAAG,GAAG,KAAK,MAAM,CAAC,CAAC;AAAA,QAC/C,UAAU;AAAA,QACV,aAAa,WAAS,EAAE,IAAI,KAAK;AAAA,MACjD,CAAa;AAAA,IACL,OACK;AACD,QAAE,IAAI,IAAI;AAAA,IACd;AAAA,EACJ;AACA,IAAE,IAAG;AACT;AACO,MAAM,UAAU;AAAA,EAAY;AAAA,EAAa;AAAA;AAAA,EAEhD,MAAM;AACF,UAAM,IAAI,UAAU,kBAAkB;AAAA,EAC1C;AAAA,EAAG,MAAM;AACL,UAAM,IAAI,UAAU,kBAAkB;AAAA,EAC1C;AAAA;AAAA,EAEA,CAAC,KAAK,YAAY;AACd,QAAI,CAAC,OAAO,GAAG,GAAG;AACd,YAAM,IAAI,UAAU,kBAAkB;AAAA,IAC1C;AACA,QAAI,IAAI,QACJ,IAAI,UACJ,IAAI,QACJ,IAAI,KAAK,SAAS,KAAK,KACvB,IAAI,KAAK,SAAS,MAAM,GAAG;AAC3B,YAAM,IAAI,UAAU,sCAAsC;AAAA,IAC9D;AACA,QAAI,CAAC,SAAS,QAAQ;AAClB,YAAM,IAAI,UAAU,mCAAmC;AAAA,IAC3D;AAAA,EACJ;AAAC;AC5NqB,YAAYkB,QAAE,UAAUA,QAAE,WAAWA,QAAE,YAAYA,QAAE,aAAa,CAAC,KAAK,UAAU,CAAA,MAAO;AAC3GA,UAAE,WAAW,KAAK,OAAO;AACzB,cAAY,GAAG;AACnB,CAAC;AACD,MAAM,cAAc,CAAC,QAAQ;AACzB,QAAM,SAAS,IAAI;AACnB,MAAI,CAAC,IAAI,YAAY;AACjB,QAAI,aAAa,oBAAI,IAAG;AAAA,EAC5B;AACA,MAAI,SACA,SACI,CAAC,MAAM,SAAS,OAAO,MAAM,IAAI,KAC7B;AAAA,IAEE,IAAI,YAAY,IAAI,IAAI,KAAK,KAAK,SAAS,MACxC,KAAK,SAAS,MAGrB,CAAC,MAAM,SAAS;AAAA,IAEhB,IAAI,YAAY,IAAI,IAAI,KAAK,KAAK,SAAS,MACxC,KAAK,SAAS;AAG/B;ACAA,MAAM,sCAAsB,IAAA;AAC5B,IAAI,4BAA4B;AAMhC,SAAS,0BAA0B;AACjC,MAAI,0BAA2B;AAC/B,8BAA4B;AAE5B,QAAM,UAAU,YAAY;AAC1B,QAAI,gBAAgB,SAAS,EAAG;AAEhC,UAAM,OAAO,MAAM,KAAK,eAAe;AACvC,UAAM,QAAQ;AAAA,MACZ,KAAK,IAAI,OAAO,QAAQ;AACtB,YAAI;AACF,gBAAM,GAAG,KAAK,EAAE,WAAW,MAAM,OAAO,MAAM;AAC9C,0BAAgB,OAAO,GAAG;AAAA,QAC5B,SAAS,QAAQ;AAAA,QAEjB;AAAA,MACF,CAAC;AAAA,IAAA;AAAA,EAEL;AAGA,UAAQ,GAAG,QAAQ,MAAM;AAAA,EAGzB,CAAC;AAGD,UAAQ,GAAG,UAAU,YAAY;AAC/B,UAAM,QAAA;AACN,YAAQ,KAAK,GAAG;AAAA,EAClB,CAAC;AAED,UAAQ,GAAG,WAAW,YAAY;AAChC,UAAM,QAAA;AACN,YAAQ,KAAK,GAAG;AAAA,EAClB,CAAC;AAGD,UAAQ,GAAG,qBAAqB,OAAO,UAAU;AAC/C,UAAM,QAAA;AACN,UAAM;AAAA,EACR,CAAC;AACH;AAkBA,SAAS,YAAY,KAAsB;AACzC,MAAI;AACJ,MAAI;AACJ,MAAI;AACJ,MAAI,MAAM;AACV,MAAI;AAGJ,MAAI,IAAI,WAAW,SAAS,GAAG;AAC7B,WAAO;AACP,UAAM,QAAQ,IAAI,MAAM,CAAC,EAAE,MAAM,GAAG;AACpC,WAAO,MAAM,CAAC;AAGd,UAAM,aAAa,MAAM,CAAC,GAAG,MAAM,GAAG,KAAK,CAAC,IAAI,EAAE;AAClD,WAAO,WAAW,CAAC;AACnB,QAAI,WAAW,CAAC,EAAG,OAAM,WAAW,CAAC;AAGrC,QAAI,MAAM,SAAS,GAAG;AACpB,eAAS,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG;AAAA,IAClC;AAAA,EACF,WAAW,IAAI,WAAW,SAAS,GAAG;AACpC,WAAO;AACP,UAAM,QAAQ,IAAI,MAAM,CAAC,EAAE,MAAM,GAAG;AACpC,WAAO,MAAM,CAAC;AAEd,UAAM,aAAa,MAAM,CAAC,GAAG,MAAM,GAAG,KAAK,CAAC,IAAI,EAAE;AAClD,WAAO,WAAW,CAAC;AACnB,QAAI,WAAW,CAAC,EAAG,OAAM,WAAW,CAAC;AAErC,QAAI,MAAM,SAAS,GAAG;AACpB,eAAS,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG;AAAA,IAClC;AAAA,EACF,WAAW,IAAI,WAAW,YAAY,GAAG;AACvC,WAAO;AACP,UAAM,QAAQ,IAAI,MAAM,EAAE,EAAE,MAAM,GAAG;AACrC,WAAO,MAAM,CAAC;AAEd,UAAM,aAAa,MAAM,CAAC,GAAG,MAAM,GAAG,KAAK,CAAC,IAAI,EAAE;AAClD,WAAO,WAAW,CAAC;AACnB,QAAI,WAAW,CAAC,EAAG,OAAM,WAAW,CAAC;AAErC,QAAI,MAAM,SAAS,GAAG;AACpB,eAAS,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG;AAAA,IAClC;AAAA,EACF,WAES,IAAI,SAAS,YAAY,GAAG;AACnC,WAAO;AACP,UAAM,QAAQ,IAAI,MAAM,kCAAkC;AAC1D,QAAI,CAAC,MAAO,OAAM,IAAI,MAAM,uBAAuB,GAAG,EAAE;AACxD,WAAO,MAAM,CAAC;AACd,WAAO,MAAM,CAAC,EAAE,QAAQ,UAAU,EAAE;AAGpC,UAAM,WAAW,IAAI,MAAM,QAAQ;AACnC,QAAI,UAAU;AACZ,YAAM,WAAW,SAAS,CAAC,EAAE,MAAM,GAAG;AACtC,YAAM,SAAS,CAAC;AAChB,UAAI,SAAS,CAAC,EAAG,UAAS,SAAS,CAAC;AAAA,IACtC;AAAA,EACF,WAAW,IAAI,SAAS,YAAY,GAAG;AACrC,WAAO;AACP,UAAM,QAAQ,IAAI,MAAM,kCAAkC;AAC1D,QAAI,CAAC,MAAO,OAAM,IAAI,MAAM,uBAAuB,GAAG,EAAE;AACxD,WAAO,MAAM,CAAC;AACd,WAAO,MAAM,CAAC,EAAE,QAAQ,UAAU,EAAE;AAEpC,UAAM,WAAW,IAAI,MAAM,QAAQ;AACnC,QAAI,UAAU;AACZ,YAAM,WAAW,SAAS,CAAC,EAAE,MAAM,GAAG;AACtC,YAAM,SAAS,CAAC;AAChB,UAAI,SAAS,CAAC,EAAG,UAAS,SAAS,CAAC;AAAA,IACtC;AAAA,EACF,WAAW,IAAI,SAAS,eAAe,GAAG;AACxC,WAAO;AACP,UAAM,QAAQ,IAAI,MAAM,qCAAqC;AAC7D,QAAI,CAAC,MAAO,OAAM,IAAI,MAAM,0BAA0B,GAAG,EAAE;AAC3D,WAAO,MAAM,CAAC;AACd,WAAO,MAAM,CAAC,EAAE,QAAQ,UAAU,EAAE;AAEpC,UAAM,WAAW,IAAI,MAAM,QAAQ;AACnC,QAAI,UAAU;AACZ,YAAM,WAAW,SAAS,CAAC,EAAE,MAAM,GAAG;AACtC,YAAM,SAAS,CAAC;AAChB,UAAI,SAAS,CAAC,EAAG,UAAS,SAAS,CAAC;AAAA,IACtC;AAAA,EACF,OAAO;AACL,UAAM,IAAI,MAAM,wBAAwB,GAAG,EAAE;AAAA,EAC/C;AAEA,SAAO,EAAE,MAAM,MAAM,MAAM,KAAK,OAAA;AAClC;AAKA,SAAS,cAAc,MAAuB;AAC5C,UAAQ,KAAK,MAAA;AAAA,IACX,KAAK;AACH,aAAO,sBAAsB,KAAK,IAAI,IAAI,KAAK,IAAI,YAAY,KAAK,GAAG;AAAA,IACzE,KAAK;AACH,aAAO,sBAAsB,KAAK,IAAI,IAAI,KAAK,IAAI,cAAc,KAAK,GAAG,IAAI,KAAK,IAAI,IAAI,KAAK,GAAG;AAAA,IACpG,KAAK;AACH,aAAO,yBAAyB,KAAK,IAAI,IAAI,KAAK,IAAI,QAAQ,KAAK,GAAG;AAAA,IACxE;AACE,YAAM,IAAI,MAAM,yBAAyB,KAAK,IAAI,EAAE;AAAA,EAAA;AAE1D;AAMA,SAAS,oBAAoB,aAA2B;AACtD,MAAI;AACF,UAAM,MAAM,IAAI,IAAI,WAAW;AAG/B,QAAI,IAAI,aAAa,UAAU;AAC7B,YAAM,IAAI;AAAA,QACR,8BAA8B,IAAI,QAAQ;AAAA,MAAA;AAAA,IAE9C;AAGA,UAAM,eAAe;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA;AAGF,QAAI,CAAC,aAAa,SAAS,IAAI,QAAQ,GAAG;AACxC,YAAM,IAAI,MAAM,+BAA+B,IAAI,QAAQ,EAAE;AAAA,IAC/D;AAGA,QACE,IAAI,aAAa,eACjB,IAAI,aAAa,eACjB,IAAI,SAAS,WAAW,UAAU,KAClC,IAAI,SAAS,WAAW,KAAK,KAC7B,IAAI,SAAS,WAAW,MAAM,GAC9B;AACA,YAAM,IAAI;AAAA,QACR,mDAAmD,IAAI,QAAQ;AAAA,MAAA;AAAA,IAEnE;AAAA,EACF,SAAS,OAAO;AACd,QAAI,iBAAiB,WAAW;AAC9B,YAAM,IAAI,MAAM,gCAAgC,WAAW,EAAE;AAAA,IAC/D;AACA,UAAM;AAAA,EACR;AACF;AAKA,eAAe,gBAAgB,KAAa,MAA+B;AACzE,QAAM,kBAAkB;AACxB,QAAM,mBAAmB,MAAM,OAAO;AAEtC,SAAO,IAAI,QAAQ,CAAChD,UAAS,WAAW;AACtC,QAAI,WAAW;AACf,QAAI,gBAAgB;AAEpB,UAAM,MAAM,MAAM,IAAI,KAAK,CAAC,aAAa;AAEvC,UAAI,SAAS,eAAe,OAAO,SAAS,eAAe,KAAK;AAC9D,cAAM,cAAc,SAAS,QAAQ;AACrC,YAAI,CAAC,aAAa;AAChB,iBAAO,OAAO,IAAI,MAAM,kCAAkC,CAAC;AAAA,QAC7D;AAGA,YAAI;AACF,8BAAoB,WAAW;AAAA,QACjC,SAAS,OAAO;AACd,iBAAO,OAAO,KAAK;AAAA,QACrB;AAEA,eAAO,gBAAgB,aAAa,IAAI,EAAE,KAAKA,UAAS,MAAM;AAAA,MAChE;AAEA,UAAI,SAAS,eAAe,KAAK;AAC/B,eAAO;AAAA,UACL,IAAI,MAAM,oCAAoC,SAAS,UAAU,EAAE;AAAA,QAAA;AAAA,MAEvE;AAGA,eAAS,GAAG,QAAQ,CAAC,UAAU;AAC7B,yBAAiB,MAAM;AACvB,YAAI,gBAAgB,kBAAkB;AACpC,mBAAS,QAAQ,IAAI,MAAM,4BAA4B,CAAC;AAAA,QAC1D;AAAA,MACF,CAAC;AAGD,YAAM,gBAAgB,QAAQ;AAAA,QAC5B,KAAK;AAAA,QACL,OAAO;AAAA;AAAA,MAAA,CACR;AAED,eAAS,KAAK,aAAa;AAE3B,oBAAc,GAAG,UAAU,MAAMA,SAAQ,IAAI,CAAC;AAC9C,oBAAc,GAAG,SAAS,CAAC,QAAQ;AACjC,iBAAS,QAAA;AACT,eAAO,GAAG;AAAA,MACZ,CAAC;AAAA,IACH,CAAC;AAED,QAAI,WAAW,iBAAiB,MAAM;AACpC,iBAAW;AACX,UAAI,QAAQ,IAAI,MAAM,mBAAmB,CAAC;AAAA,IAC5C,CAAC;AAED,QAAI,GAAG,SAAS,CAAC,QAAQ;AACvB,UAAI,UAAU;AACZ,eAAO,IAAI,MAAM,mBAAmB,CAAC;AAAA,MACvC,OAAO;AACL,eAAO,GAAG;AAAA,MACZ;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AAKA,eAAsB,gBAAgB,QAAyC;AAE7E,0BAAA;AAGA,QAAM,OAAO,YAAY,MAAM;AAG/B,QAAM,UAAU;AAAA,IACd,OAAA;AAAA,IACA,iBAAiB,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,KAAK;AAAA,EAAA;AAEvD,QAAMiD,QAAM,SAAS,EAAE,WAAW,MAAM;AAGxC,kBAAgB,IAAI,OAAO;AAE3B,MAAI;AAEF,UAAM,aAAa,cAAc,IAAI;AACrC,YAAQ;AAAA,MACN,6BAA6B,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI;AAAA,IAAA;AAElE,UAAM,gBAAgB,YAAY,OAAO;AAGzC,UAAM,cAAc,KAAK,SAAS,KAAK,SAAS,KAAK,MAAM,IAAI;AAC/D,UAAM,aAAa,KAAK,aAAa,oBAAoB;AAGzD,QAAI;AACF,YAAM,YAAY,cAAc,UAAU,EAAE;AAC5C,YAAMC,UAAS,MAAM,OAAO;AAC5B,YAAM,SAASA,QAAO,WAAWA;AAGjCC,+BAAuB,QAAQ,UAAU;AAGxC,aAAe,YAAY;AAE5B,aAAO;AAAA,IACT,SAAS,QAAQ;AAEf,UAAI;AACF,cAAM,eAAe,KAAK,aAAa,oBAAoB;AAC3D,cAAM,YAAY,cAAc,YAAY,EAAE;AAC9C,cAAMD,UAAS,MAAM,OAAO;AAC5B,cAAM,SAASA,QAAO,WAAWA;AAEjCC,iCAAuB,QAAQ,YAAY;AAC1C,eAAe,YAAY;AAE5B,eAAO;AAAA,MACT,QAAQ;AACN,cAAM,IAAI;AAAA,UACR,wDAAwD,MAAM;AAAA,QAAA;AAAA,MAElE;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AAEd,UAAM,GAAG,SAAS,EAAE,WAAW,MAAM,OAAO,MAAM;AAClD,UAAM;AAAA,EACR;AACF;AAgBA,eAAsB,mBACpB,QACe;AACf,QAAM,UAAW,OAAe;AAChC,MAAI,SAAS;AACX,UAAM,GAAG,SAAS,EAAE,WAAW,MAAM,OAAO,MAAM;AAAA,EACpD;AACF;AAKA,SAASA,yBAAuB,QAAa,QAAsB;AACjE,QAAM,WAAW,CAAC,QAAQ,eAAe,cAAc;AAEvD,aAAW,SAAS,UAAU;AAC5B,QAAI,CAAC,OAAO,KAAK,GAAG;AAClB,YAAM,IAAI;AAAA,QACR,8BAA8B,MAAM,6BAA6B,KAAK;AAAA,MAAA;AAAA,IAE1E;AAAA,EACF;AAEA,MAAI,OAAO,OAAO,iBAAiB,UAAU;AAC3C,UAAM,IAAI;AAAA,MACR,8BAA8B,MAAM;AAAA,IAAA;AAAA,EAExC;AAEA,MAAI,OAAO,mBAAmB,OAAO,OAAO,oBAAoB,UAAU;AACxE,UAAM,IAAI;AAAA,MACR,8BAA8B,MAAM;AAAA,IAAA;AAAA,EAExC;AACF;AC9aA,SAAS,oBAAoB,MAAsB;AACjD,MAAI,KAAK,WAAW,IAAI,GAAG;AACzB,WAAO,KAAK,QAAA,GAAW,KAAK,MAAM,CAAC,CAAC;AAAA,EACtC;AACA,MAAI,KAAK,WAAW,GAAG,GAAG;AACxB,WAAO,KAAK,QAAA,GAAW,KAAK,MAAM,CAAC,CAAC;AAAA,EACtC;AACA,SAAO;AACT;AAOA,SAAS,qBACP,cACA,cACM;AACN,QAAM,OAAO,QAAA;AAGb,MAAI,aAAa,SAAS,IAAI,KAAK,aAAa,SAAS,IAAI,GAAG;AAC9D,UAAM,IAAI;AAAA,MACR;AAAA,IAAA;AAAA,EAEJ;AAIA,MAAI,aAAa,WAAW,GAAG,GAAG;AAChC,UAAMC,kBAAiB,QAAQ,YAAY;AAC3C,UAAM,iBAAiB,QAAQ,IAAI;AAEnC,QAAI,CAACA,gBAAe,WAAW,cAAc,GAAG;AAC9C,YAAM,IAAI;AAAA,QACR,2CAA2CA,eAAc,6BAA6B,cAAc;AAAA,MAAA;AAAA,IAExG;AAAA,EACF;AAIA,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEF,QAAM,iBAAiB,QAAQ,YAAY;AAE3C,aAAW,iBAAiB,gBAAgB;AAC1C,QACE,mBAAmB,iBACnB,eAAe,WAAW,GAAG,aAAa,GAAG,GAC7C;AACA,YAAM,IAAI;AAAA,QACR,qDAAqD,aAAa;AAAA,MAAA;AAAA,IAEtE;AAAA,EACF;AAGA,MACE,eAAe,WAAW,OAAO,KACjC,eAAe,WAAW,QAAQ,KAClC,eAAe,WAAW,WAAW,KACrC,eAAe,WAAW,YAAY,GACtC;AACA,UAAM,IAAI,MAAM,iDAAiD;AAAA,EACnE;AACF;AAYA,eAAsB,iBAAiB,WAAoC;AACzE,MAAI;AAGJ,MAAI,UAAU,WAAW,GAAG,GAAG;AAC7B,mBAAe,oBAAoB,SAAS;AAAA,EAC9C,WAAW,UAAU,WAAW,GAAG,GAAG;AAEpC,mBAAe;AAAA,EACjB,OAAO;AAEL,mBAAe,QAAQ,QAAQ,IAAA,GAAO,SAAS;AAAA,EACjD;AAGA,uBAAqB,cAAc,SAAS;AAG5C,MAAI;AACF,UAAM,OAAO,YAAY;AAAA,EAC3B,QAAQ;AACN,UAAM,IAAI,MAAM,uCAAuC,YAAY,EAAE;AAAA,EACvE;AAEA,SAAO;AACT;AAKA,eAAsB,kBACpB,cACyB;AAEzB,MAAI,aAA4B;AAEhC,aAAW,OAAO,CAAC,MAAM,IAAI,GAAG;AAC9B,UAAM,WAAW,KAAK,cAAc,mBAAmB,GAAG,EAAE;AAC5D,QAAI;AACF,YAAM,OAAO,QAAQ;AACrB,mBAAa;AACb;AAAA,IACF,QAAQ;AAAA,IAER;AAAA,EACF;AAEA,MAAI,CAAC,YAAY;AACf,UAAM,IAAI;AAAA,MACR,wDAAwD,YAAY;AAAA,IAAA;AAAA,EAExE;AAGA,MAAI;AACF,UAAM,YAAY,cAAc,UAAU,EAAE;AAC5C,UAAMF,UAAS,MAAM,OAAO;AAC5B,UAAM,SAASA,QAAO,WAAWA;AAGjCC,6BAAuB,QAAQ,UAAU;AAEzC,WAAO;AAAA,EACT,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,uCAAuC,UAAU,KAAK,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,IAAA;AAAA,EAElH;AACF;AAKA,SAASA,yBAAuB,QAAa,QAAsB;AACjE,QAAM,WAAW,CAAC,QAAQ,eAAe,cAAc;AAEvD,aAAW,SAAS,UAAU;AAC5B,QAAI,CAAC,OAAO,KAAK,GAAG;AAClB,YAAM,IAAI;AAAA,QACR,8BAA8B,MAAM,6BAA6B,KAAK;AAAA,MAAA;AAAA,IAE1E;AAAA,EACF;AAEA,MAAI,OAAO,OAAO,iBAAiB,UAAU;AAC3C,UAAM,IAAI;AAAA,MACR,8BAA8B,MAAM;AAAA,IAAA;AAAA,EAExC;AAEA,MAAI,OAAO,mBAAmB,OAAO,OAAO,oBAAoB,UAAU;AACxE,UAAM,IAAI;AAAA,MACR,8BAA8B,MAAM;AAAA,IAAA;AAAA,EAExC;AACF;ACjLA,eAAsB,kBAAkB,aAAsC;AAE5E,MAAI;AACF,UAAM,WAAW,QAAQ,QAAQ,aAAa;AAAA,MAC5C,OAAO,CAAC,QAAQ,OAAO,GAAG,OAAO,KAAK;AAAA,IAAA,CACvC;AACD,WAAO;AAAA,EACT,QAAQ;AAEN,UAAM,kBAAkB,KAAK,QAAQ,IAAA,GAAO,gBAAgB,WAAW;AACvE,QAAI;AACF,YAAM,OAAO,eAAe;AAC5B,aAAO;AAAA,IACT,QAAQ;AACN,YAAM,IAAI;AAAA,QACR,gBAAgB,WAAW,0CAA0C,YAAY,MAAM,GAAG,EAAE,CAAC,CAAC;AAAA,MAAA;AAAA,IAElG;AAAA,EACF;AACF;AAKA,eAAsB,gBACpB,cACyB;AACzB,MAAI;AAGJ,MACE,aAAa,SAAS,oBAAoB,KAC1C,aAAa,SAAS,oBAAoB,GAC1C;AACA,iBAAa;AAAA,EACf,OAAO;AAEL,UAAM,MAAM,aAAa,SAAS,KAAK,IACnCE,UAAQ,YAAY,IACpB;AAEJ,QAAI;AACF,mBAAa,KAAK,KAAK,oBAAoB;AAC3C,YAAM,OAAO,UAAU;AAAA,IACzB,QAAQ;AACN,UAAI;AACF,qBAAa,KAAK,KAAK,oBAAoB;AAC3C,cAAM,OAAO,UAAU;AAAA,MACzB,QAAQ;AACN,cAAM,IAAI;AAAA,UACR,wDAAwD,GAAG;AAAA,QAAA;AAAA,MAE/D;AAAA,IACF;AAAA,EACF;AAGA,MAAI;AACF,UAAM,YAAY,cAAc,UAAU,EAAE;AAC5C,UAAMH,UAAS,MAAM,OAAO;AAC5B,UAAM,SAASA,QAAO,WAAWA;AAGjC,2BAAuB,QAAQ,UAAU;AAEzC,WAAO;AAAA,EACT,SAAS,OAAO;AACd,UAAM,IAAI;AAAA,MACR,uCAAuC,UAAU,KAAK,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,IAAA;AAAA,EAElH;AACF;AAUA,eAAsB,uBACpB,WACwB;AACxB,QAAM,kBAAkB,KAAK,QAAQ,IAAA,GAAO,cAAc;AAG1D,QAAM,WAAW;AAAA;AAAA,IAEf,GAAG,eAAe,iBAAiB,SAAS;AAAA;AAAA,IAE5C,GAAG,eAAe,OAAO,SAAS;AAAA;AAAA,IAElC,GAAG,eAAe,IAAI,SAAS;AAAA;AAAA,IAE/B,GAAG,eAAe,gBAAgB,SAAS;AAAA,EAAA;AAG7C,aAAW,WAAW,UAAU;AAC9B,UAAM,UAAU,MAAM,KAAK,SAAS,EAAE,UAAU,MAAM;AACtD,QAAI,QAAQ,SAAS,GAAG;AAEtB,YAAM,aAAa,QAAQ,CAAC;AAC5B,aAAOG,UAAQ,UAAU;AAAA,IAC3B;AAAA,EACF;AAEA,SAAO;AACT;AAOA,eAAsB,6BAEpB;AACA,QAAM,kBAAkB,KAAK,QAAQ,IAAA,GAAO,cAAc;AAE1D,QAAM,WAAW;AAAA,IACf,GAAG,eAAe;AAAA,IAClB,GAAG,eAAe;AAAA,EAAA;AAGpB,QAAM,YAID,CAAA;AAEL,aAAW,WAAW,UAAU;AAC9B,UAAM,UAAU,MAAM,KAAK,SAAS,EAAE,UAAU,MAAM;AAEtD,eAAW,cAAc,SAAS;AAChC,UAAI;AACF,cAAM,YAAY,cAAc,UAAU,EAAE;AAC5C,cAAMH,UAAS,MAAM,OAAO;AAC5B,cAAM,SAASA,QAAO,WAAWA;AAGjC,cAAM,eAAe,WAAW,QAAQ,kBAAkB,KAAK,EAAE;AACjE,cAAM,SAAS,aAAa;AAAA,UAC1B;AAAA,UACA,aAAa,QAAQ,kBAAkB;AAAA,QAAA;AAGzC,kBAAU,KAAK;AAAA,UACb,MAAM,OAAO,QAAQ;AAAA,UACrB;AAAA,UACA;AAAA,QAAA,CACD;AAAA,MACH,SAAS,OAAO;AAEd,gBAAQ,KAAK,8BAA8B,UAAU,KAAK,KAAK;AAAA,MACjE;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAKA,SAAS,uBAAuB,QAAa,QAAsB;AACjE,QAAM,WAAW,CAAC,QAAQ,eAAe,cAAc;AAEvD,aAAW,SAAS,UAAU;AAC5B,QAAI,CAAC,OAAO,KAAK,GAAG;AAClB,YAAM,IAAI;AAAA,QACR,8BAA8B,MAAM,6BAA6B,KAAK;AAAA,MAAA;AAAA,IAE1E;AAAA,EACF;AAEA,MAAI,OAAO,OAAO,iBAAiB,UAAU;AAC3C,UAAM,IAAI;AAAA,MACR,8BAA8B,MAAM;AAAA,IAAA;AAAA,EAExC;AAEA,MAAI,OAAO,mBAAmB,OAAO,OAAO,oBAAoB,UAAU;AACxE,UAAM,IAAI;AAAA,MACR,8BAA8B,MAAM;AAAA,IAAA;AAAA,EAExC;AACF;AChKA,eAAsB,gBAAgBR,OAAuC;AAE3E,MACEA,MAAK,WAAW,SAAS,KACzBA,MAAK,WAAW,SAAS,KACzBA,MAAK,WAAW,MAAM,KACtBA,MAAK,SAAS,MAAM,KACpBA,MAAK,WAAW,oBAAoB,KACpCA,MAAK,WAAW,oBAAoB,GACpC;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAUA;AAAA,MACV,UAAUA;AAAA,IAAA;AAAA,EAEd;AAGA,MAAIA,MAAK,WAAW,GAAG,KAAKA,MAAK,WAAW,GAAG,KAAKA,MAAK,WAAW,GAAG,GAAG;AACxE,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAUA;AAAA,MACV,UAAU,MAAM,iBAAiBA,KAAI;AAAA,IAAA;AAAA,EAEzC;AAGA,MAAIA,MAAK,SAAS,GAAG,KAAKA,MAAK,SAAS,GAAG,GAAG;AAC5C,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAUA;AAAA,MACV,UAAU,MAAM,kBAAkBA,KAAI;AAAA,IAAA;AAAA,EAE1C;AAGA,QAAM,UAAU,MAAM,uBAAuBA,KAAI;AACjD,MAAI,SAAS;AACX,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAU,MAAM,kBAAkB,OAAO;AAAA,IAAA;AAAA,EAE7C;AAEA,QAAM,IAAI;AAAA,IACR,aAAaA,KAAI;AAAA,sBACQA,KAAI,kBAAkBA,KAAI;AAAA,oBAC5BA,KAAI,QAAQA,KAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA;AAO3C;AAKA,eAAsB,aACpB,QACyB;AACzB,UAAQ,OAAO,MAAA;AAAA,IACb,KAAK;AACH,aAAO,gBAAgB,OAAO,QAAQ;AAAA,IACxC,KAAK;AACH,aAAO,gBAAgB,OAAO,QAAQ;AAAA,IACxC,KAAK;AACH,aAAO,kBAAkB,OAAO,QAAQ;AAAA,IAC1C;AACE,YAAM,IAAI,MAAM,0BAA0B,OAAO,IAAI,EAAE;AAAA,EAAA;AAE7D;ACjGA,eAAsB,SACpB,QACA,QACA,SACe;AACf,UAAQ,IAAI;AAAA,uBAA0B,QAAQ,IAAI,EAAE;AACpD,UAAQ,IAAI,sBAAsB,OAAO,IAAI,KAAK,OAAO,WAAW;AAAA,CAAK;AAGzE,MAAI,OAAO,eAAe;AACxB,YAAQ,IAAI,8BAA8B,OAAO,SAAS,MAAM;AAChE,UAAM,iBAAiB,OAAO,eAAe,QAAQ,SAAS;AAAA,EAChE,OAAO;AAEL,UAAMO,QAAM,QAAQ,WAAW,EAAE,WAAW,MAAM;AAAA,EACpD;AAGA,UAAQ,IAAI,8BAA8B;AAC1C,QAAM,gBAAgB,QAAQ,QAAQ,QAAQ,SAAS;AAGvD,UAAQ,IAAI,gCAAgC;AAC5C,QAAM,iBAAiB,QAAQ,WAAW,QAAQ,QAAQ,IAAI;AAE9D,UAAQ,IAAI,iCAAiC;AAC7C,UAAQ,IAAI;AAAA,eAAkB;AAC9B,UAAQ,IAAI,SAAS,QAAQ,IAAI,EAAE;AACnC,UAAQ,IAAI,iBAAiB;AAC7B,UAAQ,IAAI;AAAA,CAAe;AAC7B;AAKA,SAAS,sBACP,SACA,WACM;AAEN,QAAM,kBAAkB,CAAC,OAAO,OAAO,QAAQ,QAAQ,OAAO,MAAM;AAEpE,MAAI,CAAC,gBAAgB,SAAS,QAAQ,OAAO,GAAG;AAC9C,UAAM,IAAI;AAAA,MACR,2BAA2B,QAAQ,OAAO,oCACnB,gBAAgB,KAAK,IAAI,CAAC;AAAA,IAAA;AAAA,EAErD;AAGA,QAAM,iBAAiB;AACvB,MAAI,eAAe,KAAK,SAAS,GAAG;AAClC,UAAM,IAAI;AAAA,MACR,mDAAmD,SAAS;AAAA,IAAA;AAAA,EAGhE;AAGA,aAAW,OAAO,QAAQ,MAAM;AAE9B,UAAM,cAAc,IAAI,QAAQ,SAAS,SAAS;AAGlD,QAAI,eAAe,KAAK,WAAW,GAAG;AACpC,YAAM,IAAI;AAAA,QACR,wFAAwF,WAAW;AAAA,MAAA;AAAA,IAEvG;AAAA,EACF;AACF;AAQA,eAAe,iBACb,SACA,WACe;AAEf,wBAAsB,SAAS,SAAS;AAGxC,QAAM,OAAO,QAAQ,KAAK,IAAI,CAAC,QAAQ,IAAI,QAAQ,SAAS,SAAS,CAAC;AAEtE,SAAO,IAAI,QAAQ,CAACjD,UAAS,WAAW;AAEtC,UAAMsD,QAAO,MAAM,QAAQ,SAAS,MAAM;AAAA,MACxC,OAAO;AAAA,MACP,OAAO;AAAA,IAAA,CACR;AAED,IAAAA,MAAK,GAAG,SAAS,CAACxC,UAAS;AACzB,UAAIA,UAAS,GAAG;AACd,QAAAd,SAAA;AAAA,MACF,OAAO;AACL,eAAO,IAAI,MAAM,mCAAmCc,KAAI,EAAE,CAAC;AAAA,MAC7D;AAAA,IACF,CAAC;AAED,IAAAwC,MAAK,GAAG,SAAS,MAAM;AAAA,EACzB,CAAC;AACH;AAKA,eAAe,gBACb,QACA,QACA,WACe;AAEf,MAAI;AAEJ,UAAQ,OAAO,MAAA;AAAA,IACb,KAAK;AACH,mBAAa,KAAKD,UAAQ,OAAO,QAAQ,GAAG,SAAS;AACrD;AAAA,IACF,KAAK,OAAO;AAEV,YAAM,UAAW,OAAe;AAChC,UAAI,CAAC,SAAS;AACZ,cAAM,IAAI,MAAM,uCAAuC;AAAA,MACzD;AACA,mBAAa,KAAK,SAAS,SAAS;AACpC;AAAA,IACF;AAAA,IACA,KAAK;AACH,mBAAa,KAAK,OAAO,UAAU,SAAS;AAC5C;AAAA,IACF;AACE,YAAM,IAAI,MAAM,wBAAwB,OAAO,IAAI,EAAE;AAAA,EAAA;AAIzD,QAAM,QAAQ,MAAM,KAAK,QAAQ;AAAA,IAC/B,KAAK;AAAA,IACL,KAAK;AAAA,IACL,WAAW;AAAA,EAAA,CACZ;AAGD,aAAW,QAAQ,OAAO;AACxB,UAAM,MAAM,KAAK,YAAY,IAAI;AACjC,UAAM,OAAO,KAAK,WAAW,IAAI;AAGjC,UAAMJ,QAAMI,UAAQ,IAAI,GAAG,EAAE,WAAW,MAAM;AAG9C,UAAM,GAAG,KAAK,IAAI;AAAA,EACpB;AACF;AAKA,eAAe,iBACb,WACA,QACA,aACe;AACf,QAAM,UAAU,KAAK,WAAW,cAAc;AAE9C,MAAI;AACJ,MAAI;AACF,UAAM,UAAU,MAAM,SAAS,SAAS,OAAO;AAC/C,UAAM,KAAK,MAAM,OAAO;AAAA,EAC1B,QAAQ;AAEN,UAAM;AAAA,MACJ,MAAM;AAAA,MACN,SAAS;AAAA,MACT,SAAS;AAAA,MACT,SAAS,CAAA;AAAA,MACT,cAAc,CAAA;AAAA,MACd,iBAAiB,CAAA;AAAA,IAAC;AAAA,EAEtB;AAGA,MAAI,OAAO;AAGX,MAAI,eAAe;AAAA,IACjB,GAAG,IAAI;AAAA,IACP,GAAG,OAAO;AAAA,EAAA;AAGZ,MAAI,kBAAkB;AAAA,IACpB,GAAG,IAAI;AAAA,IACP,GAAG,OAAO;AAAA,EAAA;AAIZ,MAAI,CAAC,IAAI,QAAQ,mBAAmB,GAAG;AACrC,QAAI,UAAU;AAAA,MACZ,GAAG,IAAI;AAAA,MACP,qBAAqB;AAAA,MACrB,mBAAmB;AAAA,IAAA;AAAA,EAEvB;AAGA,QAAM,UAAU,SAAS,KAAK,UAAU,KAAK,MAAM,CAAC,IAAI,IAAI;AAC9D;ACvNO,MAAM,gBAA4C;AAAA,EACvD,gBAAgB;AAAA,IACd,MAAM;AAAA,IACN,aAAa;AAAA,IACb,MAAM,CAAC,MAAM;AAAA,IACb,SAAS;AAAA,MACP,UAAU;AAAA,QACR,MAAM;AAAA,QACN,aAAa;AAAA,QACb,SAAS;AAAA,MAAA;AAAA,MAEX,cAAc;AAAA,QACZ,MAAM;AAAA,QACN,aAAa;AAAA,MAAA;AAAA,IACf;AAAA,IAEF,SAAS,OAAO,MAAgB,YAAiB;AAC/C,YAAMX,QAAO,KAAK,CAAC;AACnB,UAAI,CAACA,OAAM;AACT,cAAM,IAAI,MAAM,oDAAoD;AAAA,MACtE;AAEA,YAAM,YAAY,QAAQ,aAAa,KAAKA,KAAI;AAChD,YAAM,eAAe,QAAQ,YAAY;AAEzC,UAAI;AAEF,gBAAQ,IAAI,0BAA0B,YAAY,KAAK;AACvD,cAAM,SAAS,MAAM,gBAAgB,YAAY;AACjD,gBAAQ,IAAI,qBAAqB,OAAO,IAAI,IAAI,OAAO,QAAQ;AAAA,CAAI;AAGnE,cAAM,SAAS,MAAM,aAAa,MAAM;AAGxC,cAAM,SAAS,QAAQ,QAAQ;AAAA,UAC7B,MAAAA;AAAA,UACA,UAAU;AAAA,UACV;AAAA,QAAA,CACD;AAGD,YAAI,OAAO,SAAS,OAAO;AACzB,gBAAM,mBAAmB,MAAM;AAAA,QACjC;AAAA,MACF,SAAS,OAAO;AACd,cAAM,IAAI;AAAA,UACR,2BAA2B,iBAAiB,QAAQ,MAAM,UAAU,eAAe;AAAA,UACnF,EAAE,OAAO,MAAA;AAAA,QAAM;AAAA,MAEnB;AAAA,IACF;AAAA,EAAA;AAAA,EAGF,wBAAwB;AAAA,IACtB,MAAM;AAAA,IACN,aAAa;AAAA,IACb,SAAS,CAAC,UAAU;AAAA,IACpB,SAAS,OAAO,OAAiB,aAAkB;AACjD,cAAQ,IAAI,yCAAyC;AAErD,YAAM,YAAY,MAAM,2BAAA;AAExB,UAAI,UAAU,WAAW,GAAG;AAC1B,gBAAQ,IAAI,qCAAqC;AACjD,gBAAQ;AAAA,UACN;AAAA,QAAA;AAEF,gBAAQ,IAAI,qCAAqC;AACjD,gBAAQ,IAAI,4BAA4B;AACxC,gBAAQ,IAAI,yDAAyD;AACrE;AAAA,MACF;AAEA,cAAQ,IAAI,wBAAwB;AAEpC,iBAAW,KAAK,WAAW;AACzB,gBAAQ,IAAI,KAAK,EAAE,IAAI,EAAE;AACzB,gBAAQ,IAAI,OAAO,EAAE,OAAO,WAAW,EAAE;AACzC,gBAAQ,IAAI,eAAe,EAAE,MAAM,EAAE;AACrC,gBAAQ,IAAI,kBAAkB,EAAE,OAAO,aAAa,SAAS,EAAE;AAC/D,gBAAQ,IAAA;AAAA,MACV;AAEA,cAAQ,IAAI,SAAS,UAAU,MAAM;AAAA,CAAgB;AACrD,cAAQ,IAAI,QAAQ;AACpB,cAAQ,IAAI,uDAAuD;AACnE,cAAQ,IAAI,kDAAkD;AAAA,IAChE;AAAA,EAAA;AAEJ;","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]}