{"version":3,"file":"postgres-B7IAgBFj.js","sources":["../../src/postgres.ts"],"sourcesContent":["import { DatabaseError } from '@have/utils';\nimport { Pool } from 'pg';\nimport type {\n  QueryResult as BaseQueryResult,\n  DatabaseInterface,\n  TableInterface,\n  SchemaInitializationOptions,\n} from './shared/types';\nimport { buildWhere } from './shared/utils';\nimport { DatabaseSchemaManager } from './schema-manager';\n\n/**\n * Configuration options for PostgreSQL database connections\n */\nexport interface PostgresOptions {\n  /**\n   * Connection URL for PostgreSQL\n   */\n  url?: string;\n\n  /**\n   * Database name\n   */\n  database?: string;\n\n  /**\n   * Database server hostname\n   */\n  host?: string;\n\n  /**\n   * Username for authentication\n   */\n  user?: string;\n\n  /**\n   * Password for authentication\n   */\n  password?: string;\n\n  /**\n   * Port number for the PostgreSQL server\n   */\n  port?: number;\n}\n\n/**\n * Creates a PostgreSQL database adapter\n *\n * @param options - PostgreSQL connection options\n * @returns Database interface for PostgreSQL\n */\nexport function getDatabase(options: PostgresOptions = {}): DatabaseInterface {\n  const {\n    url = process.env.SQLOO_URL,\n    database = process.env.SQLOO_DATABASE,\n    host = process.env.SQLOO_HOST || 'localhost',\n    user = process.env.SQLOO_USER,\n    password = process.env.SQLOO_PASSWORD,\n    port = Number(process.env.SQLOO_PORT) || 5432,\n  } = options;\n\n  // Create a connection pool\n  const client = new Pool(\n    url\n      ? { connectionString: url }\n      : {\n          host,\n          user,\n          password,\n          port,\n          database,\n        },\n  );\n\n  /**\n   * Inserts one or more records into a table\n   *\n   * @param table - Table name\n   * @param data - Single record or array of records to insert\n   * @returns Promise resolving to operation result\n   * @throws Error if the insert operation fails\n   *\n   * @example Single record insert:\n   * ```typescript\n   * await db.insert('users', {\n   *   name: 'John Doe',\n   *   email: 'john@example.com'\n   * });\n   * ```\n   *\n   * @example Multiple record insert:\n   * ```typescript\n   * await db.insert('users', [\n   *   { name: 'John', email: 'john@example.com' },\n   *   { name: 'Jane', email: 'jane@example.com' }\n   * ]);\n   * ```\n   */\n  const insert = async (\n    table: string,\n    data: Record<string, any> | Record<string, any>[],\n  ): Promise<BaseQueryResult> => {\n    // If data is an array, we need to handle multiple rows\n    if (Array.isArray(data)) {\n      const keys = Object.keys(data[0]);\n      const placeholders = data\n        .map(\n          (_, i) =>\n            `(${keys.map((_, j) => `$${i * keys.length + j + 1}`).join(', ')})`,\n        )\n        .join(', ');\n      const query = `INSERT INTO ${table} (${keys.join(\n        ', ',\n      )}) VALUES ${placeholders}`;\n      const values = data.reduce(\n        (acc, row) => acc.concat(Object.values(row)),\n        [],\n      );\n      const result = await client.query(query, values);\n      return { operation: 'insert', affected: result.rowCount ?? 0 };\n    }\n    // If data is an object, we handle a single row\n    const keys = Object.keys(data);\n    const values = Object.values(data);\n    const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ');\n    const query = `INSERT INTO ${table} (${keys.join(\n      ', ',\n    )}) VALUES (${placeholders})`;\n    const result = await client.query(query, values);\n    return { operation: 'insert', affected: result.rowCount ?? 0 };\n  };\n\n  /**\n   * Retrieves a single record matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to query result\n   */\n  const get = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any> | null> => {\n    const keys = Object.keys(where);\n    const values = Object.values(where);\n    const whereClause = keys\n      .map((key, i) => `${key} = $${i + 1}`)\n      .join(' AND ');\n    const query = `SELECT * FROM ${table} WHERE ${whereClause}`;\n    try {\n      const result = await client.query(query, values);\n      return result.rows[0] || null;\n    } catch (e) {\n      throw new DatabaseError('Failed to retrieve record from table', {\n        table,\n        sql: query,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Retrieves multiple records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records\n   * @returns Promise resolving to array of records\n   */\n  const list = async (\n    table: string,\n    where: Record<string, any>,\n  ): Promise<Record<string, any>[]> => {\n    const { sql: whereClause, values } = buildWhere(where, 1);\n    const query = `SELECT * FROM ${table} ${whereClause}`;\n    try {\n      const result = await client.query(query, values);\n      return result.rows;\n    } catch (e) {\n      throw new DatabaseError('Failed to list records from table', {\n        table,\n        sql: query,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Updates records matching the where criteria\n   *\n   * @param table - Table name\n   * @param where - Criteria to match records to update\n   * @param data - New data to set\n   * @returns Promise resolving to operation result\n   */\n  const update = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<BaseQueryResult> => {\n    const keys = Object.keys(data);\n    const values = Object.values(data);\n    const setClause = keys.map((key, i) => `${key} = $${i + 1}`).join(', ');\n    const whereKeys = Object.keys(where);\n    const whereValues = Object.values(where);\n    const whereClause = whereKeys\n      .map((key, i) => `${key} = $${i + 1 + values.length}`)\n      .join(' AND ');\n\n    const sql = `UPDATE ${table} SET ${setClause} WHERE ${whereClause}`;\n    try {\n      const result = await client.query(sql, [...values, ...whereValues]);\n      return { operation: 'update', affected: result.rowCount ?? 0 };\n    } catch (e) {\n      throw new DatabaseError('Failed to update records in table', {\n        table,\n        sql,\n        values: [...values, ...whereValues],\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Inserts a record or updates it if it already exists (UPSERT)\n   *\n   * @param table - Table name\n   * @param conflictColumns - Columns that define the uniqueness constraint\n   * @param data - Data to insert or update\n   * @returns Promise resolving to operation result\n   * @throws Error if the upsert operation fails\n   */\n  const upsert = async (\n    table: string,\n    conflictColumns: string[],\n    data: Record<string, any>,\n  ): Promise<BaseQueryResult> => {\n    const keys = Object.keys(data);\n    const values = Object.values(data);\n    const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ');\n    const updateSet = keys\n      .map((key, i) => `${key} = $${i + 1}`)\n      .join(', ');\n    const conflict = conflictColumns.join(', ');\n\n    const sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders}) ON CONFLICT(${conflict}) DO UPDATE SET ${updateSet}`;\n\n    try {\n      const result = await client.query(sql, values);\n      return { operation: 'upsert', affected: result.rowCount ?? 0 };\n    } catch (e) {\n      throw new DatabaseError('Failed to upsert record into table', {\n        table,\n        sql,\n        values,\n        conflictColumns,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Gets a record matching the where criteria or inserts it if not found\n   *\n   * @param table - Table name\n   * @param where - Criteria to match existing record\n   * @returns Promise resolving to the query result or insert result\n   */\n  const getOrInsert = async (\n    table: string,\n    where: Record<string, any>,\n    data: Record<string, any>,\n  ): Promise<Record<string, any>> => {\n    const result = await get(table, where);\n    if (result) return result;\n    await insert(table, data);\n\n    const inserted = await get(table, where);\n    if (!inserted) {\n      throw new DatabaseError('Failed to insert and retrieve record', {\n        table,\n        where,\n        data,\n      });\n    }\n    return inserted;\n  };\n\n  /**\n   * Creates a table-specific interface for simplified table operations\n   *\n   * @param tableName - Table name\n   * @returns TableMethods interface for the specified table\n   */\n  const table = (tableName: string): TableInterface => {\n    return {\n      insert: (data) => insert(tableName, data),\n      get: (data) => get(tableName, data),\n      list: (data) => list(tableName, data),\n    };\n  };\n\n  /**\n   * Template and values extracted from a tagged template literal\n   */\n  interface SqlTemplate {\n    /**\n     * SQL query with parameter placeholders\n     */\n    sql: string;\n\n    /**\n     * Values to use as parameters\n     */\n    values: any[];\n  }\n\n  /**\n   * Parses a tagged template literal into a SQL query and values\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Object with SQL query and values array\n   */\n  const parseTemplate = (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): SqlTemplate => {\n    let sql = strings[0];\n    const values = [];\n    for (let i = 0; i < vars.length; i++) {\n      values.push(vars[i]);\n      sql += `$${i + 1}${strings[i + 1]}`;\n    }\n    return { sql, values };\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single value\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single value (first column of first row)\n   */\n  const pluck = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<any> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const result = await client.query(sql, values);\n      const firstRow = result.rows[0];\n      if (!firstRow) return null;\n      // Return the first column value from the first row\n      return Object.values(firstRow)[0];\n    } catch (e) {\n      throw new DatabaseError('Failed to execute pluck query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns a single row\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to a single result record or null\n   */\n  const single = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any> | null> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const result = await client.query(sql, values);\n      return result.rows[0] || null;\n    } catch (e) {\n      throw new DatabaseError('Failed to execute single query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals and returns multiple rows\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise resolving to array of result records\n   */\n  const many = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<Record<string, any>[]> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      const result = await client.query(sql, values);\n      return result.rows;\n    } catch (e) {\n      throw new DatabaseError('Failed to execute many query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a SQL query using template literals without returning results\n   *\n   * @param strings - Template strings\n   * @param vars - Variables to interpolate into the query\n   * @returns Promise that resolves when the query completes\n   */\n  const execute = async (\n    strings: TemplateStringsArray,\n    ...vars: any[]\n  ): Promise<void> => {\n    const { sql, values } = parseTemplate(strings, ...vars);\n    try {\n      await client.query(sql, values);\n    } catch (e) {\n      throw new DatabaseError('Failed to execute query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Executes a raw SQL query with parameterized values\n   *\n   * @param sql - SQL query string\n   * @param values - Variables to use as parameters\n   * @returns Promise resolving to query result with rows and count\n   */\n  const query = async (\n    sql: string,\n    ...values: any[]\n  ): Promise<{ rows: Record<string, any>[]; rowCount: number }> => {\n    try {\n      const result = await client.query(sql, values);\n      return {\n        rows: result.rows,\n        rowCount: result.rowCount ?? 0,\n      };\n    } catch (e) {\n      throw new DatabaseError('Failed to execute raw query', {\n        sql,\n        values,\n        originalError: e instanceof Error ? e.message : String(e),\n      });\n    }\n  };\n\n  /**\n   * Checks if a table exists in the database\n   *\n   * @param tableName - Name of the table to check\n   * @returns Promise resolving to boolean indicating if the table exists\n   */\n  const tableExists = async (tableName: string): Promise<boolean> => {\n    const result = await client.query(\n      `SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = $1 AND table_schema = 'public')`,\n      [tableName],\n    );\n    return result.rows[0].exists;\n  };\n\n  /**\n   * Synchronizes database schema with provided SQL DDL\n   * Creates tables if they don't exist and adds missing columns\n   *\n   * @param schema - SQL schema definition with CREATE TABLE statements\n   * @returns Promise that resolves when schema is synchronized\n   */\n  const syncSchema = async (schema: string): Promise<void> => {\n    const commands = schema\n      .trim()\n      .split(';')\n      .filter((command) => command.trim() !== '');\n\n    for (const command of commands) {\n      const createTableRegex =\n        /CREATE TABLE (IF NOT EXISTS )?(\\w+) \\(([\\s\\S]+)\\)/i;\n      const match = command.match(createTableRegex);\n\n      if (match) {\n        const tableName = match[2];\n        const columns = match[3].trim().split(',\\n');\n\n        // Check if table exists\n        const exists = await tableExists(tableName);\n\n        if (!exists) {\n          // Table doesn't exist, create it\n          await client.query(command);\n        } else {\n          // Table exists, check for missing columns\n          for (const column of columns) {\n            const columnDef = column.trim();\n            const columnMatch = columnDef.match(/(\\w+)\\s+(\\w+[^,]*)/);\n\n            if (columnMatch) {\n              const columnName = columnMatch[1];\n\n              // Skip constraint definitions\n              if (\n                columnName.toUpperCase() === 'PRIMARY' ||\n                columnName.toUpperCase() === 'FOREIGN' ||\n                columnName.toUpperCase() === 'UNIQUE' ||\n                columnName.toUpperCase() === 'CHECK' ||\n                columnName.toUpperCase() === 'CONSTRAINT'\n              ) {\n                continue;\n              }\n\n              try {\n                // Check if column exists\n                const columnExists = await client.query(\n                  `SELECT EXISTS (\n                    SELECT 1 FROM information_schema.columns\n                    WHERE table_name = $1\n                    AND column_name = $2\n                    AND table_schema = 'public'\n                  )`,\n                  [tableName, columnName],\n                );\n\n                if (!columnExists.rows[0].exists) {\n                  // Column doesn't exist, add it\n                  const alterCommand = `ALTER TABLE ${tableName} ADD COLUMN ${columnDef}`;\n                  await client.query(alterCommand);\n                }\n              } catch (error) {\n                // If there's an error checking/adding the column, log it but continue\n                console.error(\n                  `Error adding column ${columnName} to ${tableName}:`,\n                  error,\n                );\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Executes a callback within a database transaction\n   * Automatically commits on success or rolls back on error\n   *\n   * @param callback - Function to execute within transaction\n   * @returns Promise resolving to callback result\n   */\n  const transaction = async <T>(\n    callback: (tx: DatabaseInterface) => Promise<T>,\n  ): Promise<T> => {\n    // Get a client from the pool for the transaction\n    const txClient = await client.connect();\n\n    try {\n      await txClient.query('BEGIN');\n\n      // Create a transaction-scoped database interface\n      const txDb: DatabaseInterface = {\n        client: txClient,\n        insert: async (table, data) => {\n          // Reuse insert logic but with transaction client\n          if (Array.isArray(data)) {\n            const keys = Object.keys(data[0]);\n            const placeholders = data\n              .map(\n                (_, i) =>\n                  `(${keys.map((_, j) => `$${i * keys.length + j + 1}`).join(', ')})`,\n              )\n              .join(', ');\n            const query = `INSERT INTO ${table} (${keys.join(', ')}) VALUES ${placeholders}`;\n            const values = data.reduce(\n              (acc, row) => acc.concat(Object.values(row)),\n              [] as any[],\n            );\n            const result = await txClient.query(query, values);\n            return { operation: 'insert', affected: result.rowCount ?? 0 };\n          }\n          const keys = Object.keys(data);\n          const values = Object.values(data);\n          const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ');\n          const query = `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders})`;\n          const result = await txClient.query(query, values);\n          return { operation: 'insert', affected: result.rowCount ?? 0 };\n        },\n        get: async (table, where) => {\n          const keys = Object.keys(where);\n          const values = Object.values(where);\n          const whereClause = keys\n            .map((key, i) => `${key} = $${i + 1}`)\n            .join(' AND ');\n          const query = `SELECT * FROM ${table} WHERE ${whereClause}`;\n          const result = await txClient.query(query, values);\n          return result.rows[0] || null;\n        },\n        list: async (table, where) => {\n          const { sql: whereClause, values } = buildWhere(where, 1);\n          const query = `SELECT * FROM ${table} ${whereClause}`;\n          const result = await txClient.query(query, values);\n          return result.rows;\n        },\n        update: async (table, where, data) => {\n          const keys = Object.keys(data);\n          const values = Object.values(data);\n          const setClause = keys\n            .map((key, i) => `${key} = $${i + 1}`)\n            .join(', ');\n          const whereKeys = Object.keys(where);\n          const whereValues = Object.values(where);\n          const whereClause = whereKeys\n            .map((key, i) => `${key} = $${i + 1 + values.length}`)\n            .join(' AND ');\n          const sql = `UPDATE ${table} SET ${setClause} WHERE ${whereClause}`;\n          const result = await txClient.query(sql, [...values, ...whereValues]);\n          return { operation: 'update', affected: result.rowCount ?? 0 };\n        },\n        upsert: async (table, conflictColumns, data) => {\n          const keys = Object.keys(data);\n          const values = Object.values(data);\n          const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ');\n          const updateSet = keys\n            .map((key, i) => `${key} = $${i + 1}`)\n            .join(', ');\n          const conflict = conflictColumns.join(', ');\n          const sql = `INSERT INTO ${table} (${keys.join(', ')}) VALUES (${placeholders}) ON CONFLICT(${conflict}) DO UPDATE SET ${updateSet}`;\n          const result = await txClient.query(sql, values);\n          return { operation: 'upsert', affected: result.rowCount ?? 0 };\n        },\n        getOrInsert: async (table, where, data) => {\n          const result = await txDb.get(table, where);\n          if (result) return result;\n          await txDb.insert(table, data);\n          const inserted = await txDb.get(table, where);\n          if (!inserted) {\n            throw new DatabaseError('Failed to insert and retrieve record', {\n              table,\n              where,\n              data,\n            });\n          }\n          return inserted;\n        },\n        table: (tableName) => ({\n          insert: (data) => txDb.insert(tableName, data),\n          get: (data) => txDb.get(tableName, data),\n          list: (data) => txDb.list(tableName, data),\n        }),\n        many: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          const result = await txClient.query(sql, values);\n          return result.rows;\n        },\n        single: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          const result = await txClient.query(sql, values);\n          return result.rows[0] || null;\n        },\n        pluck: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          const result = await txClient.query(sql, values);\n          const firstRow = result.rows[0];\n          if (!firstRow) return null;\n          return Object.values(firstRow)[0];\n        },\n        execute: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          await txClient.query(sql, values);\n        },\n        query: async (sql, ...values) => {\n          const result = await txClient.query(sql, values);\n          return {\n            rows: result.rows,\n            rowCount: result.rowCount ?? 0,\n          };\n        },\n        oo: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          const result = await txClient.query(sql, values);\n          return result.rows;\n        },\n        oO: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          const result = await txClient.query(sql, values);\n          return result.rows[0] || null;\n        },\n        ox: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          const result = await txClient.query(sql, values);\n          const firstRow = result.rows[0];\n          if (!firstRow) return null;\n          return Object.values(firstRow)[0];\n        },\n        xx: async (strings, ...vars) => {\n          const { sql, values } = parseTemplate(strings, ...vars);\n          await txClient.query(sql, values);\n        },\n        tableExists,\n        syncSchema,\n        transaction,\n      };\n\n      const result = await callback(txDb);\n      await txClient.query('COMMIT');\n      return result;\n    } catch (error) {\n      await txClient.query('ROLLBACK');\n      throw error;\n    } finally {\n      txClient.release();\n    }\n  };\n\n  // Shorthand aliases for query methods\n  const oo = many; // (o)bjective-(o)bjects: returns multiple rows\n  const oO = single; // (o)bjective-(O)bject: returns a single row\n  const ox = pluck; // (o)bjective-(x): returns a single value\n  const xx = execute; // (x)ecute-(x)ecute: executes without returning\n\n  /**\n   * Initialize database schemas from JSON manifest\n   * Supports dependency resolution and schema overrides\n   *\n   * @param options - Schema initialization options\n   * @returns Promise that resolves when schemas are initialized\n   */\n  const initializeSchemas = async (\n    options: SchemaInitializationOptions,\n  ): Promise<void> => {\n    const schemaManager = new DatabaseSchemaManager();\n    const currentDb: DatabaseInterface = {\n      client,\n      insert,\n      update,\n      upsert,\n      get,\n      getOrInsert,\n      list,\n      table,\n      many,\n      single,\n      pluck,\n      execute,\n      query,\n      oo,\n      oO,\n      ox,\n      xx,\n      tableExists,\n      syncSchema,\n      transaction,\n    };\n\n    await schemaManager.initializeSchemas(currentDb, options);\n  };\n\n  return {\n    client,\n    insert,\n    update,\n    upsert,\n    get,\n    getOrInsert,\n    list,\n    table,\n    many,\n    single,\n    pluck,\n    execute,\n    query,\n    oo,\n    oO,\n    ox,\n    xx,\n    tableExists,\n    syncSchema,\n    initializeSchemas,\n    transaction,\n  };\n}\n"],"names":["table","keys","placeholders","_","query","values","result","options"],"mappings":"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"}