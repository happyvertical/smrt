{"version":3,"file":"server-D6t1do0C.js","sources":["../../src/runtime/client.ts","../../src/runtime/mcp.ts","../../src/runtime/server.ts"],"sourcesContent":["/**\n * Runtime client implementation for SMRT auto-generated services\n */\n\nimport type { SmrtClientOptions } from './types';\n\nexport class SmrtClient {\n  private options: Required<SmrtClientOptions>;\n\n  constructor(options: SmrtClientOptions = {}) {\n    this.options = {\n      baseUrl: 'http://localhost:3000',\n      basePath: '/api/v1',\n      fetch: globalThis.fetch,\n      ...options,\n    } as Required<SmrtClientOptions>;\n  }\n\n  /**\n   * Make an authenticated request\n   */\n  async request(method: string, path: string, data?: any): Promise<any> {\n    const url = `${this.options.baseUrl}${this.options.basePath}${path}`;\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n\n    // Add authentication headers\n    if (this.options.auth) {\n      switch (this.options.auth.type) {\n        case 'bearer':\n          if (this.options.auth.token) {\n            headers.Authorization = `Bearer ${this.options.auth.token}`;\n          }\n          break;\n        case 'basic':\n          if (this.options.auth.username && this.options.auth.password) {\n            const credentials = btoa(\n              `${this.options.auth.username}:${this.options.auth.password}`,\n            );\n            headers.Authorization = `Basic ${credentials}`;\n          }\n          break;\n      }\n    }\n\n    const requestOptions: RequestInit = {\n      method,\n      headers,\n    };\n\n    if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n      requestOptions.body = JSON.stringify(data);\n    }\n\n    const response = await this.options.fetch(url, requestOptions);\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    // Handle empty responses\n    if (\n      response.status === 204 ||\n      response.headers.get('content-length') === '0'\n    ) {\n      return null;\n    }\n\n    const contentType = response.headers.get('content-type') || '';\n    if (contentType.includes('application/json')) {\n      return response.json();\n    }\n\n    return response.text();\n  }\n\n  /**\n   * GET request\n   */\n  async get(path: string, params?: Record<string, any>): Promise<any> {\n    let url = path;\n    if (params && Object.keys(params).length > 0) {\n      const searchParams = new URLSearchParams();\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          searchParams.append(key, String(value));\n        }\n      });\n      url += `?${searchParams.toString()}`;\n    }\n\n    return this.request('GET', url);\n  }\n\n  /**\n   * POST request\n   */\n  async post(path: string, data?: any): Promise<any> {\n    return this.request('POST', path, data);\n  }\n\n  /**\n   * PUT request\n   */\n  async put(path: string, data?: any): Promise<any> {\n    return this.request('PUT', path, data);\n  }\n\n  /**\n   * PATCH request\n   */\n  async patch(path: string, data?: any): Promise<any> {\n    return this.request('PATCH', path, data);\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete(path: string): Promise<any> {\n    return this.request('DELETE', path);\n  }\n}\n\n/**\n * Create a new SMRT client instance\n */\nexport function createSmrtClient(options?: SmrtClientOptions): SmrtClient {\n  return new SmrtClient(options);\n}\n","/**\n * Runtime MCP server implementation for SMRT auto-generated services\n */\n\nexport interface MCPTool {\n  name: string;\n  description: string;\n  inputSchema: any;\n}\n\nexport interface MCPServerOptions {\n  name?: string;\n  version?: string;\n  tools?: MCPTool[];\n  handlers?: Record<string, (params: any) => Promise<any>>;\n}\n\nexport class SmrtMCPServer {\n  private options: Required<MCPServerOptions>;\n\n  constructor(options: MCPServerOptions = {}) {\n    this.options = {\n      name: 'smrt-auto-generated',\n      version: '1.0.0',\n      tools: [],\n      handlers: {},\n      ...options,\n    };\n  }\n\n  /**\n   * Add a tool to the server\n   */\n  addTool(tool: MCPTool, handler: (params: any) => Promise<any>): void {\n    this.options.tools.push(tool);\n    this.options.handlers[tool.name] = handler;\n  }\n\n  /**\n   * Get all available tools\n   */\n  getTools(): MCPTool[] {\n    return this.options.tools;\n  }\n\n  /**\n   * Execute a tool\n   */\n  async executeTool(name: string, params: any): Promise<any> {\n    const handler = this.options.handlers[name];\n    if (!handler) {\n      throw new Error(`Tool '${name}' not found`);\n    }\n\n    try {\n      return await handler(params);\n    } catch (error) {\n      throw new Error(\n        `Tool execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n      );\n    }\n  }\n\n  /**\n   * Get server info\n   */\n  getServerInfo() {\n    return {\n      name: this.options.name,\n      version: this.options.version,\n      toolCount: this.options.tools.length,\n    };\n  }\n\n  /**\n   * Start the MCP server (basic implementation)\n   */\n  async start(): Promise<void> {\n    console.log(\n      `[smrt-mcp] Server '${this.options.name}' started with ${this.options.tools.length} tools`,\n    );\n    console.log(\n      `[smrt-mcp] Available tools: ${this.options.tools.map((t) => t.name).join(', ')}`,\n    );\n  }\n}\n\n/**\n * Create a new SMRT MCP server instance\n */\nexport function createMCPServer(options?: MCPServerOptions): SmrtMCPServer {\n  return new SmrtMCPServer(options);\n}\n","/**\n * Runtime server implementation for SMRT auto-generated services\n */\n\nimport http from 'node:http';\nimport type { SmrtRequest, SmrtServerOptions } from './types';\n\nexport class SmrtServer {\n  private options: Required<SmrtServerOptions>;\n  private routes: Map<string, (req: SmrtRequest) => Promise<Response>> =\n    new Map();\n\n  constructor(options: SmrtServerOptions = {}) {\n    this.options = {\n      port: 3000,\n      hostname: 'localhost',\n      basePath: '/api/v1',\n      cors: true,\n      ...options,\n    } as Required<SmrtServerOptions>;\n  }\n\n  /**\n   * Add a route handler\n   */\n  addRoute(\n    method: string,\n    path: string,\n    handler: (req: SmrtRequest) => Promise<Response>,\n  ) {\n    const key = `${method.toUpperCase()} ${path}`;\n    this.routes.set(key, handler);\n  }\n\n  /**\n   * Add GET route handler (RouteApp compatibility)\n   */\n  get(path: string, handler: (req: any, res: any) => void): void {\n    this.addExpressStyleRoute('GET', path, handler);\n  }\n\n  /**\n   * Add POST route handler (RouteApp compatibility)\n   */\n  post(path: string, handler: (req: any, res: any) => void): void {\n    this.addExpressStyleRoute('POST', path, handler);\n  }\n\n  /**\n   * Add PUT route handler (RouteApp compatibility)\n   */\n  put(path: string, handler: (req: any, res: any) => void): void {\n    this.addExpressStyleRoute('PUT', path, handler);\n  }\n\n  /**\n   * Add DELETE route handler (RouteApp compatibility)\n   */\n  delete(path: string, handler: (req: any, res: any) => void): void {\n    this.addExpressStyleRoute('DELETE', path, handler);\n  }\n\n  /**\n   * Convert Express-style handler to SMRT handler\n   */\n  private addExpressStyleRoute(\n    method: string,\n    path: string,\n    handler: (req: any, res: any) => void,\n  ) {\n    const smrtHandler = async (req: SmrtRequest): Promise<Response> => {\n      return new Promise((resolve, reject) => {\n        // Create Express-style response object\n        const res = {\n          status: (code: number) => {\n            res.statusCode = code;\n            return res;\n          },\n          json: (data: any) => {\n            resolve(\n              new Response(JSON.stringify(data), {\n                status: res.statusCode || 200,\n                headers: {\n                  'Content-Type': 'application/json',\n                  ...res.headers,\n                },\n              }),\n            );\n          },\n          send: (data: any) => {\n            const body = typeof data === 'string' ? data : JSON.stringify(data);\n            resolve(\n              new Response(body, {\n                status: res.statusCode || 200,\n                headers: {\n                  'Content-Type':\n                    typeof data === 'string'\n                      ? 'text/plain'\n                      : 'application/json',\n                  ...res.headers,\n                },\n              }),\n            );\n          },\n          end: (data?: any) => {\n            resolve(\n              new Response(data || '', {\n                status: res.statusCode || 200,\n                headers: res.headers,\n              }),\n            );\n          },\n          setHeader: (key: string, value: string) => {\n            if (!res.headers) res.headers = {};\n            res.headers[key] = value;\n            return res;\n          },\n          statusCode: 200,\n          headers: {} as Record<string, string>,\n        };\n\n        try {\n          handler(req, res);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    };\n\n    this.addRoute(method, path, smrtHandler);\n  }\n\n  /**\n   * Start the server\n   */\n  async start(): Promise<{ server: any; url: string }> {\n    const server = http.createServer(async (req, res) => {\n      try {\n        const request = await this.nodeRequestToWebRequest(req);\n        const response = await this.handleRequest(request);\n        await this.webResponseToNodeResponse(response, res);\n      } catch (_error) {\n        res.statusCode = 500;\n        res.end('Internal Server Error');\n      }\n    });\n\n    server.listen(this.options.port, this.options.hostname);\n\n    const url = `http://${this.options.hostname}:${this.options.port}`;\n    console.log(`[smrt] Server started at ${url}`);\n\n    return { server, url };\n  }\n\n  /**\n   * Convert stream to string\n   */\n  private async streamToString(stream: http.IncomingMessage): Promise<string> {\n    const chunks: Buffer[] = [];\n    for await (const chunk of stream) {\n      chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n    }\n    return Buffer.concat(chunks).toString('utf-8');\n  }\n\n  /**\n   * Convert Node.js IncomingMessage to Web Request\n   */\n  private async nodeRequestToWebRequest(\n    req: http.IncomingMessage,\n  ): Promise<Request> {\n    const url = `http://${this.options.hostname}:${this.options.port}${req.url}`;\n    const method = req.method || 'GET';\n    const headers = new Headers();\n\n    for (const [key, value] of Object.entries(req.headers)) {\n      if (value) {\n        headers.set(key, Array.isArray(value) ? value[0] : value);\n      }\n    }\n\n    let body: string | undefined;\n    if (method !== 'GET' && method !== 'HEAD') {\n      body = await this.streamToString(req);\n    }\n\n    return new Request(url, {\n      method,\n      headers,\n      body,\n    });\n  }\n\n  /**\n   * Convert Web Response to Node.js ServerResponse\n   */\n  private async webResponseToNodeResponse(\n    webResponse: Response,\n    res: http.ServerResponse,\n  ): Promise<void> {\n    res.statusCode = webResponse.status;\n\n    // Set headers\n    for (const [key, value] of webResponse.headers.entries()) {\n      res.setHeader(key, value);\n    }\n\n    // Send body\n    if (webResponse.body) {\n      const reader = webResponse.body.getReader();\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        res.write(value);\n      }\n    }\n\n    res.end();\n  }\n\n  /**\n   * Handle incoming requests\n   */\n  private async handleRequest(request: Request): Promise<Response> {\n    try {\n      // Handle CORS\n      if (this.options.cors && request.method === 'OPTIONS') {\n        return this.createCorsResponse();\n      }\n\n      // Parse request\n      const smrtRequest = await this.parseRequest(request);\n\n      // Check authentication\n      if (this.options.auth) {\n        const authResult = await this.authenticate(smrtRequest);\n        if (!authResult) {\n          return new Response('Unauthorized', { status: 401 });\n        }\n      }\n\n      // Find matching route\n      const routeKey = `${request.method} ${smrtRequest.url}`;\n      const handler = this.findRouteHandler(routeKey);\n\n      if (!handler) {\n        return new Response('Not Found', { status: 404 });\n      }\n\n      // Execute handler\n      const response = await handler(smrtRequest);\n\n      // Add CORS headers if needed\n      if (this.options.cors) {\n        this.addCorsHeaders(response);\n      }\n\n      return response;\n    } catch (error) {\n      console.error('[smrt] Request error:', error);\n      return new Response('Internal Server Error', { status: 500 });\n    }\n  }\n\n  /**\n   * Parse incoming request into SmrtRequest format\n   */\n  private async parseRequest(request: Request): Promise<SmrtRequest> {\n    const url = new URL(request.url);\n    const pathname = url.pathname;\n\n    // Remove base path\n    const routePath = pathname.startsWith(this.options.basePath)\n      ? pathname.slice(this.options.basePath.length)\n      : pathname;\n\n    // Parse query parameters\n    const query: Record<string, any> = {};\n    url.searchParams.forEach((value, key) => {\n      query[key] = value;\n    });\n\n    // Parse body if present\n    let body: any;\n    if (\n      request.body &&\n      (request.method === 'POST' ||\n        request.method === 'PUT' ||\n        request.method === 'PATCH')\n    ) {\n      const contentType = request.headers.get('content-type') || '';\n      if (contentType.includes('application/json')) {\n        body = await request.json();\n      } else {\n        body = await request.text();\n      }\n    }\n\n    // Extract headers\n    const headers: Record<string, string> = {};\n    request.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n\n    return {\n      params: {}, // Will be populated by route matching\n      query,\n      body,\n      headers,\n      method: request.method,\n      url: routePath,\n      json: async () => body,\n    };\n  }\n\n  /**\n   * Find route handler with parameter extraction\n   */\n  private findRouteHandler(\n    routeKey: string,\n  ): ((req: SmrtRequest) => Promise<Response>) | undefined {\n    // First try exact match\n    if (this.routes.has(routeKey)) {\n      return this.routes.get(routeKey);\n    }\n\n    // Try parameter matching\n    const [method, path] = routeKey.split(' ', 2);\n\n    for (const [key, handler] of this.routes.entries()) {\n      const [routeMethod, routePath] = key.split(' ', 2);\n\n      if (method === routeMethod) {\n        const params = this.matchRoute(path, routePath);\n        if (params !== null) {\n          // Return wrapped handler that injects params\n          return async (req: SmrtRequest) => {\n            req.params = params;\n            return handler(req);\n          };\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Match route path with parameters (e.g., /users/:id)\n   */\n  private matchRoute(\n    requestPath: string,\n    routePath: string,\n  ): Record<string, string> | null {\n    const requestSegments = requestPath.split('/').filter((s) => s);\n    const routeSegments = routePath.split('/').filter((s) => s);\n\n    if (requestSegments.length !== routeSegments.length) {\n      return null;\n    }\n\n    const params: Record<string, string> = {};\n\n    for (let i = 0; i < routeSegments.length; i++) {\n      const routeSegment = routeSegments[i];\n      const requestSegment = requestSegments[i];\n\n      if (routeSegment.startsWith(':')) {\n        // Parameter segment\n        const paramName = routeSegment.slice(1);\n        params[paramName] = requestSegment;\n      } else if (routeSegment !== requestSegment) {\n        // Literal segment mismatch\n        return null;\n      }\n    }\n\n    return params;\n  }\n\n  /**\n   * Handle authentication\n   */\n  private async authenticate(request: SmrtRequest): Promise<boolean> {\n    if (!this.options.auth) return true;\n\n    const authHeader = request.headers.authorization;\n    if (!authHeader) return false;\n\n    switch (this.options.auth.type) {\n      case 'bearer': {\n        const token = authHeader.replace('Bearer ', '');\n        return this.options.auth.verify\n          ? await this.options.auth.verify(token)\n          : true;\n      }\n\n      case 'basic': {\n        const credentials = authHeader.replace('Basic ', '');\n        return this.options.auth.verify\n          ? await this.options.auth.verify(credentials)\n          : true;\n      }\n\n      case 'custom':\n        return this.options.auth.verify\n          ? await this.options.auth.verify(authHeader)\n          : true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Create CORS preflight response\n   */\n  private createCorsResponse(): Response {\n    return new Response(null, {\n      status: 204,\n      headers: this.getCorsHeaders(),\n    });\n  }\n\n  /**\n   * Add CORS headers to response\n   */\n  private addCorsHeaders(response: Response): void {\n    const corsHeaders = this.getCorsHeaders();\n    Object.entries(corsHeaders).forEach(([key, value]) => {\n      response.headers.set(key, value);\n    });\n  }\n\n  /**\n   * Get CORS headers\n   */\n  private getCorsHeaders(): Record<string, string> {\n    const corsConfig = this.options.cors;\n\n    if (typeof corsConfig === 'boolean') {\n      return {\n        'Access-Control-Allow-Origin': '*',\n        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n        'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n      };\n    }\n\n    return {\n      'Access-Control-Allow-Origin': Array.isArray(corsConfig.origin)\n        ? corsConfig.origin.join(', ')\n        : corsConfig.origin || '*',\n      'Access-Control-Allow-Methods':\n        corsConfig.methods?.join(', ') || 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers':\n        corsConfig.headers?.join(', ') || 'Content-Type, Authorization',\n    };\n  }\n}\n\n/**\n * Create a new SMRT server instance\n */\nexport function createSmrtServer(options?: SmrtServerOptions): SmrtServer {\n  return new SmrtServer(options);\n}\n"],"names":[],"mappings":"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"}