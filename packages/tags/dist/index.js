var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self, value) => {
  for (var i = 0, fns = array[flags >> 1], n = fns && fns.length; i < n; i++) flags & 1 ? fns[i].call(self) : value = fns[i].call(self, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s = !!(flags & 8), p = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p && !s && (target = target.prototype), k < 5 && (k > 3 || !p) && __getOwnPropDesc(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i = decorators.length - 1; i >= 0; i--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s, ctx.private = p, access = ctx.access = { has: p ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3) access.get = p ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2) access.set = p ? (x, y) => __privateSet(x, target, y, k ^ 4 ? extra : desc.set) : (x, y) => x[name] = y;
    }
    it = (0, decorators[i])(k ? k < 4 ? p ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0) __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _Tag_decorators, _init, _a, _TagAlias_decorators, _init2, _b;
import { SmrtObject, smrt, SmrtCollection } from "@smrt/core";
_Tag_decorators = [smrt({
  api: { include: ["list", "get", "create", "update", "delete"] },
  mcp: { include: ["list", "get", "create", "update"] },
  cli: true
})];
class Tag extends (_a = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  _slug = "";
  // Unique identifier
  _context = "global";
  // Namespace/grouping
  // Override SmrtObject accessors
  get slug() {
    return this._slug;
  }
  set slug(value) {
    this._slug = value;
  }
  get context() {
    return this._context;
  }
  set context(value) {
    this._context = value;
  }
  name = "";
  // Display name
  parentSlug = "";
  // FK to parent tag for hierarchy (nullable)
  level = 0;
  // Hierarchy depth (0 = root)
  description = "";
  // Optional description
  metadata = "";
  // JSON metadata stored as text
  // Timestamps
  createdAt = /* @__PURE__ */ new Date();
  updatedAt = /* @__PURE__ */ new Date();
  constructor(options = {}) {
    super(options);
    if (options.slug) this._slug = options.slug;
    if (options.name) this.name = options.name;
    if (options.context !== void 0) this._context = options.context;
    if (options.parentSlug !== void 0) this.parentSlug = options.parentSlug;
    if (options.level !== void 0) this.level = options.level;
    if (options.description !== void 0)
      this.description = options.description;
    if (options.metadata !== void 0) {
      if (typeof options.metadata === "string") {
        this.metadata = options.metadata;
      } else {
        this.metadata = JSON.stringify(options.metadata);
      }
    }
  }
  /**
   * Get metadata as parsed object
   *
   * @returns Parsed metadata object or empty object if no metadata
   */
  getMetadata() {
    if (!this.metadata) return {};
    try {
      return JSON.parse(this.metadata);
    } catch {
      return {};
    }
  }
  /**
   * Set metadata from object
   *
   * @param data - Metadata object to store
   */
  setMetadata(data) {
    this.metadata = JSON.stringify(data);
  }
  /**
   * Update metadata by merging with existing values
   *
   * @param updates - Partial metadata to merge
   */
  updateMetadata(updates) {
    const current = this.getMetadata();
    this.setMetadata({ ...current, ...updates });
  }
  /**
   * Get the parent tag
   *
   * @returns Parent Tag instance or null if no parent
   */
  async getParent() {
    if (!this.parentSlug) return null;
    const { TagCollection: TagCollection2 } = await Promise.resolve().then(() => tags);
    const collection = await TagCollection2.create(this.options);
    return await collection.get({ slug: this.parentSlug });
  }
  /**
   * Get immediate child tags
   *
   * @returns Array of child Tag instances
   */
  async getChildren() {
    const { TagCollection: TagCollection2 } = await Promise.resolve().then(() => tags);
    const collection = await TagCollection2.create(this.options);
    return await collection.list({ where: { parentSlug: this.slug } });
  }
  /**
   * Get all ancestor tags (recursive)
   *
   * @returns Array of ancestor tags from root to immediate parent
   */
  async getAncestors() {
    const ancestors = [];
    let current = this;
    while (current.parentSlug) {
      const parent = await current.getParent();
      if (!parent) break;
      ancestors.unshift(parent);
      current = parent;
    }
    return ancestors;
  }
  /**
   * Get all descendant tags (recursive)
   *
   * @returns Array of all descendant tags
   */
  async getDescendants() {
    const children = await this.getChildren();
    const descendants = [...children];
    for (const child of children) {
      const childDescendants = await child.getDescendants();
      descendants.push(...childDescendants);
    }
    return descendants;
  }
  /**
   * Convenience method for slug-based lookup
   *
   * @param slug - The slug to search for
   * @param context - Optional context filter
   * @returns Tag instance or null if not found
   */
  static async getBySlug(slug, context) {
    return null;
  }
  /**
   * Get root tags (no parent) for a context
   *
   * @param context - The context to filter by
   * @returns Array of root tags
   */
  static async getRootTags(context = "global") {
    return [];
  }
}
_init = __decoratorStart(_a);
Tag = __decorateElement(_init, 0, "Tag", _Tag_decorators, Tag);
__runInitializers(_init, 1, Tag);
_TagAlias_decorators = [smrt({
  api: { include: ["list", "get", "create", "update", "delete"] },
  mcp: { include: ["list", "get", "create"] },
  cli: true
})];
class TagAlias extends (_b = SmrtObject) {
  // id: UUID (auto-generated by SmrtObject)
  tagSlug = "";
  // FK to Tag.slug
  alias = "";
  // Alternative name or translation
  language = "";
  // ISO 639-1 language code (nullable)
  _context = "";
  // Optional context scoping (nullable)
  // Override SmrtObject accessor
  get context() {
    return this._context;
  }
  set context(value) {
    this._context = value;
  }
  // Timestamps
  createdAt = /* @__PURE__ */ new Date();
  constructor(options = {}) {
    super(options);
    if (options.tagSlug) this.tagSlug = options.tagSlug;
    if (options.alias) this.alias = options.alias;
    if (options.language !== void 0) this.language = options.language;
    if (options.context !== void 0) this._context = options.context;
  }
  /**
   * Get the tag this alias belongs to
   *
   * @returns Tag instance or null if not found
   */
  async getTag() {
    const { TagCollection: TagCollection2 } = await Promise.resolve().then(() => tags);
    const collection = await TagCollection2.create(this.options);
    return await collection.get({ slug: this.tagSlug });
  }
  /**
   * Search tags by alias
   *
   * @param alias - The alias to search for
   * @param language - Optional language filter
   * @returns Array of matching tags
   */
  static async searchByAlias(alias, language) {
    return [];
  }
  /**
   * Get all aliases for a tag
   *
   * @param tagSlug - The tag slug to get aliases for
   * @returns Array of TagAlias instances
   */
  static async getAliasesForTag(tagSlug) {
    return [];
  }
}
_init2 = __decoratorStart(_b);
TagAlias = __decorateElement(_init2, 0, "TagAlias", _TagAlias_decorators, TagAlias);
__runInitializers(_init2, 1, TagAlias);
class TagCollection extends SmrtCollection {
  static _itemClass = Tag;
  /**
   * Get or create a tag with context
   *
   * @param slug - Tag slug
   * @param context - Tag context (default: 'global')
   * @returns Tag instance
   */
  async getOrCreate(slug, context = "global") {
    const existing = await this.list({
      where: { slug, context },
      limit: 1
    });
    if (existing.length > 0) {
      return existing[0];
    }
    return await this.create({
      slug,
      name: slug.replace(/-/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
      context,
      level: 0
    });
  }
  /**
   * List tags by context with optional parent filtering
   *
   * @param context - The context to filter by
   * @param parentSlug - Optional parent slug to filter children
   * @returns Array of matching tags
   */
  async listByContext(context, parentSlug) {
    const where = { context };
    if (parentSlug !== void 0) {
      where.parentSlug = parentSlug;
    }
    return await this.list({ where });
  }
  /**
   * Get root tags (no parent) for a context
   *
   * @param context - The context to filter by (default: 'global')
   * @returns Array of root tags
   */
  async getRootTags(context = "global") {
    return await this.list({
      where: { context, parentSlug: null }
    });
  }
  /**
   * Get immediate children of a parent tag
   *
   * @param parentSlug - The parent tag slug
   * @returns Array of child tags
   */
  async getChildren(parentSlug) {
    return await this.list({
      where: { parentSlug }
    });
  }
  /**
   * Get tag hierarchy (all ancestors and descendants)
   *
   * @param slug - The tag slug
   * @returns Object with ancestors, current tag, and descendants
   */
  async getHierarchy(slug) {
    const tag = await this.get({ slug });
    if (!tag) throw new Error(`Tag '${slug}' not found`);
    const ancestors = await this.getAncestors(tag);
    const descendants = await this.getDescendants(tag);
    return { ancestors, current: tag, descendants };
  }
  /**
   * Move a tag to a new parent (updates level automatically)
   *
   * @param slug - The tag to move
   * @param newParentSlug - The new parent slug (null for root)
   * @throws Error if circular reference detected
   */
  async moveTag(slug, newParentSlug) {
    const tag = await this.get({ slug });
    if (!tag) throw new Error(`Tag '${slug}' not found`);
    if (newParentSlug) {
      const hasCircular = await this.hasCircularReference(slug, newParentSlug);
      if (hasCircular) {
        throw new Error(
          `Cannot move tag: circular reference detected (${slug} -> ${newParentSlug})`
        );
      }
    }
    const newLevel = await this.calculateLevel(newParentSlug);
    tag.parentSlug = newParentSlug || "";
    tag.level = newLevel;
    await tag.save();
    await this.updateDescendantLevels(tag);
  }
  /**
   * Merge one tag into another (updates all references)
   *
   * Note: This method updates the tag itself but consuming packages
   * are responsible for updating their join tables (e.g., asset_tags)
   *
   * @param fromSlug - The tag to merge from
   * @param toSlug - The tag to merge into
   */
  async mergeTag(fromSlug, toSlug) {
    const fromTag = await this.get({ slug: fromSlug });
    const toTag = await this.get({ slug: toSlug });
    if (!fromTag) throw new Error(`Source tag '${fromSlug}' not found`);
    if (!toTag) throw new Error(`Target tag '${toSlug}' not found`);
    const children = await this.getChildren(fromSlug);
    for (const child of children) {
      child.parentSlug = toSlug;
      await child.save();
    }
    const { TagAliasCollection: TagAliasCollection2 } = await Promise.resolve().then(() => tagAliases);
    const aliasCollection = await TagAliasCollection2.create(this.options);
    const aliases = await aliasCollection.list({
      where: { tagSlug: fromSlug }
    });
    for (const alias of aliases) {
      alias.tagSlug = toSlug;
      await alias.save();
    }
    await fromTag.delete();
  }
  /**
   * Remove tags with no references (cleanup unused tags)
   *
   * Note: This requires consuming packages to provide usage information.
   * By default, only removes tags with no children and no aliases.
   *
   * @param context - Optional context to filter cleanup
   */
  async cleanupUnused(context) {
    const where = {};
    if (context) where.context = context;
    const tags2 = await this.list({ where });
    const { TagAliasCollection: TagAliasCollection2 } = await Promise.resolve().then(() => tagAliases);
    const aliasCollection = await TagAliasCollection2.create(this.options);
    let deletedCount = 0;
    for (const tag of tags2) {
      const children = await this.getChildren(tag.slug);
      if (children.length > 0) continue;
      const aliases = await aliasCollection.list({
        where: { tagSlug: tag.slug }
      });
      if (aliases.length > 0) continue;
      await tag.delete();
      deletedCount++;
    }
    return deletedCount;
  }
  /**
   * Calculate hierarchy level for a tag
   *
   * @param parentSlug - The parent tag slug (null for root)
   * @returns The calculated level
   */
  async calculateLevel(parentSlug) {
    if (!parentSlug) return 0;
    const parent = await this.get({ slug: parentSlug });
    if (!parent) return 0;
    return parent.level + 1;
  }
  /**
   * Check if moving a tag would create a circular reference
   *
   * @param slug - The tag being moved
   * @param newParentSlug - The proposed new parent
   * @returns True if circular reference detected
   */
  async hasCircularReference(slug, newParentSlug) {
    let current = newParentSlug;
    while (current) {
      if (current === slug) return true;
      const parent = await this.get({ slug: current });
      if (!parent || !parent.parentSlug) break;
      current = parent.parentSlug;
    }
    return false;
  }
  /**
   * Get all ancestor tags (recursive)
   *
   * @param tag - The tag to get ancestors for
   * @returns Array of ancestor tags from root to immediate parent
   */
  async getAncestors(tag) {
    const ancestors = [];
    let current = tag;
    while (current.parentSlug) {
      const parent = await this.get({ slug: current.parentSlug });
      if (!parent) break;
      ancestors.unshift(parent);
      current = parent;
    }
    return ancestors;
  }
  /**
   * Get all descendant tags (recursive)
   *
   * @param tag - The tag to get descendants for
   * @returns Array of all descendant tags
   */
  async getDescendants(tag) {
    const children = await this.list({ where: { parentSlug: tag.slug } });
    const descendants = [...children];
    for (const child of children) {
      const childDescendants = await this.getDescendants(child);
      descendants.push(...childDescendants);
    }
    return descendants;
  }
  /**
   * Update levels for all descendants after moving a tag
   *
   * @param tag - The tag that was moved
   */
  async updateDescendantLevels(tag) {
    const children = await this.getChildren(tag.slug);
    for (const child of children) {
      child.level = tag.level + 1;
      await child.save();
      await this.updateDescendantLevels(child);
    }
  }
}
const tags = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TagCollection
}, Symbol.toStringTag, { value: "Module" }));
class TagAliasCollection extends SmrtCollection {
  static _itemClass = TagAlias;
  /**
   * Add an alias to a tag (get or create)
   *
   * @param tagSlug - The tag slug
   * @param alias - The alias text
   * @param language - Optional language code
   * @param context - Optional context
   * @returns TagAlias instance
   */
  async addAlias(tagSlug, alias, language, context) {
    const where = { tagSlug, alias };
    if (language) where.language = language;
    if (context) where.context = context;
    const existing = await this.list({ where, limit: 1 });
    if (existing.length > 0) {
      return existing[0];
    }
    return await this.create({
      tagSlug,
      alias,
      language,
      context
    });
  }
  /**
   * Search tags by alias
   *
   * @param alias - The alias to search for
   * @param language - Optional language filter
   * @returns Array of matching tags
   */
  async searchByAlias(alias, language) {
    const where = { alias };
    if (language) where.language = language;
    const aliases = await this.list({ where });
    const tagSlugs = [...new Set(aliases.map((a) => a.tagSlug))];
    const { TagCollection: TagCollection2 } = await Promise.resolve().then(() => tags);
    const tagCollection = await TagCollection2.create(this.options);
    const tags$1 = [];
    for (const slug of tagSlugs) {
      const tag = await tagCollection.get({ slug });
      if (tag) tags$1.push(tag);
    }
    return tags$1;
  }
  /**
   * Get all aliases for a tag
   *
   * @param tagSlug - The tag slug
   * @param language - Optional language filter
   * @returns Array of TagAlias instances
   */
  async getAliasesForTag(tagSlug, language) {
    const where = { tagSlug };
    if (language) where.language = language;
    return await this.list({ where });
  }
  /**
   * Remove an alias by ID
   *
   * @param aliasId - The alias UUID
   */
  async removeAlias(aliasId) {
    const alias = await this.get({ id: aliasId });
    if (alias) {
      await alias.delete();
    }
  }
  /**
   * Bulk add aliases to a tag
   *
   * @param tagSlug - The tag slug
   * @param aliases - Array of alias configurations
   * @returns Array of created TagAlias instances
   */
  async bulkAddAliases(tagSlug, aliases) {
    const created = [];
    for (const aliasData of aliases) {
      const tagAlias = await this.addAlias(
        tagSlug,
        aliasData.alias,
        aliasData.language,
        aliasData.context
      );
      created.push(tagAlias);
    }
    return created;
  }
  /**
   * Get aliases grouped by language
   *
   * @param tagSlug - The tag slug
   * @returns Map of language code to array of aliases
   */
  async getAliasesByLanguage(tagSlug) {
    const aliases = await this.getAliasesForTag(tagSlug);
    const grouped = /* @__PURE__ */ new Map();
    for (const alias of aliases) {
      const lang = alias.language || "default";
      if (!grouped.has(lang)) {
        grouped.set(lang, []);
      }
      grouped.get(lang)?.push(alias.alias);
    }
    return grouped;
  }
  /**
   * Find similar aliases (case-insensitive partial match)
   *
   * Note: This is a simple implementation. For production use,
   * consider using full-text search or fuzzy matching.
   *
   * @param query - The search query
   * @param language - Optional language filter
   * @returns Array of matching TagAlias instances
   */
  async findSimilar(query, language) {
    const where = {};
    if (language) where.language = language;
    const all = await this.list({ where });
    const queryLower = query.toLowerCase();
    return all.filter(
      (alias) => alias.alias.toLowerCase().includes(queryLower)
    );
  }
}
const tagAliases = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TagAliasCollection
}, Symbol.toStringTag, { value: "Module" }));
function validateSlug(slug) {
  const slugPattern = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
  return slugPattern.test(slug);
}
function sanitizeSlug(input) {
  return input.toLowerCase().trim().replace(/\s+/g, "-").replace(/[^a-z0-9-]/g, "").replace(/-+/g, "-").replace(/^-|-$/g, "");
}
async function hasCircularReference(slug, parentSlug, tagCollection) {
  let current = parentSlug;
  while (current) {
    if (current === slug) return true;
    const parent = await tagCollection.get({ slug: current });
    if (!parent || !parent.parentSlug) break;
    current = parent.parentSlug;
  }
  return false;
}
async function calculateLevel(parentSlug, tagCollection) {
  if (!parentSlug) return 0;
  const parent = await tagCollection.get({ slug: parentSlug });
  if (!parent) return 0;
  return parent.level + 1;
}
async function generateUniqueSlug(name, context, tagCollection) {
  const baseSlug = sanitizeSlug(name);
  let slug = baseSlug;
  let counter = 1;
  while (true) {
    const existing = await tagCollection.list({
      where: { slug, context },
      limit: 1
    });
    if (existing.length === 0) break;
    slug = `${baseSlug}-${counter}`;
    counter++;
  }
  return slug;
}
export {
  Tag,
  TagAlias,
  TagAliasCollection,
  TagCollection,
  calculateLevel,
  generateUniqueSlug,
  hasCircularReference,
  sanitizeSlug,
  validateSlug
};
//# sourceMappingURL=index.js.map
