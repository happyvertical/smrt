{"version":3,"file":"manifest-generator-Bb3IuFsV.js","sources":["../../src/tools/tool-generator.ts","../../src/scanner/manifest-generator.ts"],"sourcesContent":["/**\n * Tool Manifest Generation for AI Function Calling\n *\n * This module converts TypeScript method definitions from the AST scanner\n * into AI tool format at build time for use with LLM function calling.\n */\n\nimport type { MethodDefinition } from '../scanner/types';\nimport type { AITool } from '@have/ai';\n\n/**\n * Configuration for AI-callable methods\n */\nexport interface AiConfig {\n  /**\n   * Methods that AI can call\n   * - Array of method names, e.g., ['analyze', 'validate']\n   * - 'public-async' to auto-include all public async methods\n   * - 'all' to include all methods (not recommended)\n   */\n  callable?: string[] | 'public-async' | 'all';\n\n  /**\n   * Methods to exclude from AI calling (higher priority than callable)\n   */\n  exclude?: string[];\n\n  /**\n   * Additional tool descriptions to override method JSDoc\n   */\n  descriptions?: Record<string, string>;\n}\n\n/**\n * Converts a TypeScript type string to JSON Schema format\n *\n * @param tsType - TypeScript type string (e.g., 'string', 'number', '{ foo: string }')\n * @returns JSON Schema representation\n */\nexport function convertTypeToJsonSchema(tsType: string): Record<string, any> {\n  // Remove whitespace\n  const cleanType = tsType.trim();\n\n  // Primitive types\n  if (cleanType === 'string') {\n    return { type: 'string' };\n  }\n  if (cleanType === 'number') {\n    return { type: 'number' };\n  }\n  if (cleanType === 'boolean') {\n    return { type: 'boolean' };\n  }\n  if (cleanType === 'null') {\n    return { type: 'null' };\n  }\n  if (cleanType === 'any' || cleanType === 'unknown') {\n    return {}; // No type constraint\n  }\n\n  // Array types\n  if (cleanType.endsWith('[]')) {\n    const itemType = cleanType.slice(0, -2);\n    return {\n      type: 'array',\n      items: convertTypeToJsonSchema(itemType),\n    };\n  }\n\n  // Array<T> syntax\n  const arrayMatch = cleanType.match(/^Array<(.+)>$/);\n  if (arrayMatch) {\n    return {\n      type: 'array',\n      items: convertTypeToJsonSchema(arrayMatch[1]),\n    };\n  }\n\n  // Union types with literal values (e.g., 'shallow' | 'deep')\n  if (cleanType.includes('|')) {\n    const options = cleanType.split('|').map((s) => s.trim());\n\n    // Check if all options are string literals\n    if (options.every((opt) => opt.startsWith(\"'\") && opt.endsWith(\"'\"))) {\n      return {\n        type: 'string',\n        enum: options.map((opt) => opt.slice(1, -1)), // Remove quotes\n      };\n    }\n\n    // Mixed union - use oneOf\n    return {\n      oneOf: options.map(convertTypeToJsonSchema),\n    };\n  }\n\n  // Object types - basic support\n  if (cleanType.startsWith('{') && cleanType.endsWith('}')) {\n    return { type: 'object' };\n  }\n\n  // Record<string, any> and similar\n  if (cleanType.startsWith('Record<')) {\n    return { type: 'object' };\n  }\n\n  // Default fallback\n  return { type: 'string', description: `TypeScript type: ${cleanType}` };\n}\n\n/**\n * Determines if a method should be included as an AI-callable tool\n *\n * @param method - Method definition from AST scanner\n * @param config - AI configuration from @smrt decorator\n * @returns True if method should be callable by AI\n */\nexport function shouldIncludeMethod(\n  method: MethodDefinition,\n  config?: AiConfig,\n): boolean {\n  // Skip if no AI config\n  if (!config || !config.callable) {\n    return false;\n  }\n\n  // Check exclusions first (higher priority)\n  if (config.exclude?.includes(method.name)) {\n    return false;\n  }\n\n  // Skip private methods always\n  if (!method.isPublic) {\n    return false;\n  }\n\n  // Skip static methods (tools operate on instances)\n  if (method.isStatic) {\n    return false;\n  }\n\n  // Handle 'all' mode\n  if (config.callable === 'all') {\n    return true;\n  }\n\n  // Handle 'public-async' mode\n  if (config.callable === 'public-async') {\n    return method.async;\n  }\n\n  // Handle explicit array of method names\n  if (Array.isArray(config.callable)) {\n    return config.callable.includes(method.name);\n  }\n\n  return false;\n}\n\n/**\n * Generates an AITool definition from a method definition\n *\n * @param method - Method definition from AST scanner\n * @param config - AI configuration for custom descriptions\n * @returns AITool definition for LLM function calling\n */\nexport function generateToolFromMethod(\n  method: MethodDefinition,\n  config?: AiConfig,\n): AITool {\n  // Build parameters JSON Schema\n  const parameters: Record<string, any> = {\n    type: 'object',\n    properties: {},\n    required: [],\n  };\n\n  for (const param of method.parameters) {\n    // Convert parameter type to JSON Schema\n    parameters.properties[param.name] = convertTypeToJsonSchema(param.type);\n\n    // Add to required if not optional\n    if (!param.optional) {\n      parameters.required.push(param.name);\n    }\n\n    // Add default value if present\n    if (param.default !== undefined) {\n      parameters.properties[param.name].default = param.default;\n    }\n  }\n\n  // Remove empty required array\n  if (parameters.required.length === 0) {\n    delete parameters.required;\n  }\n\n  // Get description (custom override or from JSDoc)\n  const description =\n    config?.descriptions?.[method.name] ||\n    method.description ||\n    `Call the ${method.name} method`;\n\n  return {\n    type: 'function',\n    function: {\n      name: method.name,\n      description,\n      parameters,\n    },\n  };\n}\n\n/**\n * Generates tool manifest from method definitions\n *\n * @param methods - Array of method definitions from AST scanner\n * @param config - AI configuration from @smrt decorator\n * @returns Array of AITool definitions for LLM function calling\n */\nexport function generateToolManifest(\n  methods: MethodDefinition[],\n  config?: AiConfig,\n): AITool[] {\n  const tools: AITool[] = [];\n\n  for (const method of methods) {\n    if (shouldIncludeMethod(method, config)) {\n      const tool = generateToolFromMethod(method, config);\n      tools.push(tool);\n    }\n  }\n\n  return tools;\n}\n","/**\n * Manifest generator for creating service manifests from AST scan results\n */\n\nimport type {\n  ScanResult,\n  SmartObjectDefinition,\n  SmartObjectManifest,\n} from './types';\nimport { generateToolManifest } from '../tools/tool-generator';\n\nexport class ManifestGenerator {\n  /**\n   * Generate manifest from scan results\n   */\n  generateManifest(scanResults: ScanResult[]): SmartObjectManifest {\n    const manifest: SmartObjectManifest = {\n      version: '1.0.0',\n      timestamp: Date.now(),\n      objects: {},\n    };\n\n    for (const result of scanResults) {\n      for (const objectDef of result.objects) {\n        // Generate AI tools from methods if AI config exists\n        if (objectDef.decoratorConfig.ai) {\n          const methods = Object.values(objectDef.methods);\n          const tools = generateToolManifest(\n            methods,\n            objectDef.decoratorConfig.ai,\n          );\n\n          // Store tools in object definition\n          if (tools.length > 0) {\n            objectDef.tools = tools;\n          }\n        }\n\n        manifest.objects[objectDef.name] = objectDef;\n      }\n    }\n\n    return manifest;\n  }\n\n  /**\n   * Generate TypeScript interfaces from manifest\n   */\n  generateTypeDefinitions(manifest: SmartObjectManifest): string {\n    const interfaces: string[] = [];\n\n    for (const [_name, obj] of Object.entries(manifest.objects)) {\n      interfaces.push(this.generateInterface(obj));\n    }\n\n    return interfaces.join('\\n\\n');\n  }\n\n  /**\n   * Generate a single interface definition\n   */\n  private generateInterface(obj: SmartObjectDefinition): string {\n    const fields = Object.entries(obj.fields)\n      .map(([name, field]) => {\n        const optional = !field.required ? '?' : '';\n        const type = this.mapFieldTypeToTS(field.type);\n        return `  ${name}${optional}: ${type};`;\n      })\n      .join('\\n');\n\n    return `export interface ${obj.className}Data {\n${fields}\n}`;\n  }\n\n  /**\n   * Map field types to TypeScript types\n   */\n  private mapFieldTypeToTS(fieldType: string): string {\n    switch (fieldType) {\n      case 'text':\n        return 'string';\n      case 'decimal':\n        return 'number';\n      case 'integer':\n        return 'number';\n      case 'boolean':\n        return 'boolean';\n      case 'datetime':\n        return 'Date | string';\n      case 'json':\n        return 'any';\n      case 'foreignKey':\n        return 'string';\n      default:\n        return 'any';\n    }\n  }\n\n  /**\n   * Generate simple endpoint list for testing/documentation\n   */\n  generateRestEndpoints(manifest: SmartObjectManifest): string {\n    const endpoints: string[] = [];\n\n    for (const [_name, obj] of Object.entries(manifest.objects)) {\n      const apiConfig = obj.decoratorConfig.api;\n      if (apiConfig !== false) {\n        endpoints.push(...this.getSimpleEndpoints(obj));\n      }\n    }\n\n    return endpoints.join('\\n');\n  }\n\n  /**\n   * Generate REST endpoint code implementations\n   */\n  generateRestEndpointCode(manifest: SmartObjectManifest): string {\n    const endpoints: string[] = [];\n\n    for (const [_name, obj] of Object.entries(manifest.objects)) {\n      const apiConfig = obj.decoratorConfig.api;\n      if (apiConfig !== false) {\n        endpoints.push(this.generateRestEndpoint(obj));\n      }\n    }\n\n    return endpoints.join('\\n\\n');\n  }\n\n  /**\n   * Get simple endpoint strings for an object\n   */\n  private getSimpleEndpoints(obj: SmartObjectDefinition): string[] {\n    const { collection } = obj;\n    const config = obj.decoratorConfig.api;\n    const exclude = (typeof config === 'object' && config?.exclude) || [];\n    const include =\n      (typeof config === 'object' && config?.include) || undefined;\n\n    const endpoints: string[] = [];\n\n    // Determine which operations to include\n    const shouldInclude = (op: string) => {\n      if (include && !include.includes(op)) return false;\n      if (exclude.includes(op)) return false;\n      return true;\n    };\n\n    if (shouldInclude('list')) {\n      endpoints.push(`GET /${collection}`);\n    }\n    if (shouldInclude('create')) {\n      endpoints.push(`POST /${collection}`);\n    }\n    if (shouldInclude('get')) {\n      endpoints.push(`GET /${collection}/:id`);\n    }\n    if (shouldInclude('update')) {\n      endpoints.push(`PUT /${collection}/:id`);\n    }\n    if (shouldInclude('delete')) {\n      endpoints.push(`DELETE /${collection}/:id`);\n    }\n\n    return endpoints;\n  }\n\n  /**\n   * Generate a single REST endpoint\n   */\n  private generateRestEndpoint(obj: SmartObjectDefinition): string {\n    const { collection, className } = obj;\n    const config = obj.decoratorConfig.api;\n    const exclude = (typeof config === 'object' && config?.exclude) || [];\n    const include =\n      (typeof config === 'object' && config?.include) || undefined;\n\n    const operations = [];\n\n    // Determine which operations to include\n    const shouldInclude = (op: string) => {\n      if (include && !include.includes(op)) return false;\n      if (exclude.includes(op)) return false;\n      return true;\n    };\n\n    if (shouldInclude('list')) {\n      operations.push(`  // GET /${collection} - List ${collection}`);\n      operations.push(`  app.get('/${collection}', async (req: Request) => {`);\n      operations.push(\n        `    const collection = await get${className}Collection();`,\n      );\n      operations.push('    const items = await collection.list(req.query);');\n      operations.push('    return Response.json(items);');\n      operations.push('  });');\n    }\n\n    if (shouldInclude('get')) {\n      operations.push(`  // GET /${collection}/:id - Get ${className}`);\n      operations.push(\n        `  app.get('/${collection}/:id', async (req: Request) => {`,\n      );\n      operations.push(\n        `    const collection = await get${className}Collection();`,\n      );\n      operations.push('    const item = await collection.get(req.params.id);');\n      operations.push(\n        `    if (!item) return new Response('Not found', { status: 404 });`,\n      );\n      operations.push('    return Response.json(item);');\n      operations.push('  });');\n    }\n\n    if (shouldInclude('create')) {\n      operations.push(`  // POST /${collection} - Create ${className}`);\n      operations.push(`  app.post('/${collection}', async (req: Request) => {`);\n      operations.push(\n        `    const collection = await get${className}Collection();`,\n      );\n      operations.push('    const data = await req.json();');\n      operations.push('    const item = await collection.create(data);');\n      operations.push('    return Response.json(item, { status: 201 });');\n      operations.push('  });');\n    }\n\n    if (shouldInclude('update')) {\n      operations.push(`  // PUT /${collection}/:id - Update ${className}`);\n      operations.push(\n        `  app.put('/${collection}/:id', async (req: Request) => {`,\n      );\n      operations.push(\n        `    const collection = await get${className}Collection();`,\n      );\n      operations.push('    const data = await req.json();');\n      operations.push(\n        '    const item = await collection.update(req.params.id, data);',\n      );\n      operations.push(\n        `    if (!item) return new Response('Not found', { status: 404 });`,\n      );\n      operations.push('    return Response.json(item);');\n      operations.push('  });');\n    }\n\n    if (shouldInclude('delete')) {\n      operations.push(`  // DELETE /${collection}/:id - Delete ${className}`);\n      operations.push(\n        `  app.delete('/${collection}/:id', async (req: Request) => {`,\n      );\n      operations.push(\n        `    const collection = await get${className}Collection();`,\n      );\n      operations.push(\n        '    const success = await collection.delete(req.params.id);',\n      );\n      operations.push(\n        `    if (!success) return new Response('Not found', { status: 404 });`,\n      );\n      operations.push(`    return new Response('', { status: 204 });`);\n      operations.push('  });');\n    }\n\n    return `// ${className} endpoints\\n${operations.join('\\n')}`;\n  }\n\n  /**\n   * Generate simple MCP tool names for testing/documentation\n   */\n  generateMCPTools(manifest: SmartObjectManifest): string {\n    const tools: string[] = [];\n\n    for (const [_name, obj] of Object.entries(manifest.objects)) {\n      const mcpConfig = obj.decoratorConfig.mcp;\n      if (mcpConfig !== false) {\n        tools.push(...this.getSimpleMCPToolNames(obj));\n      }\n    }\n\n    return tools.join('\\n');\n  }\n\n  /**\n   * Generate MCP tool JSON definitions\n   */\n  generateMCPToolsCode(manifest: SmartObjectManifest): string {\n    const tools: string[] = [];\n\n    for (const [_name, obj] of Object.entries(manifest.objects)) {\n      const mcpConfig = obj.decoratorConfig.mcp;\n      if (mcpConfig !== false) {\n        tools.push(this.generateMCPTool(obj));\n      }\n    }\n\n    return `[\\n${tools.join(',\\n')}\\n]`;\n  }\n\n  /**\n   * Get simple MCP tool names for an object\n   */\n  private getSimpleMCPToolNames(obj: SmartObjectDefinition): string[] {\n    const { collection } = obj;\n    const config = obj.decoratorConfig.mcp;\n    const exclude = (typeof config === 'object' && config?.exclude) || [];\n    const include =\n      (typeof config === 'object' && config?.include) || undefined;\n\n    const tools: string[] = [];\n\n    const shouldInclude = (op: string) => {\n      if (include && !include.includes(op)) return false;\n      if (exclude.includes(op)) return false;\n      return true;\n    };\n\n    if (shouldInclude('list')) {\n      tools.push(`list_${collection}`);\n    }\n    if (shouldInclude('get')) {\n      tools.push(`get_${collection}`);\n    }\n    if (shouldInclude('create')) {\n      tools.push(`create_${collection}`);\n    }\n    if (shouldInclude('update')) {\n      tools.push(`update_${collection}`);\n    }\n    if (shouldInclude('delete')) {\n      tools.push(`delete_${collection}`);\n    }\n\n    return tools;\n  }\n\n  /**\n   * Generate a single MCP tool\n   */\n  private generateMCPTool(obj: SmartObjectDefinition): string {\n    const { collection, className, name } = obj;\n    const config = obj.decoratorConfig.mcp;\n    const exclude = (typeof config === 'object' && config?.exclude) || [];\n    const include =\n      (typeof config === 'object' && config?.include) || undefined;\n\n    const tools = [];\n\n    const shouldInclude = (op: string) => {\n      if (include && !include.includes(op)) return false;\n      if (exclude.includes(op)) return false;\n      return true;\n    };\n\n    if (shouldInclude('list')) {\n      tools.push(`  {\n    name: \"list_${collection}\",\n    description: \"List ${collection}\",\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        limit: { type: \"number\" },\n        offset: { type: \"number\" },\n        where: { type: \"object\" }\n      }\n    }\n  }`);\n    }\n\n    if (shouldInclude('get')) {\n      tools.push(`  {\n    name: \"get_${name}\",\n    description: \"Get a ${name} by ID\",\n    inputSchema: {\n      type: \"object\",\n      properties: {\n        id: { type: \"string\", description: \"The ${name} ID\" }\n      },\n      required: [\"id\"]\n    }\n  }`);\n    }\n\n    if (shouldInclude('create')) {\n      const requiredFields = Object.entries(obj.fields)\n        .filter(([_, field]) => field.required)\n        .map(([fieldName]) => fieldName);\n\n      tools.push(`  {\n    name: \"create_${name}\",\n    description: \"Create a new ${name}\",\n    inputSchema: {\n      type: \"object\",\n      properties: ${JSON.stringify(this.generateSchemaProperties(obj.fields), null, 6)},\n      required: ${JSON.stringify(requiredFields)}\n    }\n  }`);\n    }\n\n    return tools.join(',\\n');\n  }\n\n  /**\n   * Generate JSON schema properties for fields\n   */\n  private generateSchemaProperties(\n    fields: Record<string, any>,\n  ): Record<string, any> {\n    const properties: Record<string, any> = {};\n\n    for (const [name, field] of Object.entries(fields)) {\n      properties[name] = {\n        type: this.mapFieldTypeToJSON(field.type),\n        description: field.description || `The ${name} field`,\n      };\n\n      if (field.min !== undefined) properties[name].minimum = field.min;\n      if (field.max !== undefined) properties[name].maximum = field.max;\n      if (field.minLength !== undefined)\n        properties[name].minLength = field.minLength;\n      if (field.maxLength !== undefined)\n        properties[name].maxLength = field.maxLength;\n    }\n\n    return properties;\n  }\n\n  /**\n   * Map field types to JSON Schema types\n   */\n  private mapFieldTypeToJSON(fieldType: string): string {\n    switch (fieldType) {\n      case 'text':\n        return 'string';\n      case 'decimal':\n        return 'number';\n      case 'integer':\n        return 'integer';\n      case 'boolean':\n        return 'boolean';\n      case 'datetime':\n        return 'string';\n      case 'json':\n        return 'object';\n      case 'foreignKey':\n        return 'string';\n      default:\n        return 'string';\n    }\n  }\n\n  /**\n   * Save manifest to file\n   */\n  saveManifest(manifest: SmartObjectManifest, filePath: string): void {\n    const fs = require('node:fs');\n    fs.writeFileSync(filePath, JSON.stringify(manifest, null, 2));\n  }\n\n  /**\n   * Load manifest from file\n   */\n  loadManifest(filePath: string): SmartObjectManifest {\n    const fs = require('node:fs');\n    const content = fs.readFileSync(filePath, 'utf-8');\n    return JSON.parse(content);\n  }\n}\n\n/**\n * Convenience function to generate manifest\n */\nexport function generateManifest(\n  scanResults: ScanResult[],\n): SmartObjectManifest {\n  const generator = new ManifestGenerator();\n  return generator.generateManifest(scanResults);\n}\n"],"names":[],"mappings":"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"}