import { existsSync, mkdirSync, writeFileSync, readFileSync } from "node:fs";
import { join, relative, dirname } from "node:path";
import { fileURLToPath } from "node:url";
async function generateSvelteKitRoutes(projectRoot, manifest, options) {
  if (!options.enabled) return;
  console.log("[smrt] Generating SvelteKit routes...");
  await generateSmrtConfigFile(projectRoot, manifest, options);
  for (const [className, objectDef] of Object.entries(manifest.objects)) {
    await generateRoutesForObject(projectRoot, className, objectDef, options);
  }
  updateGitignore(projectRoot, options);
  console.log(
    `[smrt] Generated routes for ${Object.keys(manifest.objects).length} SMRT objects`
  );
}
async function generateRegistrationFile(projectRoot, manifest, options) {
  const configPath = options.configPath || "src/lib/server";
  const configDir = join(projectRoot, configPath);
  const registrationFilePath = join(configDir, "smrt-register.ts");
  const imports = Object.entries(manifest.objects).map(([className, objectDef]) => {
    const importPath = getSvelteKitImportPath(
      projectRoot,
      objectDef.filePath,
      options.objectsDir,
      className
    );
    const actualClassName = importPath.split("/").pop() || className;
    return `import { ${actualClassName} } from '${importPath}';`;
  }).join("\n");
  const registrationContent = `/**
 * Auto-generated SMRT object registration
 * DO NOT EDIT - changes will be overwritten
 *
 * This file imports all SMRT objects to trigger their @smrt() decorators
 * and register them in the ObjectRegistry.
 */

${imports}

// Objects are registered automatically when imported via @smrt() decorator
`;
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
  writeFileSync(registrationFilePath, registrationContent, "utf-8");
  console.log(`[smrt] Generated registration file: ${registrationFilePath}`);
}
async function generateSmrtConfigFile(projectRoot, manifest, options) {
  const configPath = options.configPath || "src/lib/server";
  const configFileName = options.configFileName || "smrt.ts";
  const configDir = join(projectRoot, configPath);
  const configFilePath = join(configDir, configFileName);
  await generateRegistrationFile(projectRoot, manifest, options);
  if (existsSync(configFilePath)) {
    console.log("[smrt] Config file already exists, skipping generation");
    return;
  }
  const configContent = `/**
 * Centralized SMRT configuration with per-object overrides
 * Generated by @smrt/core vite plugin
 *
 * Most objects will use the default configuration.
 * Add entries to \`objectOverrides\` for objects that need different backends.
 */

// Import SMRT objects to register them via @smrt() decorators
import './smrt-register.js';

import { ObjectRegistry } from '@smrt/core';
import type { SmrtClassOptions } from '@smrt/core';

/**
 * Per-object configuration overrides
 * Define specific backends for objects that differ from project defaults
 *
 * @example
 * const objectOverrides: Record<string, Partial<SmrtClassOptions>> = {
 *   // Analytics uses a separate PostgreSQL database
 *   Analytics: {
 *     db: {
 *       url: process.env.ANALYTICS_DATABASE_URL!,
 *       type: 'postgres'
 *     }
 *   },
 *
 *   // AuditLog uses dedicated database with no AI
 *   AuditLog: {
 *     db: {
 *       url: process.env.AUDIT_DATABASE_URL!,
 *       type: 'postgres'
 *     },
 *     ai: undefined
 *   },
 *
 *   // Cache uses REST adapter (e.g., Redis)
 *   Cache: {
 *     persistence: {
 *       type: 'rest',
 *       baseUrl: process.env.REDIS_URL!
 *     }
 *   }
 * };
 */
const objectOverrides: Record<string, Partial<SmrtClassOptions>> = {
  // Add your per-object configuration overrides here
};

/**
 * Default configuration for most SMRT objects
 * Customize this to change project-wide defaults
 */
function getDefaultConfig(): SmrtClassOptions {
  return {
    db: {
      url: process.env.DATABASE_URL || ':memory:',
      type: (process.env.DATABASE_TYPE as 'sqlite' | 'postgres') || 'sqlite'
    },
    ai: process.env.OPENAI_API_KEY ? {
      type: 'openai',
      apiKey: process.env.OPENAI_API_KEY
    } : process.env.ANTHROPIC_API_KEY ? {
      type: 'anthropic',
      apiKey: process.env.ANTHROPIC_API_KEY
    } : undefined
  };
}

/**
 * Get configuration for a specific SMRT object
 * Merges project defaults with per-object overrides if defined
 */
export function getSmrtConfig(className: string): SmrtClassOptions {
  const defaults = getDefaultConfig();
  const override = objectOverrides[className];

  if (override) {
    // Deep merge: override specific properties while keeping defaults
    return {
      ...defaults,
      ...override,
      // Ensure nested objects are merged properly
      db: override.db ? { ...defaults.db, ...override.db } : defaults.db,
      ai: override.ai !== undefined ? override.ai : defaults.ai
    };
  }

  return defaults;
}

/**
 * Helper to get a collection with centralized configuration
 * Automatically applies project defaults or object-specific overrides
 */
export async function getCollection<T>(className: string) {
  return await ObjectRegistry.getCollection<T>(
    className,
    getSmrtConfig(className)
  );
}
`;
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }
  writeFileSync(configFilePath, configContent, "utf-8");
  console.log(`[smrt] Generated configuration file: ${configFilePath}`);
}
async function generateRoutesForObject(projectRoot, className, objectDef, options) {
  const collectionName = objectDef.collection;
  const routeDir = join(projectRoot, options.routesDir, collectionName);
  const apiConfig = objectDef.decoratorConfig?.api;
  if (apiConfig === false) {
    console.log(`[smrt] Skipping ${className} - API disabled`);
    return;
  }
  const standardActions = ["list", "get", "create", "update", "delete"];
  let includedActions = [];
  if (apiConfig === true || apiConfig === void 0) {
    includedActions = [...standardActions];
  } else if (typeof apiConfig === "object") {
    if (apiConfig.include) {
      includedActions = apiConfig.include.filter(
        (action) => standardActions.includes(action)
      );
    } else {
      includedActions = [...standardActions];
    }
    if (apiConfig.exclude && Array.isArray(apiConfig.exclude)) {
      includedActions = includedActions.filter(
        (action) => !apiConfig.exclude?.includes(action)
      );
    }
  }
  if (includedActions.includes("list") || includedActions.includes("create")) {
    const collectionRoute = generateCollectionRouteTemplate(
      projectRoot,
      className,
      objectDef,
      includedActions
    );
    writeRoute(routeDir, "+server.ts", collectionRoute);
  }
  if (includedActions.includes("get") || includedActions.includes("update") || includedActions.includes("delete")) {
    const itemRoute = generateItemRouteTemplate(
      projectRoot,
      className,
      objectDef,
      includedActions,
      options
    );
    writeRoute(join(routeDir, "[id]"), "+server.ts", itemRoute);
  }
  const customActions = Object.entries(objectDef.methods).filter(
    ([name, method]) => !standardActions.includes(name) && method.isPublic && shouldIncludeInApi(name, apiConfig)
  );
  for (const [actionName, actionDef] of customActions) {
    const actionRoute = generateActionRouteTemplate(
      projectRoot,
      className,
      actionName,
      actionDef,
      objectDef,
      options
    );
    writeRoute(join(routeDir, "[id]", actionName), "+server.ts", actionRoute);
  }
}
function shouldIncludeInApi(actionName, apiConfig) {
  if (apiConfig === false) return false;
  if (apiConfig === true || apiConfig === void 0) return true;
  if (typeof apiConfig === "object") {
    if (apiConfig.include) {
      return apiConfig.include.includes(actionName);
    }
    if (apiConfig.exclude) {
      return !apiConfig.exclude.includes(actionName);
    }
  }
  return true;
}
function writeRoute(dir, filename, content) {
  try {
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }
    const filePath = join(dir, filename);
    writeFileSync(filePath, content, "utf-8");
    console.log(`[smrt] Generated: ${filePath}`);
  } catch (error) {
    console.error(`[smrt] [ERROR] Failed to write route file:`);
    console.error(`[smrt] [ERROR]   Directory: ${dir}`);
    console.error(`[smrt] [ERROR]   Filename: ${filename}`);
    console.error(`[smrt] [ERROR]   Error:`, error);
    throw error;
  }
}
function getSvelteKitImportPath(projectRoot, objectFilePath, objectsDir, className) {
  const filePath = objectFilePath || join(projectRoot, objectsDir, `${className || "Object"}.ts`);
  const absoluteObjectsDir = objectsDir.startsWith("/") ? objectsDir : join(projectRoot, objectsDir);
  const relativePath = relative(absoluteObjectsDir, filePath);
  const normalizedPath = relativePath.replace(/\\/g, "/");
  const withoutExtension = normalizedPath.replace(/\.(ts|js|tsx|jsx)$/, "");
  if (objectsDir.includes("src/lib")) {
    const libSubpath = objectsDir.split("src/lib")[1] || "";
    const fullPath = libSubpath ? `${libSubpath}/${withoutExtension}` : withoutExtension;
    return `$lib${fullPath}`.replace(/\/+/g, "/");
  }
  return withoutExtension.startsWith(".") ? withoutExtension : `./${withoutExtension}`;
}
function generateCollectionRouteTemplate(_projectRoot, className, _objectDef, includedActions, _options) {
  const hasGet = includedActions.includes("list");
  const hasPost = includedActions.includes("create");
  const imports = `// Auto-generated by @smrt/core vite plugin
// DO NOT EDIT - changes will be overwritten

import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { getCollection } from '$lib/server/smrt';
// Note: ${className} is auto-registered by the Vite plugin scanner
`;
  const getHandler = hasGet ? `
// List all ${className.toLowerCase()}s
export const GET: RequestHandler = async ({ url }) => {
  const limit = Number(url.searchParams.get('limit')) || 50;
  const offset = Number(url.searchParams.get('offset')) || 0;

  const collection = await getCollection('${className}');
  const items = await collection.list({ limit, offset });
  const count = await collection.count();

  return json({ items, count, limit, offset });
};
` : "";
  const postHandler = hasPost ? `
// Create new ${className.toLowerCase()}
export const POST: RequestHandler = async ({ request }) => {
  const data = await request.json();

  const collection = await getCollection('${className}');
  const item = await collection.create(data);
  await item.save();

  return json(item, { status: 201 });
};
` : "";
  return imports + getHandler + postHandler;
}
function generateItemRouteTemplate(projectRoot, className, objectDef, includedActions, options) {
  const hasGet = includedActions.includes("get");
  const hasPut = includedActions.includes("update");
  const hasDelete = includedActions.includes("delete");
  getSvelteKitImportPath(
    projectRoot,
    objectDef.filePath,
    options.objectsDir,
    className
  );
  const imports = `// Auto-generated by @smrt/core vite plugin
// DO NOT EDIT - changes will be overwritten

import { json, error } from '@sveltejs/kit';
import type { RequestHandler} from './$types';
import { getCollection } from '$lib/server/smrt';
// Note: ${className} is auto-registered by the Vite plugin scanner
`;
  const getHandler = hasGet ? `
// Get single ${className.toLowerCase()}
export const GET: RequestHandler = async ({ params }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  return json(item);
};
` : "";
  const putHandler = hasPut ? `
// Update ${className.toLowerCase()}
export const PUT: RequestHandler = async ({ params, request }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  const data = await request.json();
  Object.assign(item, data);
  await item.save();

  return json(item);
};
` : "";
  const deleteHandler = hasDelete ? `
// Delete ${className.toLowerCase()}
export const DELETE: RequestHandler = async ({ params }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  await item.delete();
  return json({ success: true });
};
` : "";
  return imports + getHandler + putHandler + deleteHandler;
}
function generateActionRouteTemplate(projectRoot, className, actionName, actionDef, objectDef, options) {
  const paramsList = actionDef.parameters.map((p) => p.name).join(", ");
  getSvelteKitImportPath(
    projectRoot,
    objectDef.filePath,
    options.objectsDir,
    className
  );
  return `// Auto-generated by @smrt/core vite plugin
// DO NOT EDIT - changes will be overwritten

import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { getCollection } from '$lib/server/smrt';
// Note: ${className} is auto-registered by the Vite plugin scanner

// Custom action: ${actionName}
export const POST: RequestHandler = async ({ params, request }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  const options = await request.json();
  const result = await item.${actionName}(${paramsList ? "options" : ""});

  return json({ action: '${actionName}', result });
};
`;
}
function updateGitignore(projectRoot, options) {
  const gitignorePath = join(projectRoot, ".gitignore");
  const patternsToAdd = [
    "# SMRT auto-generated routes (from Vite plugin)",
    `${options.routesDir}/**/+server.ts`
  ];
  let gitignoreContent = "";
  if (existsSync(gitignorePath)) {
    gitignoreContent = readFileSync(gitignorePath, "utf-8");
  }
  let needsUpdate = false;
  const linesToAdd = [];
  for (const pattern of patternsToAdd) {
    if (!gitignoreContent.includes(pattern)) {
      linesToAdd.push(pattern);
      needsUpdate = true;
    }
  }
  if (needsUpdate) {
    if (gitignoreContent.length > 0 && !gitignoreContent.endsWith("\n")) {
      gitignoreContent += "\n";
    }
    if (gitignoreContent.length > 0 && !gitignoreContent.endsWith("\n\n")) {
      gitignoreContent += "\n";
    }
    gitignoreContent += `${linesToAdd.join("\n")}
`;
    writeFileSync(gitignorePath, gitignoreContent, "utf-8");
    console.log("[smrt] Updated .gitignore with generated route patterns");
  }
}
const VIRTUAL_MODULES = {
  "@smrt/routes": "smrt:routes",
  "@smrt/client": "smrt:client",
  "@smrt/mcp": "smrt:mcp",
  "@smrt/types": "smrt:types",
  "@smrt/manifest": "smrt:manifest",
  "@smrt/schema": "smrt:schema",
  "@smrt/ui": "smrt:ui",
  "@smrt/cli": "smrt:cli"
};
function smrtPlugin(options = {}) {
  const {
    include = ["src/**/*.ts", "src/**/*.js"],
    exclude = ["**/*.test.ts", "**/*.spec.ts", "**/node_modules/**"],
    hmr = true,
    watch = true,
    generateTypes = true,
    baseClasses = ["SmrtObject", "SmartObject"],
    typeDeclarationsPath = "src/types",
    mode = "auto",
    manifestPath,
    svelteKit = {
      enabled: false,
      routesDir: "src/routes/api",
      objectsDir: "src/lib/objects",
      configPath: "src/lib/server",
      configFileName: "smrt.ts"
    }
  } = options;
  let server;
  let manifest = null;
  let manifestGenerator = null;
  let pluginMode = "server";
  return {
    name: "smrt-auto-service",
    async configResolved(config) {
      if (mode === "auto") {
        const isSSRBuild = config.build?.ssr;
        const isFederationBuild = config.plugins.some(
          (p) => p.name?.includes("federation")
        );
        const isClientBuild = isFederationBuild || !isSSRBuild && config.build?.target === "esnext";
        pluginMode = isClientBuild ? "client" : "server";
      } else {
        pluginMode = mode;
      }
      console.log(`[smrt] Running in ${pluginMode} mode`);
      manifest = await scanAndGenerateManifest();
      if (svelteKit.enabled && manifest) {
        await generateSvelteKitRoutes(config.root, manifest, {
          enabled: svelteKit.enabled,
          routesDir: svelteKit.routesDir || "src/routes/api",
          objectsDir: svelteKit.objectsDir || "src/lib/objects",
          configPath: svelteKit.configPath || "src/lib/server",
          configFileName: svelteKit.configFileName || "smrt.ts"
        });
      }
    },
    async buildStart() {
      manifest = await scanAndGenerateManifest();
    },
    configureServer(devServer) {
      server = devServer;
      devServer.middlewares.use(async (req, res, next) => {
        if (req.url === "/" || req.url === "/index.html") {
          try {
            const { existsSync: existsSync2 } = await import("node:fs");
            const { join: join2 } = await import("node:path");
            const projectRoot = devServer.config.root;
            const indexPath = join2(projectRoot, "index.html");
            if (existsSync2(indexPath)) {
              return next();
            }
            console.log("[smrt] Serving default UI (no index.html found)");
            let html = getDefaultHTML();
            html = await devServer.transformIndexHtml("/", html);
            res.setHeader("Content-Type", "text/html");
            res.end(html);
            return;
          } catch (error) {
            console.error("[smrt] Error serving default HTML:", error);
            return next();
          }
        }
        next();
      });
      if (watch && hmr) {
        const watcher = devServer.watcher;
        watcher.on("change", async (file) => {
          if (await shouldRescan(file)) {
            console.log(`[smrt] Rescanning due to change in ${file}`);
            manifest = await scanAndGenerateManifest();
            if (svelteKit.enabled && manifest && server) {
              await generateSvelteKitRoutes(server.config.root, manifest, {
                enabled: svelteKit.enabled,
                routesDir: svelteKit.routesDir || "src/routes/api",
                objectsDir: svelteKit.objectsDir || "src/lib/objects",
                configPath: svelteKit.configPath || "src/lib/server",
                configFileName: svelteKit.configFileName || "smrt.ts"
              });
            }
            Object.values(VIRTUAL_MODULES).forEach((id) => {
              const module = server?.moduleGraph.getModuleById(id);
              if (module) {
                server?.reloadModule(module);
              }
            });
          }
        });
        watcher.on("add", async (file) => {
          if (await shouldRescan(file)) {
            console.log(`[smrt] Rescanning due to new file ${file}`);
            manifest = await scanAndGenerateManifest();
          }
        });
      }
    },
    resolveId(id) {
      if (id in VIRTUAL_MODULES) {
        return `\0${VIRTUAL_MODULES[id]}`;
      }
      if (id === "/index.html" && server) {
        return `\0smrt:index-html`;
      }
      return null;
    },
    async load(id) {
      const cleanId = id.startsWith("\0") ? id.slice(1) : id;
      if (!manifest) {
        manifest = await scanAndGenerateManifest();
      }
      switch (cleanId) {
        case "smrt:routes":
          return await generateRoutesModule(manifest);
        case "smrt:client":
          return generateClientModule(manifest);
        case "smrt:mcp":
          return await generateMCPModule(manifest);
        case "smrt:types":
          return await generateTypesModule(manifest, pluginMode);
        case "smrt:manifest":
          return generateManifestModule(manifest);
        case "smrt:schema":
          return await generateSchemaModule(manifest);
        case "smrt:ui":
          return await loadDefaultUI();
        case "smrt:index-html":
          return await loadDefaultHTML();
        case "smrt:cli":
          return await generateCLIModule(manifest);
        default:
          return null;
      }
    },
    transformIndexHtml: {
      order: "pre",
      handler: async (html, _ctx) => {
        if (!server) return html;
        try {
          const { existsSync: existsSync2 } = await import("node:fs");
          const { join: join2 } = await import("node:path");
          const projectRoot = server.config.root;
          const indexPath = join2(projectRoot, "index.html");
          if (existsSync2(indexPath)) {
            return html;
          }
          return await loadDefaultHTML();
        } catch (error) {
          console.error("[smrt] Error checking for index.html:", error);
          return html;
        }
      }
    }
  };
  function createEmptyManifest() {
    return {
      version: "1.0.0",
      timestamp: Date.now(),
      objects: {}
    };
  }
  async function scanAndGenerateManifest() {
    if (process.env.NODE_ENV === "production") {
      try {
        const { staticManifest } = await import("./static-manifest-BpxVdLxT.js");
        if (staticManifest && Object.keys(staticManifest.objects).length > 0) {
          console.log("[smrt] Using pre-generated static manifest");
          return staticManifest;
        }
      } catch (_error) {
        console.warn(
          "[smrt] Static manifest not found, falling back to dynamic scanning"
        );
      }
    }
    try {
      const [{ default: fg }, { ASTScanner, ManifestGenerator }] = await Promise.all([import("./index-D2SdCo8s.js").then((n) => n.i), import("./index-vnWPj8WQ.js")]);
      if (!manifestGenerator) {
        manifestGenerator = new ManifestGenerator();
      }
      const sourceFiles = fg.sync(include, {
        ignore: exclude,
        absolute: true
      });
      if (sourceFiles.length === 0) {
        console.warn("[smrt] No source files found matching patterns");
        return createEmptyManifest();
      }
      const scanner = new ASTScanner(sourceFiles, {
        baseClasses,
        includePrivateMethods: false,
        includeStaticMethods: true,
        followImports: false
      });
      const scanResults = scanner.scanFiles();
      const newManifest = manifestGenerator.generateManifest(scanResults);
      const objectCount = Object.keys(newManifest.objects).length;
      if (objectCount > 0) {
        const names = Object.keys(newManifest.objects).join(", ");
        console.log(`[smrt] Found ${objectCount} SMRT objects: ${names}`);
      } else {
        console.log("[smrt] No SMRT objects found");
      }
      if (generateTypes && server) {
        await generateTypeDeclarationFile(
          newManifest,
          server.config.root,
          typeDeclarationsPath
        );
      }
      return newManifest;
    } catch (error) {
      console.error("[smrt] Error scanning files:", error);
      return createEmptyManifest();
    }
  }
  async function shouldRescan(file) {
    if (pluginMode === "client") {
      return false;
    }
    try {
      const { minimatch } = await import("./index-C817Echr.js");
      const isIncluded = include.some((pattern) => minimatch(file, pattern));
      const isExcluded = exclude.some((pattern) => minimatch(file, pattern));
      return isIncluded && !isExcluded;
    } catch (error) {
      console.warn("[smrt] Error checking file patterns:", error);
      return false;
    }
  }
}
async function generateRoutesModule(manifest) {
  try {
    const { ManifestGenerator } = await import("./index-vnWPj8WQ.js");
    const generator = new ManifestGenerator();
    const routes = generator.generateRestEndpoints(manifest);
    return `
// Auto-generated REST routes from SMRT objects
// This file is generated automatically - do not edit

export function setupRoutes(app) {
${routes}
}

export { setupRoutes as default };
`;
  } catch (error) {
    console.warn("[smrt] Error generating routes module:", error);
    return 'export function setupRoutes() { console.warn("Routes generation failed"); }';
  }
}
function generateClientModule(manifest) {
  const objects = Object.entries(manifest.objects);
  const clientMethods = objects.map(([name, obj]) => {
    const { collection } = obj;
    return `
  ${name}: {
    list: (params) => fetch(basePath + '/${collection}', { 
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    }).then(r => r.json()),
    
    get: (id) => fetch(basePath + '/${collection}/' + id, {
      method: 'GET', 
      headers: { 'Content-Type': 'application/json' }
    }).then(r => r.json()),
    
    create: (data) => fetch(basePath + '/${collection}', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    }).then(r => r.json()),
    
    update: (id, data) => fetch(basePath + '/${collection}/' + id, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    }).then(r => r.json()),
    
    delete: (id) => fetch(basePath + '/${collection}/' + id, {
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' }
    }).then(r => r.ok)
  }`;
  }).join(",");
  return `
// Auto-generated API client from SMRT objects
// This file is generated automatically - do not edit

export function createClient(basePath = '/api/v1') {
  return {${clientMethods}
  };
}

export { createClient as default };
`;
}
async function generateMCPModule(manifest) {
  try {
    const { ManifestGenerator } = await import("./index-vnWPj8WQ.js");
    const generator = new ManifestGenerator();
    const tools = generator.generateMCPTools(manifest);
    return `
// Auto-generated MCP tools from SMRT objects  
// This file is generated automatically - do not edit

export const tools = ${tools};

export function createMCPServer() {
  return {
    name: 'smrt-auto-generated',
    version: '1.0.0',
    tools
  };
}

export { createMCPServer as default };
`;
  } catch (error) {
    console.warn("[smrt] Error generating MCP module:", error);
    return 'export const tools = []; export function createMCPServer() { console.warn("MCP generation failed"); return { name: "smrt-client", version: "1.0.0", tools: [] }; }';
  }
}
function generateClientModeTypes(manifest) {
  const typeDefinitions = [];
  for (const [objectName, objectMeta] of Object.entries(manifest.objects)) {
    const fields = objectMeta.fields || {};
    const propertyLines = [];
    for (const [fieldName, fieldDef] of Object.entries(fields)) {
      let type = "any";
      switch (fieldDef.type) {
        case "text":
          type = "string";
          break;
        case "decimal":
        case "integer":
          type = "number";
          break;
        case "boolean":
          type = "boolean";
          break;
        case "datetime":
          type = "string";
          break;
        case "json":
          type = "any";
          break;
        case "foreignKey":
          type = "string";
          break;
        default:
          type = "any";
      }
      const optional = !fieldDef.required ? "?" : "";
      propertyLines.push(`  ${fieldName}${optional}: ${type};`);
    }
    propertyLines.unshift(
      "  id?: string;",
      "  created_at?: string;",
      "  updated_at?: string;"
    );
    const interfaceDef = `export interface ${objectName}Data {
${propertyLines.join("\n")}
}`;
    typeDefinitions.push(interfaceDef);
  }
  return typeDefinitions.join("\n\n");
}
async function generateTypesModule(manifest, mode = "server") {
  let interfaces = "";
  try {
    if (mode !== "client") {
      const { ManifestGenerator } = await import("./index-vnWPj8WQ.js");
      const generator = new ManifestGenerator();
      interfaces = generator.generateTypeDefinitions(manifest);
    } else {
      interfaces = generateClientModeTypes(manifest);
    }
    return `
// Auto-generated TypeScript types from SMRT objects
// This file is generated automatically - do not edit

${interfaces}

export interface Request {
  params: Record<string, string>;
  query: Record<string, any>;
  json(): Promise<any>;
}

export interface Response {
  json(data: any, init?: { status?: number }): Response;
  status(code: number): Response;
}
`;
  } catch (error) {
    console.warn("[smrt] Error generating types module:", error);
    return `
// Auto-generated TypeScript types from SMRT objects (fallback)
// This file is generated automatically - do not edit

export interface Request {
  params: Record<string, string>;
  query: Record<string, any>;
  json(): Promise<any>;
}

export interface Response {
  json(data: any, init?: { status?: number }): Response;
  status(code: number): Response;
}
`;
  }
}
function generateManifestModule(manifest) {
  return `
// Auto-generated manifest from SMRT objects
// This file is generated automatically - do not edit

export const manifest = ${JSON.stringify(manifest, null, 2)};

export { manifest as default };
`;
}
async function generateTypeDeclarationFile(manifest, projectRoot, typeDeclarationsPath) {
  try {
    const [{ join: join2 }, { existsSync: existsSync2, mkdirSync: mkdirSync2, writeFileSync: writeFileSync2 }] = await Promise.all([import("node:path"), import("node:fs")]);
    const declarationsDir = join2(projectRoot, typeDeclarationsPath);
    const declarationsFile = join2(declarationsDir, "virtual-modules.d.ts");
    if (!existsSync2(declarationsDir)) {
      mkdirSync2(declarationsDir, { recursive: true });
    }
    const objectInterfaces = Object.entries(manifest.objects).map(([_name, obj]) => {
      const interfaceName = `${obj.className}Data`;
      const fields = Object.entries(obj.fields).map(([fieldName, field]) => {
        const optional = field.required === false ? "?" : "";
        const type = mapTypeScriptType(field.type);
        return `    ${fieldName}${optional}: ${type};`;
      }).join("\n");
      return `  export interface ${interfaceName} {
    id?: string;
${fields}
    createdAt?: string;
    updatedAt?: string;
  }`;
    }).join("\n\n");
    const collectionNames = [
      ...new Set(Object.values(manifest.objects).map((obj) => obj.collection))
    ];
    const apiClientInterface = collectionNames.map((collection) => {
      const dataType = Object.entries(manifest.objects).find(
        ([, obj]) => obj.collection === collection
      )?.[1].className;
      const interfaceName = dataType ? `${dataType}Data` : "any";
      return `    ${collection}: CrudOperations<${interfaceName}>;`;
    }).join("\n");
    const _mcpTools = Object.entries(manifest.objects).flatMap(
      ([_name, obj]) => Object.entries(obj.methods).map(([methodName, method]) => ({
        name: `${methodName}_${obj.collection}`,
        description: `${method.name} operation on ${obj.collection}`,
        inputSchema: {
          type: "object",
          properties: Object.fromEntries(
            method.parameters.map((param) => [
              param.name,
              { type: mapJsonSchemaType(param.type) }
            ])
          ),
          required: method.parameters.filter((p) => p.optional !== true).map((p) => p.name)
        }
      }))
    );
    const typeDeclarations = `/**
 * Auto-generated TypeScript declarations for SMRT virtual modules
 * Generated from discovered @smrt() decorated classes
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * This file is automatically regenerated when SMRT objects change
 */

// Manifest module - Contains discovered SMRT objects metadata
declare module '@smrt/manifest' {
  export interface SmrtObjectField {
    type: string;
    required?: boolean;
    default?: any;
  }

  export interface SmrtObjectMethod {
    name: string;
    parameters: Array<{
      name: string;
      type: string;
      required?: boolean;
    }>;
    returnType: string;
    isAsync: boolean;
  }

  export interface SmrtObjectDefinition {
    className: string;
    collection: string;
    fields: Record<string, SmrtObjectField>;
    methods: Record<string, SmrtObjectMethod>;
    decoratorConfig: any;
  }

  export interface SmrtManifest {
    version: string;
    timestamp: number;
    objects: Record<string, SmrtObjectDefinition>;
  }

  export const manifest: SmrtManifest;
}

// Routes module - Auto-generated REST route setup
declare module '@smrt/routes' {
  export interface RouteApp {
    get(path: string, handler: (req: any, res: any) => void): void;
    post(path: string, handler: (req: any, res: any) => void): void;
    put(path: string, handler: (req: any, res: any) => void): void;
    delete(path: string, handler: (req: any, res: any) => void): void;
  }

  export function setupRoutes(app: RouteApp): void;
  export default setupRoutes;
}

// Client module - Auto-generated API client  
declare module '@smrt/client' {
  export interface ApiResponse<T = any> {
    id?: string;
    data?: T;
    error?: string;
    message?: string;
  }

  export interface CrudOperations<T = any> {
    list(params?: Record<string, any>): Promise<ApiResponse<T[]>>;
    get(id: string): Promise<ApiResponse<T>>;
    create(data: Partial<T>): Promise<ApiResponse<T>>;
    update(id: string, data: Partial<T>): Promise<ApiResponse<T>>;
    delete(id: string): Promise<boolean>;
  }

  export interface ApiClient {
${apiClientInterface}
  }

  export function createClient(basePath?: string): ApiClient;
  export default createClient;
}

// MCP module - Auto-generated Model Context Protocol tools
declare module '@smrt/mcp' {
  export interface McpTool {
    name: string;
    description: string;
    inputSchema: {
      type: string;
      properties: Record<string, any>;
      required?: string[];
    };
  }

  export const tools: McpTool[];
  export function createMCPServer(): { name: string; version: string; tools: McpTool[] };
  export default tools;
}

// Types module - Auto-generated TypeScript interfaces
declare module '@smrt/types' {
  export const types: string;

  // Auto-generated interfaces for discovered SMRT objects
${objectInterfaces}

  export default types;
}

// CLI module - Auto-generated command-line interface
declare module '@smrt/cli' {
  export interface CLIConfig {
    name?: string;
    version?: string;
    description?: string;
    prompt?: boolean;
    colors?: boolean;
  }

  export interface CLIContext {
    db?: any;
    ai?: any;
    user?: {
      id: string;
      roles?: string[];
    };
  }

  export interface CLICommandMap {
    [objectName: string]: {
      collection: string;
      commands: string[];
    };
  }

  export const cliCommands: CLICommandMap;

  export function setupCLI(config?: CLIConfig, context?: CLIContext): {
    run: (argv: string[]) => Promise<void>;
    generator: any;
  };

  export function getCLIHandler(config?: CLIConfig, context?: CLIContext): (argv: string[]) => Promise<void>;

  export default setupCLI;
}`;
    writeFileSync2(declarationsFile, typeDeclarations);
    console.log(
      `[smrt] Generated TypeScript declarations: ${declarationsFile}`
    );
  } catch (error) {
    console.error("[smrt] Error generating TypeScript declarations:", error);
  }
}
function mapTypeScriptType(smrtType) {
  const typeMap = {
    string: "string",
    number: "number",
    boolean: "boolean",
    array: "any[]",
    object: "Record<string, any>",
    date: "string",
    Date: "string"
  };
  return typeMap[smrtType] || "any";
}
function mapJsonSchemaType(tsType) {
  const typeMap = {
    string: "string",
    number: "number",
    boolean: "boolean",
    array: "array",
    object: "object",
    any: "string"
  };
  return typeMap[tsType] || "string";
}
function getDefaultHTML() {
  const uiScript = getDefaultUIModule();
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>SMRT Development UI</title>\n  <style>\n    * { margin: 0; padding: 0; box-sizing: border-box; }\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;\n      background: #f5f5f5;\n      color: #333;\n    }\n    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }\n    header {\n      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n      color: white;\n      padding: 40px 0;\n      margin-bottom: 40px;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n    }\n    header h1 { font-size: 2.5em; font-weight: 700; margin-bottom: 10px; }\n    .subtitle { font-size: 1.1em; opacity: 0.9; }\n    .stats {\n      display: grid;\n      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n      gap: 20px;\n      margin-bottom: 40px;\n    }\n    .stat-card {\n      background: white;\n      padding: 20px;\n      border-radius: 8px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n      text-align: center;\n    }\n    .stat-value { font-size: 2.5em; font-weight: 700; color: #667eea; margin-bottom: 5px; }\n    .stat-label { font-size: 0.9em; color: #666; text-transform: uppercase; letter-spacing: 1px; }\n    .collections { display: grid; gap: 30px; }\n    .collection-card {\n      background: white;\n      border-radius: 8px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n      overflow: hidden;\n    }\n    .collection-header {\n      background: #667eea;\n      color: white;\n      padding: 15px 20px;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n    }\n    .collection-title { font-size: 1.3em; font-weight: 600; }\n    .collection-count {\n      background: rgba(255,255,255,0.2);\n      padding: 5px 15px;\n      border-radius: 20px;\n      font-size: 0.9em;\n    }\n    .collection-body { padding: 20px; }\n    .field-list {\n      display: grid;\n      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n      gap: 15px;\n      margin-bottom: 20px;\n    }\n    .field {\n      padding: 10px;\n      background: #f8f9fa;\n      border-radius: 4px;\n      border-left: 3px solid #667eea;\n    }\n    .field-name { font-weight: 600; color: #333; margin-bottom: 3px; }\n    .field-type { font-size: 0.85em; color: #666; }\n    .actions { display: flex; gap: 10px; flex-wrap: wrap; }\n    .btn {\n      padding: 10px 20px;\n      border: none;\n      border-radius: 4px;\n      font-size: 0.9em;\n      cursor: pointer;\n      transition: all 0.2s;\n      text-decoration: none;\n      display: inline-block;\n    }\n    .btn-primary { background: #667eea; color: white; }\n    .btn-primary:hover { background: #5568d3; transform: translateY(-1px); }\n    .btn-secondary { background: #e0e0e0; color: #333; }\n    .btn-secondary:hover { background: #d0d0d0; }\n    .loading { text-align: center; padding: 40px; color: #666; }\n    .error {\n      background: #fee;\n      border: 1px solid #fcc;\n      color: #c33;\n      padding: 15px;\n      border-radius: 4px;\n      margin-bottom: 20px;\n    }\n    .empty-state { text-align: center; padding: 60px 20px; color: #999; }\n    .empty-state svg { width: 100px; height: 100px; margin-bottom: 20px; opacity: 0.3; }\n  </style>\n</head>\n<body>\n  <div id="app">\n    <div class="loading">Loading SMRT UI...</div>\n  </div>\n  <script type="module">\n' + uiScript + "\n  <\/script>\n</body>\n</html>";
}
function getDefaultUIModule() {
  try {
    const __dirname = dirname(fileURLToPath(import.meta.url));
    const templatePath = join(__dirname, "templates/default-ui.js");
    return readFileSync(templatePath, "utf-8").trim();
  } catch (error) {
    console.error("[smrt] Error loading UI template:", error);
    return `
async function createUI() {
  const app = document.getElementById('app');
  if (!app) return;
  app.innerHTML = '<div class="container" style="padding:40px;text-align:center;"><h1>ðŸŽ¯ SMRT Development UI</h1><p>Template file not found. UI code could not be loaded.</p></div>';
}
createUI();
`;
  }
}
async function loadDefaultHTML() {
  return getDefaultHTML();
}
async function loadDefaultUI() {
  return getDefaultUIModule();
}
async function generateCLIModule(manifest) {
  try {
    const commands = [];
    const objectImports = [];
    for (const [className, objectDef] of Object.entries(manifest.objects)) {
      const config = objectDef.decoratorConfig;
      const cliConfig = config?.cli;
      if (cliConfig === false) continue;
      const excluded = (typeof cliConfig === "object" ? cliConfig.exclude : []) || [];
      const included = typeof cliConfig === "object" ? cliConfig.include : null;
      const shouldInclude = (command) => {
        if (included && !included.includes(command)) return false;
        if (excluded.includes(command)) return false;
        return true;
      };
      const collectionName = objectDef.collection;
      objectImports.push(
        `// Import ${className} and ${className}Collection for CLI operations`
      );
      const availableCommands = [];
      if (shouldInclude("list"))
        availableCommands.push(`'${collectionName}:list'`);
      if (shouldInclude("get"))
        availableCommands.push(`'${collectionName}:get'`);
      if (shouldInclude("create"))
        availableCommands.push(`'${collectionName}:create'`);
      if (shouldInclude("update"))
        availableCommands.push(`'${collectionName}:update'`);
      if (shouldInclude("delete"))
        availableCommands.push(`'${collectionName}:delete'`);
      for (const [methodName, _method] of Object.entries(objectDef.methods)) {
        if (methodName.startsWith("_") || ["list", "get", "create", "update", "delete", "save"].includes(
          methodName
        ))
          continue;
        if (shouldInclude(methodName)) {
          availableCommands.push(`'${collectionName}:${methodName}'`);
        }
      }
      if (availableCommands.length > 0) {
        commands.push(`
  // ${className} commands
  ${className}: {
    collection: '${collectionName}',
    commands: [${availableCommands.join(", ")}]
  }`);
      }
    }
    return `
// Auto-generated CLI module from SMRT objects
// This file is generated automatically - do not edit

import { CLIGenerator } from '@smrt/core/generators/cli';

/**
 * @typedef {import('@smrt/core/generators/cli').CLIConfig} CLIConfig
 * @typedef {import('@smrt/core/generators/cli').CLIContext} CLIContext
 */

${objectImports.join("\n")}

/**
 * Available CLI commands by object
 */
export const cliCommands = {${commands.join(",\n")}
};

/**
 * Setup CLI with auto-generated commands
 *
 * @param {CLIConfig} [config={}] - CLI configuration
 * @param {CLIContext} [context={}] - CLI context
 * @returns {{run: function(string[]): Promise<void>, generator: *}}
 *
 * @example
 * import { setupCLI } from '@smrt/cli';
 *
 * const cli = setupCLI({
 *   name: 'my-app',
 *   version: '1.0.0'
 * });
 *
 * cli.run(process.argv);
 */
export function setupCLI(config = {}, context = {}) {
  const generator = new CLIGenerator(config, context);
  return {
    run: async (argv) => {
      const handler = generator.generateHandler();
      await handler(argv.slice(2)); // Remove 'node' and script name
    },
    generator
  };
}

/**
 * Get CLI handler directly
 *
 * @param {CLIConfig} [config={}] - CLI configuration
 * @param {CLIContext} [context={}] - CLI context
 * @returns {function(string[]): Promise<void>}
 */
export function getCLIHandler(config = {}, context = {}) {
  const generator = new CLIGenerator(config, context);
  return generator.generateHandler();
}

export default setupCLI;
`;
  } catch (error) {
    console.warn("[smrt] Error generating CLI module:", error);
    return `
// Error generating CLI module
export const cliCommands = {};
export function setupCLI() {
  console.warn("CLI generation failed");
  return { run: async () => {} };
}
export function getCLIHandler() {
  return async () => console.warn("CLI generation failed");
}
export default setupCLI;
`;
  }
}
async function generateSchemaModule(manifest) {
  try {
    const { SchemaGenerator } = await import("./index-NeQe5WqD.js");
    const schemaGenerator = new SchemaGenerator();
    const schemas = {};
    for (const [className, objectDef] of Object.entries(manifest.objects)) {
      const schema = schemaGenerator.generateSchema(objectDef);
      schemas[className] = schema;
    }
    const schemaManifest = {
      version: "1.0.0",
      timestamp: Date.now(),
      packageName: manifest.packageName || "unknown",
      schemas,
      dependencies: Array.from(
        new Set(
          Object.values(schemas).flatMap((s) => s.dependencies || [])
        )
      )
    };
    return `// Auto-generated schema manifest from SMRT objects
// This file is generated automatically - do not edit

// Schema manifest as JSON for SQL adapters
export const schemaManifest = ${JSON.stringify(schemaManifest, null, 2)};

// Schema registry for runtime access
export const schemas = schemaManifest.schemas;

// Schema lookup function
export function getSchema(className: string) {
  return schemas[className];
}

// All schemas as array for dependency resolution
export const allSchemas = Object.values(schemas);

// Package information
export const packageName = schemaManifest.packageName;
export const dependencies = schemaManifest.dependencies;

export default schemaManifest;`;
  } catch (error) {
    console.error("[smrt] Error generating schema module:", error);
    return `// Error generating schema module
export const schemaManifest = { schemas: {}, dependencies: [] };
export const schemas = {};
export function getSchema() { return null; }
export const allSchemas = [];
export default {};`;
  }
}
export {
  smrtPlugin as s
};
//# sourceMappingURL=index-CzyD6vtS.js.map
