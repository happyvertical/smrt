/**
 * Place model - Core entity for hierarchical place management
 *
 * Supports both real-world places with geo data and abstract places
 * (virtual worlds, game zones) by making all geo fields optional.
 */

import { SmrtObject, smrt } from '@smrt/core';
import type { GeoData, PlaceOptions } from '../types';

@smrt({
  api: { include: ['list', 'get', 'create', 'update', 'delete'] },
  mcp: { include: ['list', 'get', 'create', 'update'] },
  cli: true,
})
export class Place extends SmrtObject {
  // id: UUID (auto-generated by SmrtObject)

  // Core fields
  typeId = ''; // FK to PlaceType
  parentId = ''; // FK to parent Place for hierarchy (nullable)
  name = ''; // Place name/title
  description = ''; // Optional description

  // Optional geo fields (all nullable for abstract places)
  latitude: number | null = null;
  longitude: number | null = null;
  streetNumber = '';
  streetName = '';
  city = '';
  region = '';
  country = '';
  postalCode = '';
  countryCode = '';
  timezone = '';

  // Metadata
  externalId = ''; // External system identifier
  source = ''; // Where this place came from (e.g., 'google', 'osm')
  metadata = ''; // JSON metadata stored as text

  // Timestamps
  createdAt = new Date();
  updatedAt = new Date();

  constructor(options: PlaceOptions = {}) {
    super(options);

    // Core fields
    if (options.typeId) this.typeId = options.typeId;
    if (options.parentId !== undefined) this.parentId = options.parentId;
    if (options.name) this.name = options.name;
    if (options.description !== undefined)
      this.description = options.description;

    // Geo fields
    if (options.latitude !== undefined) this.latitude = options.latitude;
    if (options.longitude !== undefined) this.longitude = options.longitude;
    if (options.streetNumber !== undefined)
      this.streetNumber = options.streetNumber;
    if (options.streetName !== undefined) this.streetName = options.streetName;
    if (options.city !== undefined) this.city = options.city;
    if (options.region !== undefined) this.region = options.region;
    if (options.country !== undefined) this.country = options.country;
    if (options.postalCode !== undefined) this.postalCode = options.postalCode;
    if (options.countryCode !== undefined)
      this.countryCode = options.countryCode;
    if (options.timezone !== undefined) this.timezone = options.timezone;

    // Metadata
    if (options.externalId !== undefined) this.externalId = options.externalId;
    if (options.source !== undefined) this.source = options.source;

    // Handle metadata - can be object or JSON string
    if (options.metadata !== undefined) {
      if (typeof options.metadata === 'string') {
        this.metadata = options.metadata;
      } else {
        this.metadata = JSON.stringify(options.metadata);
      }
    }

    // Timestamps
    if (options.createdAt) this.createdAt = options.createdAt;
    if (options.updatedAt) this.updatedAt = options.updatedAt;
  }

  /**
   * Get geographic data for this place
   *
   * @returns GeoData object with all geo fields
   */
  getGeoData(): GeoData {
    return {
      latitude: this.latitude,
      longitude: this.longitude,
      streetNumber: this.streetNumber || undefined,
      streetName: this.streetName || undefined,
      city: this.city || undefined,
      region: this.region || undefined,
      country: this.country || undefined,
      postalCode: this.postalCode || undefined,
      countryCode: this.countryCode || undefined,
      timezone: this.timezone || undefined,
    };
  }

  /**
   * Check if this place has geographic coordinates
   *
   * @returns True if latitude and longitude are set
   */
  hasCoordinates(): boolean {
    return this.latitude !== null && this.longitude !== null;
  }

  /**
   * Get metadata as parsed object
   *
   * @returns Parsed metadata object or empty object if no metadata
   */
  getMetadata(): Record<string, any> {
    if (!this.metadata) return {};
    try {
      return JSON.parse(this.metadata);
    } catch {
      return {};
    }
  }

  /**
   * Set metadata from object
   *
   * @param data - Metadata object to store
   */
  setMetadata(data: Record<string, any>): void {
    this.metadata = JSON.stringify(data);
  }

  /**
   * Update metadata by merging with existing values
   *
   * @param updates - Partial metadata to merge
   */
  updateMetadata(updates: Record<string, any>): void {
    const current = this.getMetadata();
    this.setMetadata({ ...current, ...updates });
  }

  /**
   * Get the place type
   *
   * @returns PlaceType instance or null if not found
   */
  async getType() {
    if (!this.typeId) return null;

    const { PlaceTypeCollection } = await import(
      '../collections/PlaceTypeCollection'
    );
    const collection = await (PlaceTypeCollection as any).create(this.options);

    return await collection.get({ id: this.typeId });
  }

  /**
   * Get the parent place
   *
   * @returns Parent Place instance or null if no parent
   */
  async getParent(): Promise<Place | null> {
    if (!this.parentId) return null;

    const { PlaceCollection } = await import('../collections/PlaceCollection');
    const collection = await (PlaceCollection as any).create(this.options);

    return await collection.get({ id: this.parentId });
  }

  /**
   * Get immediate child places
   *
   * @returns Array of child Place instances
   */
  async getChildren(): Promise<Place[]> {
    const { PlaceCollection } = await import('../collections/PlaceCollection');
    const collection = await (PlaceCollection as any).create(this.options);

    return await collection.list({ where: { parentId: this.id } });
  }

  /**
   * Get all ancestor places (recursive)
   *
   * @returns Array of ancestor places from root to immediate parent
   */
  async getAncestors(): Promise<Place[]> {
    const ancestors: Place[] = [];
    let currentPlace: Place | null = this;

    while (currentPlace?.parentId) {
      const parent = await currentPlace.getParent();
      if (!parent) break;
      ancestors.unshift(parent); // Add to beginning
      currentPlace = parent;
    }

    return ancestors;
  }

  /**
   * Get all descendant places (recursive)
   *
   * @returns Array of all descendant places
   */
  async getDescendants(): Promise<Place[]> {
    const children = await this.getChildren();
    const descendants: Place[] = [...children];

    for (const child of children) {
      const childDescendants = await child.getDescendants();
      descendants.push(...childDescendants);
    }

    return descendants;
  }

  /**
   * Get full hierarchy for this place
   *
   * @returns PlaceHierarchy with ancestors, current, and descendants
   */
  async getHierarchy(): Promise<{
    ancestors: Place[];
    current: Place;
    descendants: Place[];
  }> {
    const [ancestors, descendants] = await Promise.all([
      this.getAncestors(),
      this.getDescendants(),
    ]);

    return {
      ancestors,
      current: this,
      descendants,
    };
  }
}
