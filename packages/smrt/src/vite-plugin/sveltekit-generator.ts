/**
 * SvelteKit route auto-generation from SMRT objects
 * Generates real TypeScript files in src/routes/api/ based on discovered SMRT objects
 */

import {
  writeFileSync,
  mkdirSync,
  existsSync,
  readFileSync,
  statSync,
} from 'node:fs';
import { join, dirname, relative } from 'node:path';
import type {
  SmartObjectManifest,
  SmartObjectDefinition,
} from '../scanner/types';

export interface SvelteKitOptions {
  enabled: boolean;
  routesDir: string;
  objectsDir: string;
  configPath?: string; // default: 'src/lib/server'
  configFileName?: string; // default: 'smrt.ts'
}

/**
 * Generates SvelteKit API routes from manifest
 */
export async function generateSvelteKitRoutes(
  projectRoot: string,
  manifest: SmartObjectManifest,
  options: SvelteKitOptions,
): Promise<void> {
  if (!options.enabled) return;

  console.log('[smrt] Generating SvelteKit routes...');

  // Generate centralized configuration file first (if it doesn't exist)
  await generateSmrtConfigFile(projectRoot, manifest, options);

  for (const [className, objectDef] of Object.entries(manifest.objects)) {
    await generateRoutesForObject(projectRoot, className, objectDef, options);
  }

  // Update .gitignore to exclude generated routes
  updateGitignore(projectRoot, options);

  console.log(
    `[smrt] Generated routes for ${Object.keys(manifest.objects).length} SMRT objects`,
  );
}

/**
 * Generates SMRT object registration file
 * This file imports all SMRT objects to trigger their @smrt() decorators
 */
async function generateRegistrationFile(
  projectRoot: string,
  manifest: SmartObjectManifest,
  options: SvelteKitOptions,
): Promise<void> {
  const configPath = options.configPath || 'src/lib/server';
  const configDir = join(projectRoot, configPath);
  const registrationFilePath = join(configDir, 'smrt-register.ts');

  const imports = Object.entries(manifest.objects)
    .map(([className, objectDef]) => {
      const importPath = getSvelteKitImportPath(
        projectRoot,
        objectDef.filePath,
        options.objectsDir,
        className,
      );
      const actualClassName = importPath.split('/').pop()!;
      return `import { ${actualClassName} } from '${importPath}';`;
    })
    .join('\n');

  const registrationContent = `/**
 * Auto-generated SMRT object registration
 * DO NOT EDIT - changes will be overwritten
 *
 * This file imports all SMRT objects to trigger their @smrt() decorators
 * and register them in the ObjectRegistry.
 */

${imports}

// Objects are registered automatically when imported via @smrt() decorator
`;

  // Create directory if it doesn't exist
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }

  writeFileSync(registrationFilePath, registrationContent, 'utf-8');
  console.log(`[smrt] Generated registration file: ${registrationFilePath}`);
}

/**
 * Generates centralized SMRT configuration file
 * Only creates if file doesn't exist (preserves user customizations)
 */
async function generateSmrtConfigFile(
  projectRoot: string,
  manifest: SmartObjectManifest,
  options: SvelteKitOptions,
): Promise<void> {
  const configPath = options.configPath || 'src/lib/server';
  const configFileName = options.configFileName || 'smrt.ts';
  const configDir = join(projectRoot, configPath);
  const configFilePath = join(configDir, configFileName);

  // Always generate registration file (it gets overwritten)
  await generateRegistrationFile(projectRoot, manifest, options);

  // Don't overwrite existing config file
  if (existsSync(configFilePath)) {
    console.log('[smrt] Config file already exists, skipping generation');
    return;
  }

  const configContent = `/**
 * Centralized SMRT configuration with per-object overrides
 * Generated by @have/smrt vite plugin
 *
 * Most objects will use the default configuration.
 * Add entries to \`objectOverrides\` for objects that need different backends.
 */

// Import SMRT objects to register them via @smrt() decorators
import './smrt-register.js';

import { ObjectRegistry } from '@have/smrt';
import type { SmrtClassOptions } from '@have/smrt';

/**
 * Per-object configuration overrides
 * Define specific backends for objects that differ from project defaults
 *
 * @example
 * const objectOverrides: Record<string, Partial<SmrtClassOptions>> = {
 *   // Analytics uses a separate PostgreSQL database
 *   Analytics: {
 *     db: {
 *       url: process.env.ANALYTICS_DATABASE_URL!,
 *       type: 'postgres'
 *     }
 *   },
 *
 *   // AuditLog uses dedicated database with no AI
 *   AuditLog: {
 *     db: {
 *       url: process.env.AUDIT_DATABASE_URL!,
 *       type: 'postgres'
 *     },
 *     ai: undefined
 *   },
 *
 *   // Cache uses REST adapter (e.g., Redis)
 *   Cache: {
 *     persistence: {
 *       type: 'rest',
 *       baseUrl: process.env.REDIS_URL!
 *     }
 *   }
 * };
 */
const objectOverrides: Record<string, Partial<SmrtClassOptions>> = {
  // Add your per-object configuration overrides here
};

/**
 * Default configuration for most SMRT objects
 * Customize this to change project-wide defaults
 */
function getDefaultConfig(): SmrtClassOptions {
  return {
    db: {
      url: process.env.DATABASE_URL || ':memory:',
      type: (process.env.DATABASE_TYPE as 'sqlite' | 'postgres') || 'sqlite'
    },
    ai: process.env.OPENAI_API_KEY ? {
      type: 'openai',
      apiKey: process.env.OPENAI_API_KEY
    } : process.env.ANTHROPIC_API_KEY ? {
      type: 'anthropic',
      apiKey: process.env.ANTHROPIC_API_KEY
    } : undefined
  };
}

/**
 * Get configuration for a specific SMRT object
 * Merges project defaults with per-object overrides if defined
 */
export function getSmrtConfig(className: string): SmrtClassOptions {
  const defaults = getDefaultConfig();
  const override = objectOverrides[className];

  if (override) {
    // Deep merge: override specific properties while keeping defaults
    return {
      ...defaults,
      ...override,
      // Ensure nested objects are merged properly
      db: override.db ? { ...defaults.db, ...override.db } : defaults.db,
      ai: override.ai !== undefined ? override.ai : defaults.ai
    };
  }

  return defaults;
}

/**
 * Helper to get a collection with centralized configuration
 * Automatically applies project defaults or object-specific overrides
 */
export async function getCollection<T>(className: string) {
  return await ObjectRegistry.getCollection<T>(
    className,
    getSmrtConfig(className)
  );
}
`;

  // Create directory if it doesn't exist
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }

  writeFileSync(configFilePath, configContent, 'utf-8');
  console.log(`[smrt] Generated configuration file: ${configFilePath}`);
}

/**
 * Generates route files for a single SMRT object
 */
async function generateRoutesForObject(
  projectRoot: string,
  className: string,
  objectDef: SmartObjectDefinition,
  options: SvelteKitOptions,
): Promise<void> {
  const collectionName = objectDef.collection;
  const routeDir = join(projectRoot, options.routesDir, collectionName);

  // Check if API is enabled for this object
  const apiConfig = objectDef.decoratorConfig?.api;
  if (apiConfig === false) {
    console.log(`[smrt] Skipping ${className} - API disabled`);
    return;
  }

  // Determine which actions to include
  const standardActions = ['list', 'get', 'create', 'update', 'delete'];
  let includedActions: string[] = [];

  if (apiConfig === true || apiConfig === undefined) {
    // Include all standard actions by default
    includedActions = [...standardActions];
  } else if (typeof apiConfig === 'object') {
    if (apiConfig.include) {
      includedActions = apiConfig.include.filter((action) =>
        standardActions.includes(action),
      );
    } else {
      includedActions = [...standardActions];
    }

    if (apiConfig.exclude && Array.isArray(apiConfig.exclude)) {
      includedActions = includedActions.filter(
        (action) => !apiConfig.exclude!.includes(action),
      );
    }
  }

  // Generate collection route (list, create)
  if (includedActions.includes('list') || includedActions.includes('create')) {
    const collectionRoute = generateCollectionRouteTemplate(
      projectRoot,
      className,
      objectDef,
      includedActions,
      options,
    );
    writeRoute(routeDir, '+server.ts', collectionRoute);
  }

  // Generate item route (get, update, delete)
  if (
    includedActions.includes('get') ||
    includedActions.includes('update') ||
    includedActions.includes('delete')
  ) {
    const itemRoute = generateItemRouteTemplate(
      projectRoot,
      className,
      objectDef,
      includedActions,
      options,
    );
    writeRoute(join(routeDir, '[id]'), '+server.ts', itemRoute);
  }

  // Generate custom action routes
  const customActions = Object.entries(objectDef.methods).filter(
    ([name, method]) =>
      !standardActions.includes(name) &&
      method.isPublic &&
      shouldIncludeInApi(name, apiConfig),
  );

  for (const [actionName, actionDef] of customActions) {
    const actionRoute = generateActionRouteTemplate(
      projectRoot,
      className,
      actionName,
      actionDef,
      objectDef,
      options,
    );
    writeRoute(join(routeDir, '[id]', actionName), '+server.ts', actionRoute);
  }
}

/**
 * Check if a custom action should be included in API
 */
function shouldIncludeInApi(actionName: string, apiConfig: any): boolean {
  if (apiConfig === false) return false;
  if (apiConfig === true || apiConfig === undefined) return true;

  if (typeof apiConfig === 'object') {
    if (apiConfig.include) {
      return apiConfig.include.includes(actionName);
    }
    if (apiConfig.exclude) {
      return !apiConfig.exclude.includes(actionName);
    }
  }

  return true;
}

/**
 * Writes a route file, creating directories as needed
 */
function writeRoute(dir: string, filename: string, content: string): void {
  try {
    // Create directory if needed
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true });
    }

    // Write the file (writeFileSync is synchronous and will throw on failure)
    const filePath = join(dir, filename);
    writeFileSync(filePath, content, 'utf-8');
    console.log(`[smrt] Generated: ${filePath}`);
  } catch (error) {
    console.error(`[smrt] [ERROR] Failed to write route file:`);
    console.error(`[smrt] [ERROR]   Directory: ${dir}`);
    console.error(`[smrt] [ERROR]   Filename: ${filename}`);
    console.error(`[smrt] [ERROR]   Error:`, error);
    throw error;
  }
}

/**
 * Converts absolute file path to SvelteKit $lib alias import
 * For SvelteKit projects, uses $lib alias for better module resolution
 */
function getSvelteKitImportPath(
  projectRoot: string,
  objectFilePath: string | undefined,
  objectsDir: string,
  className?: string,
): string {
  // Handle undefined filePath by generating a default path
  // This allows tests to work without providing explicit file paths
  const filePath =
    objectFilePath ||
    join(projectRoot, objectsDir, `${className || 'Object'}.ts`);

  // Convert objectsDir to absolute path if it's relative
  const absoluteObjectsDir = objectsDir.startsWith('/')
    ? objectsDir
    : join(projectRoot, objectsDir);

  // Get the relative path from objectsDir to the file
  const relativePath = relative(absoluteObjectsDir, filePath);

  // Convert to forward slashes and remove extension
  const normalizedPath = relativePath.replace(/\\/g, '/');
  const withoutExtension = normalizedPath.replace(/\.(ts|js|tsx|jsx)$/, '');

  // If objectsDir is under src/lib, use $lib alias
  if (objectsDir.includes('src/lib')) {
    const libSubpath = objectsDir.split('src/lib')[1] || '';
    const fullPath = libSubpath
      ? `${libSubpath}/${withoutExtension}`
      : withoutExtension;
    return `$lib${fullPath}`.replace(/\/+/g, '/'); // Clean up double slashes
  }

  // Otherwise use relative path (fallback for non-standard layouts)
  return withoutExtension.startsWith('.')
    ? withoutExtension
    : `./${withoutExtension}`;
}

/**
 * Generates collection route template (GET list, POST create)
 */
function generateCollectionRouteTemplate(
  projectRoot: string,
  className: string,
  objectDef: SmartObjectDefinition,
  includedActions: string[],
  options: SvelteKitOptions,
): string {
  const hasGet = includedActions.includes('list');
  const hasPost = includedActions.includes('create');

  const imports = `// Auto-generated by @have/smrt vite plugin
// DO NOT EDIT - changes will be overwritten

import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { getCollection } from '$lib/server/smrt';
// Note: ${className} is auto-registered by the Vite plugin scanner
`;

  const getHandler = hasGet
    ? `
// List all ${className.toLowerCase()}s
export const GET: RequestHandler = async ({ url }) => {
  const limit = Number(url.searchParams.get('limit')) || 50;
  const offset = Number(url.searchParams.get('offset')) || 0;

  const collection = await getCollection('${className}');
  const items = await collection.list({ limit, offset });
  const count = await collection.count();

  return json({ items, count, limit, offset });
};
`
    : '';

  const postHandler = hasPost
    ? `
// Create new ${className.toLowerCase()}
export const POST: RequestHandler = async ({ request }) => {
  const data = await request.json();

  const collection = await getCollection('${className}');
  const item = await collection.create(data);
  await item.save();

  return json(item, { status: 201 });
};
`
    : '';

  return imports + getHandler + postHandler;
}

/**
 * Generates item route template (GET, PUT, DELETE)
 */
function generateItemRouteTemplate(
  projectRoot: string,
  className: string,
  objectDef: SmartObjectDefinition,
  includedActions: string[],
  options: SvelteKitOptions,
): string {
  const hasGet = includedActions.includes('get');
  const hasPut = includedActions.includes('update');
  const hasDelete = includedActions.includes('delete');

  // Calculate import path using $lib alias for SvelteKit
  const importPath = getSvelteKitImportPath(
    projectRoot,
    objectDef.filePath,
    options.objectsDir,
    className,
  );

  const imports = `// Auto-generated by @have/smrt vite plugin
// DO NOT EDIT - changes will be overwritten

import { json, error } from '@sveltejs/kit';
import type { RequestHandler} from './$types';
import { getCollection } from '$lib/server/smrt';
// Note: ${className} is auto-registered by the Vite plugin scanner
`;

  const getHandler = hasGet
    ? `
// Get single ${className.toLowerCase()}
export const GET: RequestHandler = async ({ params }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  return json(item);
};
`
    : '';

  const putHandler = hasPut
    ? `
// Update ${className.toLowerCase()}
export const PUT: RequestHandler = async ({ params, request }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  const data = await request.json();
  Object.assign(item, data);
  await item.save();

  return json(item);
};
`
    : '';

  const deleteHandler = hasDelete
    ? `
// Delete ${className.toLowerCase()}
export const DELETE: RequestHandler = async ({ params }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  await item.delete();
  return json({ success: true });
};
`
    : '';

  return imports + getHandler + putHandler + deleteHandler;
}

/**
 * Generates custom action route template
 */
function generateActionRouteTemplate(
  projectRoot: string,
  className: string,
  actionName: string,
  actionDef: any,
  objectDef: SmartObjectDefinition,
  options: SvelteKitOptions,
): string {
  const paramsList = actionDef.parameters.map((p: any) => p.name).join(', ');

  // Calculate import path using $lib alias for SvelteKit
  const importPath = getSvelteKitImportPath(
    projectRoot,
    objectDef.filePath,
    options.objectsDir,
    className,
  );

  return `// Auto-generated by @have/smrt vite plugin
// DO NOT EDIT - changes will be overwritten

import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { getCollection } from '$lib/server/smrt';
// Note: ${className} is auto-registered by the Vite plugin scanner

// Custom action: ${actionName}
export const POST: RequestHandler = async ({ params, request }) => {
  const collection = await getCollection('${className}');
  const item = await collection.get(params.id);
  if (!item) throw error(404, '${className} not found');

  const options = await request.json();
  const result = await item.${actionName}(${paramsList ? 'options' : ''});

  return json({ action: '${actionName}', result });
};
`;
}

/**
 * Updates .gitignore to exclude auto-generated routes
 */
function updateGitignore(projectRoot: string, options: SvelteKitOptions): void {
  const gitignorePath = join(projectRoot, '.gitignore');

  // Patterns to add
  const patternsToAdd = [
    '# SMRT auto-generated routes (from Vite plugin)',
    `${options.routesDir}/**/+server.ts`,
  ];

  // Read existing .gitignore or create empty string
  let gitignoreContent = '';
  if (existsSync(gitignorePath)) {
    gitignoreContent = readFileSync(gitignorePath, 'utf-8');
  }

  // Check if patterns already exist
  let needsUpdate = false;
  const linesToAdd: string[] = [];

  for (const pattern of patternsToAdd) {
    // Skip if pattern already exists (check for exact match or similar)
    if (!gitignoreContent.includes(pattern)) {
      linesToAdd.push(pattern);
      needsUpdate = true;
    }
  }

  if (needsUpdate) {
    // Ensure file ends with newline before adding
    if (gitignoreContent.length > 0 && !gitignoreContent.endsWith('\n')) {
      gitignoreContent += '\n';
    }

    // Add a blank line before our section if file has content
    if (gitignoreContent.length > 0 && !gitignoreContent.endsWith('\n\n')) {
      gitignoreContent += '\n';
    }

    // Add our patterns
    gitignoreContent += linesToAdd.join('\n') + '\n';

    writeFileSync(gitignorePath, gitignoreContent, 'utf-8');
    console.log('[smrt] Updated .gitignore with generated route patterns');
  }
}
