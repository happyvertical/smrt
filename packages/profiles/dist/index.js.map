{"version":3,"file":"index.js","sources":["../src/models/ProfileType.ts","../src/models/Profile.ts","../src/collections/ProfileCollection.ts","../src/models/ProfileMetadata.ts","../src/collections/ProfileMetadataCollection.ts","../src/models/ProfileMetafield.ts","../src/collections/ProfileMetafieldCollection.ts","../src/models/ProfileRelationship.ts","../src/collections/ProfileRelationshipCollection.ts","../src/models/ProfileRelationshipTerm.ts","../src/collections/ProfileRelationshipTermCollection.ts","../src/models/ProfileRelationshipType.ts","../src/collections/ProfileRelationshipTypeCollection.ts","../src/collections/ProfileTypeCollection.ts"],"sourcesContent":["/**\n * ProfileType model - Lookup table defining profile types\n *\n * Represents the nature of a profile (e.g., 'human', 'org', 'robot').\n * Uses UUID primary key with unique slug for human-readable lookups.\n */\n\nimport { SmrtObject, type SmrtObjectOptions, smrt, text } from '@smrt/core';\n\nexport interface ProfileTypeOptions extends SmrtObjectOptions {\n  slug?: string;\n  name?: string;\n  description?: string;\n}\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update'] },\n  mcp: { include: ['list', 'get'] },\n  cli: true,\n})\nexport class ProfileType extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  // slug is inherited from SmrtObject (auto-generated from name)\n  name = text({ required: true });\n  description = text();\n\n  constructor(options: ProfileTypeOptions = {}) {\n    super(options);\n    // Field values are automatically set by initializePropertiesFromOptions()\n    // No need to manually assign Field properties here\n  }\n\n  /**\n   * Convenience method for slug-based lookup\n   *\n   * @param slug - The slug to search for\n   * @returns ProfileType instance or null if not found\n   */\n  static async getBySlug(slug: string): Promise<ProfileType | null> {\n    // Will be auto-implemented by SMRT\n    return null;\n  }\n}\n","/**\n * Profile model - Core entity representing any profile type\n *\n * Central table holding all primary entities with type, email, name, and description.\n * Uses UUID primary key with relationships to ProfileType for classification.\n */\n\nimport {\n  foreignKey,\n  oneToMany,\n  SmrtObject,\n  type SmrtObjectOptions,\n  smrt,\n  text,\n} from '@smrt/core';\nimport { ProfileType } from './ProfileType';\n\nexport interface ProfileOptions extends SmrtObjectOptions {\n  typeId?: string;\n  email?: string;\n  name?: string;\n  description?: string;\n}\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class Profile extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  typeId = foreignKey('ProfileType', { required: true }); // References ProfileType.id\n  email = text({ unique: true }); // Optional email address\n  name = text({ required: true }); // Display name\n  description = text(); // Short bio or description\n\n  // Relationships (not stored as columns)\n  metadata = oneToMany('ProfileMetadata');\n  relationshipsFrom = oneToMany('ProfileRelationship');\n  relationshipsTo = oneToMany('ProfileRelationship');\n\n  constructor(options: ProfileOptions = {}) {\n    super(options);\n    // Field values are automatically set by initializePropertiesFromOptions()\n    // No need to manually assign Field properties here\n  }\n\n  /**\n   * Get the profile type slug for this profile\n   *\n   * @returns The slug of the profile type\n   */\n  async getTypeSlug(): Promise<string> {\n    const type = await this.loadRelated('typeId');\n    return type?.slug || '';\n  }\n\n  /**\n   * Set the profile type by slug\n   *\n   * @param slug - The slug of the profile type\n   * @throws Error if profile type not found\n   */\n  async setTypeBySlug(slug: string): Promise<void> {\n    const type = await ProfileType.getBySlug(slug);\n    if (!type) throw new Error(`Profile type '${slug}' not found`);\n    this.typeId.value = type.id;\n  }\n\n  /**\n   * Add metadata to this profile\n   *\n   * @param metafieldSlug - The slug of the metafield\n   * @param value - The value to set\n   */\n  async addMetadata(metafieldSlug: string, value: any): Promise<void> {\n    const { ProfileMetafieldCollection } = await import(\n      '../collections/ProfileMetafieldCollection'\n    );\n    const { ProfileMetadataCollection } = await import(\n      '../collections/ProfileMetadataCollection'\n    );\n\n    // Get or create metafield collection\n    const metafieldCollection = await ProfileMetafieldCollection.create(\n      this.options,\n    );\n\n    // Find the metafield by slug\n    const metafield = await metafieldCollection.getBySlug(metafieldSlug);\n    if (!metafield) {\n      throw new Error(`Metafield '${metafieldSlug}' not found`);\n    }\n\n    // Validate the value\n    await metafield.validateValue(value);\n\n    // Get or create metadata collection\n    const metadataCollection = await ProfileMetadataCollection.create(\n      this.options,\n    );\n\n    // Check if metadata already exists\n    const existing = await metadataCollection.list({\n      where: { profileId: this.id, metafieldId: metafield.id },\n      limit: 1,\n    });\n\n    if (existing.length > 0) {\n      // Update existing\n      const metadata = existing[0];\n      metadata.value = String(value);\n      await metadata.save();\n    } else {\n      // Create new\n      const metadata = await metadataCollection.create({\n        profileId: this.id,\n        metafieldId: metafield.id,\n        value: String(value),\n      });\n      await metadata.save();\n    }\n  }\n\n  /**\n   * Get all metadata for this profile as key-value object\n   *\n   * @returns Object with metafield slugs as keys\n   */\n  async getMetadata(): Promise<Record<string, any>> {\n    const { ProfileMetadataCollection } = await import(\n      '../collections/ProfileMetadataCollection'\n    );\n\n    const metadataCollection = await ProfileMetadataCollection.create(\n      this.options,\n    );\n\n    return await metadataCollection.getMetadataObject(this.id);\n  }\n\n  /**\n   * Update multiple metadata values\n   *\n   * @param metadata - Object with metafield slugs as keys and values\n   */\n  async updateMetadata(metadata: Record<string, any>): Promise<void> {\n    for (const [metafieldSlug, value] of Object.entries(metadata)) {\n      await this.addMetadata(metafieldSlug, value);\n    }\n  }\n\n  /**\n   * Remove metadata by metafield slug\n   *\n   * @param metafieldSlug - The slug of the metafield to remove\n   */\n  async removeMetadata(metafieldSlug: string): Promise<void> {\n    const { ProfileMetafieldCollection } = await import(\n      '../collections/ProfileMetafieldCollection'\n    );\n    const { ProfileMetadataCollection } = await import(\n      '../collections/ProfileMetadataCollection'\n    );\n\n    const metafieldCollection = await ProfileMetafieldCollection.create(\n      this.options,\n    );\n\n    const metafield = await metafieldCollection.getBySlug(metafieldSlug);\n    if (!metafield) {\n      throw new Error(`Metafield '${metafieldSlug}' not found`);\n    }\n\n    const metadataCollection = await ProfileMetadataCollection.create(\n      this.options,\n    );\n\n    const existing = await metadataCollection.list({\n      where: { profileId: this.id, metafieldId: metafield.id },\n      limit: 1,\n    });\n\n    if (existing.length > 0) {\n      await existing[0].delete();\n    }\n  }\n\n  /**\n   * Add a relationship to another profile\n   *\n   * @param toProfile - The target profile\n   * @param relationshipSlug - The type of relationship\n   * @param contextProfile - Optional context profile for tertiary relationships\n   */\n  async addRelationship(\n    toProfile: Profile,\n    relationshipSlug: string,\n    contextProfile?: Profile,\n  ): Promise<void> {\n    const { ProfileRelationshipTypeCollection } = await import(\n      '../collections/ProfileRelationshipTypeCollection'\n    );\n    const { ProfileRelationshipCollection } = await import(\n      '../collections/ProfileRelationshipCollection'\n    );\n    const { ProfileRelationshipType } = await import(\n      './ProfileRelationshipType'\n    );\n\n    // Get relationship type\n    const relationshipTypeCollection =\n      await ProfileRelationshipTypeCollection.create(this.options);\n\n    const relationshipType =\n      await relationshipTypeCollection.getBySlug(relationshipSlug);\n    if (!relationshipType) {\n      throw new Error(`Relationship type '${relationshipSlug}' not found`);\n    }\n\n    // Check if relationship already exists\n    const relationshipCollection = await ProfileRelationshipCollection.create(\n      this.options,\n    );\n\n    const exists = await relationshipCollection.exists(\n      this.id,\n      toProfile.id,\n      relationshipType.id,\n    );\n\n    if (!exists) {\n      // Create the relationship\n      const relationship = await relationshipCollection.create({\n        fromProfileId: this.id,\n        toProfileId: toProfile.id,\n        typeId: relationshipType.id,\n        contextProfileId: contextProfile?.id,\n      });\n      await relationship.save();\n    }\n\n    // Handle reciprocal relationships\n    if (relationshipType.reciprocal) {\n      const handler =\n        ProfileRelationshipType.getReciprocalHandler(relationshipSlug);\n      if (handler) {\n        await handler(this, toProfile, contextProfile);\n      }\n    }\n  }\n\n  /**\n   * Get all relationships for this profile\n   *\n   * @param options - Filter options (typeSlug, direction)\n   * @returns Array of ProfileRelationship instances\n   */\n  async getRelationships(options?: {\n    typeSlug?: string;\n    direction?: 'from' | 'to' | 'all';\n  }): Promise<ProfileRelationship[]> {\n    const { ProfileRelationshipCollection } = await import(\n      '../collections/ProfileRelationshipCollection'\n    );\n    const { ProfileRelationshipTypeCollection } = await import(\n      '../collections/ProfileRelationshipTypeCollection'\n    );\n\n    const relationshipCollection = await ProfileRelationshipCollection.create(\n      this.options,\n    );\n\n    const direction = options?.direction || 'all';\n\n    // Get type ID if typeSlug is provided\n    let typeId: string | undefined;\n    if (options?.typeSlug) {\n      const relationshipTypeCollection =\n        await ProfileRelationshipTypeCollection.create(this.options);\n\n      const relationshipType = await relationshipTypeCollection.getBySlug(\n        options.typeSlug,\n      );\n      typeId = relationshipType?.id;\n    }\n\n    // Fetch relationships based on direction\n    if (direction === 'from') {\n      return await relationshipCollection.getFromProfile(this.id, typeId);\n    } else if (direction === 'to') {\n      return await relationshipCollection.getToProfile(this.id, typeId);\n    } else {\n      return await relationshipCollection.getForProfile(this.id, typeId);\n    }\n  }\n\n  /**\n   * Get related profiles\n   *\n   * @param relationshipSlug - Optional filter by relationship type slug\n   * @returns Array of related Profile instances\n   */\n  async getRelatedProfiles(relationshipSlug?: string): Promise<Profile[]> {\n    const { ProfileCollection } = await import(\n      '../collections/ProfileCollection'\n    );\n\n    const relationships = await this.getRelationships({\n      typeSlug: relationshipSlug,\n      direction: 'all',\n    });\n\n    const profileCollection = await ProfileCollection.create(this.options);\n\n    const relatedProfiles: Profile[] = [];\n    const seenIds = new Set<string>();\n\n    for (const relationship of relationships) {\n      // Get the other profile (not this one)\n      // Convert Field instances to strings for comparison\n      const fromId = String(relationship.fromProfileId);\n      const toId = String(relationship.toProfileId);\n      const thisId = String(this.id);\n      const otherId = fromId === thisId ? toId : fromId;\n\n      if (!seenIds.has(otherId)) {\n        seenIds.add(otherId);\n        const profile = await profileCollection.get({ id: otherId });\n        if (profile) {\n          relatedProfiles.push(profile);\n        }\n      }\n    }\n\n    return relatedProfiles;\n  }\n\n  /**\n   * Remove a relationship to another profile\n   *\n   * @param toProfile - The target profile\n   * @param relationshipSlug - The type of relationship to remove\n   */\n  async removeRelationship(\n    toProfile: Profile,\n    relationshipSlug: string,\n  ): Promise<void> {\n    const { ProfileRelationshipTypeCollection } = await import(\n      '../collections/ProfileRelationshipTypeCollection'\n    );\n    const { ProfileRelationshipCollection } = await import(\n      '../collections/ProfileRelationshipCollection'\n    );\n\n    // Get relationship type\n    const relationshipTypeCollection =\n      await ProfileRelationshipTypeCollection.create(this.options);\n\n    const relationshipType =\n      await relationshipTypeCollection.getBySlug(relationshipSlug);\n    if (!relationshipType) {\n      throw new Error(`Relationship type '${relationshipSlug}' not found`);\n    }\n\n    // Find and delete the relationship\n    const relationshipCollection = await ProfileRelationshipCollection.create(\n      this.options,\n    );\n\n    const relationships = await relationshipCollection.list({\n      where: {\n        fromProfileId: this.id,\n        toProfileId: toProfile.id,\n        typeId: relationshipType.id,\n      },\n    });\n\n    for (const relationship of relationships) {\n      await relationship.delete();\n    }\n\n    // Handle reciprocal relationships - delete the inverse\n    if (relationshipType.reciprocal) {\n      const inverseRelationships = await relationshipCollection.list({\n        where: {\n          fromProfileId: toProfile.id,\n          toProfileId: this.id,\n          typeId: relationshipType.id,\n        },\n      });\n\n      for (const relationship of inverseRelationships) {\n        await relationship.delete();\n      }\n    }\n  }\n\n  /**\n   * AI-powered: Generate a professional bio for this profile\n   *\n   * @returns Generated bio text\n   */\n  async generateBio(): Promise<string> {\n    return await this.do('Write a short, professional bio for this person.');\n  }\n\n  /**\n   * AI-powered: Check if profile matches criteria\n   *\n   * @param criteria - Criteria to match against\n   * @returns True if matches criteria\n   */\n  async matches(criteria: string): Promise<boolean> {\n    return await this.is(criteria);\n  }\n\n  /**\n   * Find profiles by metadata key-value pair\n   *\n   * @param metafieldSlug - The metafield slug to search\n   * @param value - The value to match\n   * @returns Array of matching profiles\n   */\n  static async findByMetadata(\n    metafieldSlug: string,\n    value: any,\n  ): Promise<Profile[]> {\n    // Will be auto-implemented by SMRT\n    return [];\n  }\n\n  /**\n   * Find profiles by type slug\n   *\n   * @param typeSlug - The profile type slug\n   * @returns Array of matching profiles\n   */\n  static async findByType(typeSlug: string): Promise<Profile[]> {\n    // Will be auto-implemented by SMRT\n    return [];\n  }\n\n  /**\n   * Find related profiles for a given profile\n   *\n   * @param profileId - The profile UUID\n   * @param relationshipSlug - Optional filter by relationship type\n   * @returns Array of related profiles\n   */\n  static async findRelated(\n    profileId: string,\n    relationshipSlug?: string,\n  ): Promise<Profile[]> {\n    // Will be auto-implemented by SMRT\n    return [];\n  }\n\n  /**\n   * Search profiles by email\n   *\n   * @param email - The email to search for\n   * @returns Profile or null if not found\n   */\n  static async searchByEmail(email: string): Promise<Profile | null> {\n    // Will be auto-implemented by SMRT\n    return null;\n  }\n}\n","/**\n * ProfileCollection - Collection manager for Profile objects\n *\n * Provides advanced querying and batch operations for Profile entities.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { Profile } from '../models/Profile';\n\nexport class ProfileCollection extends SmrtCollection<Profile> {\n  static readonly _itemClass = Profile;\n\n  /**\n   * Find profiles by type slug\n   *\n   * @param typeSlug - The profile type slug to filter by\n   * @returns Array of matching profiles\n   */\n  async findByType(typeSlug: string): Promise<Profile[]> {\n    // Will use eager loading when available\n    const allProfiles = await this.list({});\n\n    const filtered: Profile[] = [];\n    for (const profile of allProfiles) {\n      const slug = await profile.getTypeSlug();\n      if (slug === typeSlug) {\n        filtered.push(profile);\n      }\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Batch get metadata for multiple profiles\n   *\n   * @param profileIds - Array of profile UUIDs\n   * @returns Map of profile ID to metadata object\n   */\n  async batchGetMetadata(\n    profileIds: string[],\n  ): Promise<Map<string, Record<string, any>>> {\n    const result = new Map<string, Record<string, any>>();\n\n    for (const profileId of profileIds) {\n      const profile = await this.get({ id: profileId });\n      if (profile) {\n        const metadata = await profile.getMetadata();\n        result.set(profileId, metadata);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Batch update metadata for multiple profiles\n   *\n   * @param updates - Array of { profileId, data } objects\n   */\n  async batchUpdateMetadata(\n    updates: Array<{ profileId: string; data: Record<string, any> }>,\n  ): Promise<void> {\n    for (const update of updates) {\n      const profile = await this.get({ id: update.profileId });\n      if (profile) {\n        await profile.updateMetadata(update.data);\n      }\n    }\n  }\n\n  /**\n   * Find related profiles for a given profile\n   *\n   * @param profileId - The profile UUID\n   * @param relationshipSlug - Optional filter by relationship type\n   * @returns Array of related profiles\n   */\n  async findRelated(\n    profileId: string,\n    relationshipSlug?: string,\n  ): Promise<Profile[]> {\n    const profile = await this.get({ id: profileId });\n    if (!profile) return [];\n\n    return await profile.getRelatedProfiles(relationshipSlug);\n  }\n\n  /**\n   * Get the relationship network for a profile up to a maximum depth\n   *\n   * @param profileId - The starting profile UUID\n   * @param options - Configuration options\n   * @returns Map of profile ID to depth level\n   */\n  async getRelationshipNetwork(\n    profileId: string,\n    options: { maxDepth?: number } = {},\n  ): Promise<Map<string, number>> {\n    const maxDepth = options.maxDepth || 2;\n    const network = new Map<string, number>();\n    const visited = new Set<string>();\n    const queue: Array<{ id: string; depth: number }> = [\n      { id: profileId, depth: 0 },\n    ];\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n\n      if (visited.has(current.id) || current.depth > maxDepth) {\n        continue;\n      }\n\n      visited.add(current.id);\n      network.set(current.id, current.depth);\n\n      if (current.depth < maxDepth) {\n        const related = await this.findRelated(current.id);\n        for (const profile of related) {\n          if (!visited.has(profile.id)) {\n            queue.push({ id: profile.id, depth: current.depth + 1 });\n          }\n        }\n      }\n    }\n\n    return network;\n  }\n}\n","/**\n * ProfileMetadata model - Stores metadata values for profiles\n *\n * Links profiles to metafield definitions with actual values.\n * Uses UUID primary key with foreign keys to Profile and ProfileMetafield.\n */\n\nimport {\n  foreignKey,\n  SmrtObject,\n  type SmrtObjectOptions,\n  smrt,\n  text,\n} from '@smrt/core';\n\nexport interface ProfileMetadataOptions extends SmrtObjectOptions {\n  profileId?: string;\n  metafieldId?: string;\n  value?: string;\n}\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get'] },\n  cli: true,\n})\nexport class ProfileMetadata extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  profileId = foreignKey('Profile', { required: true }); // References Profile.id\n  metafieldId = foreignKey('ProfileMetafield', { required: true }); // References ProfileMetafield.id\n  value = text({ required: true }); // The metadata value (stored as text)\n\n  constructor(options: ProfileMetadataOptions = {}) {\n    super(options);\n    // Field values are automatically set by initializePropertiesFromOptions()\n    // No need to manually assign Field properties here\n  }\n\n  /**\n   * Validate this metadata value against the metafield's validation schema\n   *\n   * @returns True if valid, throws error if invalid\n   */\n  async validate(): Promise<boolean> {\n    const metafield = await this.loadRelated('metafieldId');\n    if (!metafield) {\n      throw new Error('Metafield not found');\n    }\n\n    return await metafield.validateValue(this.value);\n  }\n\n  /**\n   * Get the metafield slug for this metadata\n   *\n   * @returns The slug of the metafield\n   */\n  async getMetafieldSlug(): Promise<string> {\n    const metafield = await this.loadRelated('metafieldId');\n    return metafield?.slug || '';\n  }\n}\n","/**\n * ProfileMetadataCollection - Collection manager for ProfileMetadata objects\n *\n * Provides querying and batch operations for profile metadata.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { ProfileMetadata } from '../models/ProfileMetadata';\n\nexport class ProfileMetadataCollection extends SmrtCollection<ProfileMetadata> {\n  static readonly _itemClass = ProfileMetadata;\n\n  /**\n   * Get all metadata for a profile\n   *\n   * @param profileId - The profile UUID\n   * @returns Array of ProfileMetadata instances\n   */\n  async getByProfile(profileId: string): Promise<ProfileMetadata[]> {\n    return await this.list({ where: { profileId } });\n  }\n\n  /**\n   * Get metadata as key-value object for a profile\n   *\n   * @param profileId - The profile UUID\n   * @returns Object with metafield slugs as keys\n   */\n  async getMetadataObject(profileId: string): Promise<Record<string, any>> {\n    const metadata = await this.getByProfile(profileId);\n    const result: Record<string, any> = {};\n\n    for (const item of metadata) {\n      const slug = await item.getMetafieldSlug();\n      if (slug) {\n        result[slug] = item.value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Find all profiles with a specific metadata key-value pair\n   *\n   * @param metafieldId - The metafield UUID\n   * @param value - The value to match\n   * @returns Array of profile UUIDs\n   */\n  async findProfilesByMetadata(\n    metafieldId: string,\n    value: any,\n  ): Promise<string[]> {\n    const matches = await this.list({\n      where: { metafieldId, value: String(value) },\n    });\n\n    return matches.map((m) => m.profileId);\n  }\n}\n","/**\n * ProfileMetafield model - Controlled vocabulary for metadata fields\n *\n * Defines allowed metadata keys with validation rules.\n * Uses UUID primary key with unique slug for human-readable lookups.\n */\n\nimport {\n  json,\n  SmrtObject,\n  type SmrtObjectOptions,\n  smrt,\n  text,\n} from '@smrt/core';\nimport type { ValidationSchema, ValidatorFunction } from '../types';\n\nexport interface ProfileMetafieldOptions extends SmrtObjectOptions {\n  slug?: string;\n  name?: string;\n  description?: string;\n  validation?: ValidationSchema;\n}\n\n/**\n * Registry of custom validator functions\n */\nconst customValidators = new Map<string, ValidatorFunction>();\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update'] },\n  mcp: { include: ['list', 'get'] },\n  cli: true,\n})\nexport class ProfileMetafield extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  // slug is inherited from SmrtObject (auto-generated from name)\n  name = text({ required: true });\n  description = text();\n  validation = json(); // Validation schema as JSON\n\n  constructor(options: ProfileMetafieldOptions = {}) {\n    super(options);\n    // Field values are automatically set by initializePropertiesFromOptions()\n    // No need to manually assign Field properties here\n  }\n\n  /**\n   * Convenience method for slug-based lookup\n   *\n   * @param slug - The slug to search for\n   * @returns ProfileMetafield instance or null if not found\n   */\n  static async getBySlug(slug: string): Promise<ProfileMetafield | null> {\n    // Will be auto-implemented by SMRT\n    return null;\n  }\n\n  /**\n   * Register a custom validator function\n   *\n   * @param name - Name of the validator (used in validation.custom field)\n   * @param validator - The validator function\n   */\n  static registerValidator(name: string, validator: ValidatorFunction): void {\n    customValidators.set(name, validator);\n  }\n\n  /**\n   * Get a registered custom validator\n   *\n   * @param name - Name of the validator\n   * @returns The validator function or undefined\n   */\n  static getValidator(name: string): ValidatorFunction | undefined {\n    return customValidators.get(name);\n  }\n\n  /**\n   * Validate a value against this metafield's validation schema\n   *\n   * @param value - The value to validate\n   * @returns True if valid, throws ValidationError if invalid\n   */\n  async validateValue(value: any): Promise<boolean> {\n    if (!this.validation) return true;\n\n    const schema = this.validation as ValidationSchema;\n\n    // Type validation\n    if (schema.type) {\n      const actualType = typeof value;\n      const expectedType = schema.type;\n\n      if (expectedType === 'number' && actualType !== 'number') {\n        throw new Error(\n          schema.message || `Expected ${expectedType}, got ${actualType}`,\n        );\n      }\n      if (expectedType === 'string' && actualType !== 'string') {\n        throw new Error(\n          schema.message || `Expected ${expectedType}, got ${actualType}`,\n        );\n      }\n      if (expectedType === 'boolean' && actualType !== 'boolean') {\n        throw new Error(\n          schema.message || `Expected ${expectedType}, got ${actualType}`,\n        );\n      }\n    }\n\n    // String validations\n    if (schema.pattern && typeof value === 'string') {\n      const regex = new RegExp(schema.pattern);\n      if (!regex.test(value)) {\n        throw new Error(schema.message || 'Pattern validation failed');\n      }\n    }\n\n    if (schema.minLength && typeof value === 'string') {\n      if (value.length < schema.minLength) {\n        throw new Error(\n          schema.message ||\n            `Minimum length is ${schema.minLength}, got ${value.length}`,\n        );\n      }\n    }\n\n    if (schema.maxLength && typeof value === 'string') {\n      if (value.length > schema.maxLength) {\n        throw new Error(\n          schema.message ||\n            `Maximum length is ${schema.maxLength}, got ${value.length}`,\n        );\n      }\n    }\n\n    // Numeric validations\n    if (schema.min !== undefined && typeof value === 'number') {\n      if (value < schema.min) {\n        throw new Error(\n          schema.message || `Value must be at least ${schema.min}`,\n        );\n      }\n    }\n\n    if (schema.max !== undefined && typeof value === 'number') {\n      if (value > schema.max) {\n        throw new Error(\n          schema.message || `Value must be at most ${schema.max}`,\n        );\n      }\n    }\n\n    // Custom validator\n    if (schema.custom) {\n      const validator = ProfileMetafield.getValidator(schema.custom);\n      if (!validator) {\n        throw new Error(`Custom validator '${schema.custom}' not registered`);\n      }\n\n      const result = await validator(value);\n      if (!result) {\n        throw new Error(schema.message || 'Custom validation failed');\n      }\n    }\n\n    return true;\n  }\n}\n","/**\n * ProfileMetafieldCollection - Collection manager for ProfileMetafield objects\n *\n * Provides querying for profile metafield lookup table.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { ProfileMetafield } from '../models/ProfileMetafield';\nimport type { ValidationSchema } from '../types';\n\nexport class ProfileMetafieldCollection extends SmrtCollection<ProfileMetafield> {\n  static readonly _itemClass = ProfileMetafield;\n\n  /**\n   * Get metafield by slug\n   *\n   * @param slug - The slug to search for\n   * @returns ProfileMetafield instance or null\n   */\n  async getBySlug(slug: string): Promise<ProfileMetafield | null> {\n    return await this.get({ slug });\n  }\n\n  /**\n   * Get or create a metafield by slug\n   *\n   * @param slug - The slug to search for\n   * @param defaults - Default values if creating\n   * @returns ProfileMetafield instance\n   */\n  async getOrCreateBySlug(\n    slug: string,\n    defaults: {\n      name: string;\n      description?: string;\n      validation?: ValidationSchema;\n    },\n  ): Promise<ProfileMetafield> {\n    const existing = await this.getBySlug(slug);\n    if (existing) return existing;\n\n    const metafield = await this.create({ slug, ...defaults });\n    await metafield.save();\n    return metafield;\n  }\n}\n","/**\n * ProfileRelationship model - Connects two profiles with a relationship type\n *\n * Represents directional or reciprocal relationships between profiles.\n * Uses UUID primary key with foreign keys to profiles and relationship type.\n */\n\nimport {\n  foreignKey,\n  oneToMany,\n  SmrtObject,\n  type SmrtObjectOptions,\n  smrt,\n} from '@smrt/core';\nimport type { ProfileRelationshipTerm } from './ProfileRelationshipTerm';\n\nexport interface ProfileRelationshipOptions extends SmrtObjectOptions {\n  fromProfileId?: string;\n  toProfileId?: string;\n  typeId?: string;\n  contextProfileId?: string;\n}\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'delete'] },\n  mcp: { include: ['list', 'get'] },\n  cli: true,\n})\nexport class ProfileRelationship extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  fromProfileId = foreignKey('Profile', { required: true }); // Origin profile\n  toProfileId = foreignKey('Profile', { required: true }); // Target profile\n  typeId = foreignKey('ProfileRelationshipType', { required: true }); // Relationship type\n  contextProfileId = foreignKey('Profile'); // Optional tertiary context\n\n  // Relationships\n  terms = oneToMany('ProfileRelationshipTerm');\n\n  constructor(options: ProfileRelationshipOptions = {}) {\n    super(options);\n    // Field values are automatically set by initializePropertiesFromOptions()\n    // No need to manually assign Field properties here\n  }\n\n  /**\n   * Get the relationship type slug\n   *\n   * @returns The slug of the relationship type\n   */\n  async getTypeSlug(): Promise<string> {\n    const type = await this.loadRelated('typeId');\n    return type?.slug || '';\n  }\n\n  /**\n   * Add a term (time period) to this relationship\n   *\n   * @param startedAt - Start date of the term\n   * @param endedAt - Optional end date of the term\n   */\n  async addTerm(startedAt: Date, endedAt?: Date): Promise<void> {\n    const { ProfileRelationshipTermCollection } = await import(\n      '../collections/ProfileRelationshipTermCollection'\n    );\n\n    const termCollection = await ProfileRelationshipTermCollection.create(\n      this.options,\n    );\n\n    const term = await termCollection.create({\n      relationshipId: this.id,\n      startedAt,\n      endedAt,\n    });\n\n    await term.save();\n  }\n\n  /**\n   * End the current active term\n   *\n   * @param endedAt - End date for the term\n   */\n  async endCurrentTerm(endedAt: Date): Promise<void> {\n    const activeTerm = await this.getActiveTerm();\n    if (activeTerm) {\n      await activeTerm.end(endedAt);\n    }\n  }\n\n  /**\n   * Get all terms for this relationship\n   *\n   * @returns Array of ProfileRelationshipTerm instances\n   */\n  async getTerms(): Promise<ProfileRelationshipTerm[]> {\n    const { ProfileRelationshipTermCollection } = await import(\n      '../collections/ProfileRelationshipTermCollection'\n    );\n\n    const termCollection = await ProfileRelationshipTermCollection.create(\n      this.options,\n    );\n\n    return await termCollection.getByRelationship(this.id);\n  }\n\n  /**\n   * Get the active term (no end date)\n   *\n   * @returns Current term or null if none active\n   */\n  async getActiveTerm(): Promise<ProfileRelationshipTerm | null> {\n    const { ProfileRelationshipTermCollection } = await import(\n      '../collections/ProfileRelationshipTermCollection'\n    );\n\n    const termCollection = await ProfileRelationshipTermCollection.create(\n      this.options,\n    );\n\n    return await termCollection.getActiveTerm(this.id);\n  }\n}\n","/**\n * ProfileRelationshipCollection - Collection manager for ProfileRelationship objects\n *\n * Provides querying for relationships between profiles.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { ProfileRelationship } from '../models/ProfileRelationship';\n\nexport class ProfileRelationshipCollection extends SmrtCollection<ProfileRelationship> {\n  static readonly _itemClass = ProfileRelationship;\n\n  /**\n   * Get all relationships from a profile\n   *\n   * @param fromProfileId - The origin profile UUID\n   * @param typeId - Optional filter by relationship type UUID\n   * @returns Array of ProfileRelationship instances\n   */\n  async getFromProfile(\n    fromProfileId: string,\n    typeId?: string,\n  ): Promise<ProfileRelationship[]> {\n    const where: any = { fromProfileId };\n    if (typeId) where.typeId = typeId;\n\n    return await this.list({ where });\n  }\n\n  /**\n   * Get all relationships to a profile\n   *\n   * @param toProfileId - The target profile UUID\n   * @param typeId - Optional filter by relationship type UUID\n   * @returns Array of ProfileRelationship instances\n   */\n  async getToProfile(\n    toProfileId: string,\n    typeId?: string,\n  ): Promise<ProfileRelationship[]> {\n    const where: any = { toProfileId };\n    if (typeId) where.typeId = typeId;\n\n    return await this.list({ where });\n  }\n\n  /**\n   * Get all relationships for a profile (both directions)\n   *\n   * @param profileId - The profile UUID\n   * @param typeId - Optional filter by relationship type UUID\n   * @returns Array of ProfileRelationship instances\n   */\n  async getForProfile(\n    profileId: string,\n    typeId?: string,\n  ): Promise<ProfileRelationship[]> {\n    const fromRelationships = await this.getFromProfile(profileId, typeId);\n    const toRelationships = await this.getToProfile(profileId, typeId);\n\n    return [...fromRelationships, ...toRelationships];\n  }\n\n  /**\n   * Check if a relationship exists between two profiles\n   *\n   * @param fromProfileId - The origin profile UUID\n   * @param toProfileId - The target profile UUID\n   * @param typeId - The relationship type UUID\n   * @returns True if relationship exists\n   */\n  async exists(\n    fromProfileId: string,\n    toProfileId: string,\n    typeId: string,\n  ): Promise<boolean> {\n    const matches = await this.list({\n      where: { fromProfileId, toProfileId, typeId },\n      limit: 1,\n    });\n\n    return matches.length > 0;\n  }\n}\n","/**\n * ProfileRelationshipTerm model - Temporal data for relationships\n *\n * Defines the duration or terms of a specific relationship.\n * Uses UUID primary key with foreign key to ProfileRelationship.\n */\n\nimport {\n  datetime,\n  foreignKey,\n  SmrtObject,\n  type SmrtObjectOptions,\n  smrt,\n} from '@smrt/core';\n\nexport interface ProfileRelationshipTermOptions extends SmrtObjectOptions {\n  relationshipId?: string;\n  startedAt?: Date;\n  endedAt?: Date;\n}\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get'] },\n  cli: true,\n})\nexport class ProfileRelationshipTerm extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  relationshipId = foreignKey('ProfileRelationship', { required: true }); // References ProfileRelationship.id\n  startedAt = datetime({ required: true }); // Start date of the term\n  endedAt = datetime(); // Optional end date\n\n  constructor(options: ProfileRelationshipTermOptions = {}) {\n    super(options);\n    // Field values are automatically set by initializePropertiesFromOptions()\n    // No need to manually assign Field properties here\n  }\n\n  /**\n   * Check if this term is currently active\n   *\n   * @returns True if active (no end date or end date in future)\n   */\n  isActive(): boolean {\n    if (!this.endedAt) return true;\n    // Convert Field to Date for comparison\n    const endDate =\n      this.endedAt instanceof Date\n        ? this.endedAt\n        : new Date(String(this.endedAt));\n    return endDate > new Date();\n  }\n\n  /**\n   * End this term\n   *\n   * @param endedAt - End date for the term (defaults to now)\n   */\n  async end(endedAt: Date = new Date()): Promise<void> {\n    // Assign to Field.value\n    (this.endedAt as any).value = endedAt;\n    await this.save();\n  }\n\n  /**\n   * Get the duration of this term in days\n   *\n   * @returns Duration in days\n   */\n  getDurationDays(): number {\n    // Convert Field instances to Date objects\n    const endValue = this.endedAt\n      ? this.endedAt instanceof Date\n        ? this.endedAt\n        : new Date(String(this.endedAt))\n      : new Date();\n    const startValue =\n      this.startedAt instanceof Date\n        ? this.startedAt\n        : new Date(String(this.startedAt));\n    const diffMs = endValue.getTime() - startValue.getTime();\n    return Math.floor(diffMs / (1000 * 60 * 60 * 24));\n  }\n}\n","/**\n * ProfileRelationshipTermCollection - Collection manager for ProfileRelationshipTerm objects\n *\n * Provides querying for relationship terms (temporal data).\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { ProfileRelationshipTerm } from '../models/ProfileRelationshipTerm';\n\nexport class ProfileRelationshipTermCollection extends SmrtCollection<ProfileRelationshipTerm> {\n  static readonly _itemClass = ProfileRelationshipTerm;\n\n  /**\n   * Get all terms for a relationship\n   *\n   * @param relationshipId - The relationship UUID\n   * @returns Array of ProfileRelationshipTerm instances\n   */\n  async getByRelationship(\n    relationshipId: string,\n  ): Promise<ProfileRelationshipTerm[]> {\n    return await this.list({\n      where: { relationshipId },\n      orderBy: ['startedAt DESC'],\n    });\n  }\n\n  /**\n   * Get the active term for a relationship (no end date or future end date)\n   *\n   * @param relationshipId - The relationship UUID\n   * @returns Active term or null\n   */\n  async getActiveTerm(\n    relationshipId: string,\n  ): Promise<ProfileRelationshipTerm | null> {\n    const terms = await this.getByRelationship(relationshipId);\n\n    for (const term of terms) {\n      if (term.isActive()) {\n        return term;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get all historical (ended) terms for a relationship\n   *\n   * @param relationshipId - The relationship UUID\n   * @returns Array of ended ProfileRelationshipTerm instances\n   */\n  async getHistoricalTerms(\n    relationshipId: string,\n  ): Promise<ProfileRelationshipTerm[]> {\n    const terms = await this.getByRelationship(relationshipId);\n    return terms.filter((term) => !term.isActive());\n  }\n}\n","/**\n * ProfileRelationshipType model - Lookup table for relationship types\n *\n * Defines the kinds of relationships that can exist between profiles.\n * Uses UUID primary key with unique slug for human-readable lookups.\n */\n\nimport {\n  boolean,\n  SmrtObject,\n  type SmrtObjectOptions,\n  smrt,\n  text,\n} from '@smrt/core';\nimport type { ReciprocalHandler } from '../types';\n\nexport interface ProfileRelationshipTypeOptions extends SmrtObjectOptions {\n  slug?: string;\n  name?: string;\n  reciprocal?: boolean;\n}\n\n/**\n * Registry of reciprocal relationship handlers\n */\nconst reciprocalHandlers = new Map<string, ReciprocalHandler>();\n\n/**\n * Default handlers for common reciprocal relationship patterns\n */\nconst DEFAULT_HANDLERS: Record<string, ReciprocalHandler> = {\n  // Symmetric relationships (same type in both directions)\n  friend: async (from, to, context) => {\n    await to.addRelationship(from, 'friend', context);\n  },\n\n  spouse: async (from, to) => {\n    await to.addRelationship(from, 'spouse');\n  },\n\n  partner: async (from, to, context) => {\n    await to.addRelationship(from, 'partner', context);\n  },\n\n  colleague: async (from, to, context) => {\n    await to.addRelationship(from, 'colleague', context);\n  },\n\n  sibling: async (from, to) => {\n    await to.addRelationship(from, 'sibling');\n  },\n};\n\n// Register default handlers\nfor (const [slug, handler] of Object.entries(DEFAULT_HANDLERS)) {\n  reciprocalHandlers.set(slug, handler);\n}\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update'] },\n  mcp: { include: ['list', 'get'] },\n  cli: true,\n})\nexport class ProfileRelationshipType extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  // slug is inherited from SmrtObject (auto-generated from name)\n  name = text({ required: true });\n  reciprocal = boolean({ default: true }); // True for two-way relationships\n\n  constructor(options: ProfileRelationshipTypeOptions = {}) {\n    super(options);\n    // Field values are automatically set by initializePropertiesFromOptions()\n    // No need to manually assign Field properties here\n  }\n\n  /**\n   * Convenience method for slug-based lookup\n   *\n   * @param slug - The slug to search for\n   * @returns ProfileRelationshipType instance or null if not found\n   */\n  static async getBySlug(\n    slug: string,\n  ): Promise<ProfileRelationshipType | null> {\n    // Will be auto-implemented by SMRT\n    return null;\n  }\n\n  /**\n   * Register a custom reciprocal handler for a relationship type\n   *\n   * @param slug - The relationship type slug\n   * @param handler - The handler function to execute when creating reciprocal relationship\n   */\n  static registerReciprocalHandler(\n    slug: string,\n    handler: ReciprocalHandler,\n  ): void {\n    reciprocalHandlers.set(slug, handler);\n  }\n\n  /**\n   * Get the reciprocal handler for a relationship type\n   *\n   * @param slug - The relationship type slug\n   * @returns The handler function or undefined\n   */\n  static getReciprocalHandler(slug: string): ReciprocalHandler | undefined {\n    return reciprocalHandlers.get(slug);\n  }\n\n  /**\n   * Check if a relationship type is reciprocal\n   *\n   * @param slug - The relationship type slug\n   * @returns True if reciprocal, false otherwise\n   */\n  static async isReciprocal(slug: string): Promise<boolean> {\n    const type = await ProfileRelationshipType.getBySlug(slug);\n    return type?.reciprocal ? Boolean(type.reciprocal) : false;\n  }\n}\n","/**\n * ProfileRelationshipTypeCollection - Collection manager for ProfileRelationshipType objects\n *\n * Provides querying for relationship type lookup table.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { ProfileRelationshipType } from '../models/ProfileRelationshipType';\n\nexport class ProfileRelationshipTypeCollection extends SmrtCollection<ProfileRelationshipType> {\n  static readonly _itemClass = ProfileRelationshipType;\n\n  /**\n   * Get relationship type by slug\n   *\n   * @param slug - The slug to search for\n   * @returns ProfileRelationshipType instance or null\n   */\n  async getBySlug(slug: string): Promise<ProfileRelationshipType | null> {\n    return await this.get({ slug });\n  }\n\n  /**\n   * Get or create a relationship type by slug\n   *\n   * @param slug - The slug to search for\n   * @param defaults - Default values if creating\n   * @returns ProfileRelationshipType instance\n   */\n  async getOrCreateBySlug(\n    slug: string,\n    defaults: { name: string; reciprocal?: boolean },\n  ): Promise<ProfileRelationshipType> {\n    const existing = await this.getBySlug(slug);\n    if (existing) return existing;\n\n    const relationshipType = await this.create({ slug, ...defaults });\n    await relationshipType.save();\n    return relationshipType;\n  }\n\n  /**\n   * Get all reciprocal relationship types\n   *\n   * @returns Array of reciprocal ProfileRelationshipType instances\n   */\n  async getReciprocal(): Promise<ProfileRelationshipType[]> {\n    return await this.list({ where: { reciprocal: true } });\n  }\n\n  /**\n   * Get all directional (non-reciprocal) relationship types\n   *\n   * @returns Array of directional ProfileRelationshipType instances\n   */\n  async getDirectional(): Promise<ProfileRelationshipType[]> {\n    return await this.list({ where: { reciprocal: false } });\n  }\n}\n","/**\n * ProfileTypeCollection - Collection manager for ProfileType objects\n *\n * Provides querying for profile type lookup table.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { ProfileType } from '../models/ProfileType';\n\nexport class ProfileTypeCollection extends SmrtCollection<ProfileType> {\n  static readonly _itemClass = ProfileType;\n\n  /**\n   * Get profile type by slug\n   *\n   * @param slug - The slug to search for\n   * @returns ProfileType instance or null\n   */\n  async getBySlug(slug: string): Promise<ProfileType | null> {\n    return await this.get({ slug });\n  }\n\n  /**\n   * Get or create a profile type by slug\n   *\n   * @param slug - The slug to search for\n   * @param defaults - Default values if creating\n   * @returns ProfileType instance\n   */\n  async getOrCreateBySlug(\n    slug: string,\n    defaults: { name: string; description?: string },\n  ): Promise<ProfileType> {\n    const existing = await this.getBySlug(slug);\n    if (existing) return existing;\n\n    const profileType = await this.create({ slug, ...defaults });\n    await profileType.save();\n    return profileType;\n  }\n}\n"],"names":["ProfileMetafieldCollection","ProfileMetadataCollection","ProfileRelationshipTypeCollection","ProfileRelationshipCollection","ProfileRelationshipType","ProfileCollection","_init","ProfileRelationshipTermCollection"],"mappings":"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"}