{"version":3,"file":"registry-Cr7Ueogq.js","sources":["../../src/utils.ts","../../src/registry.ts"],"sourcesContent":["import { syncSchema } from '@have/sql';\nimport { ObjectRegistry } from './registry';\nimport { SchemaGenerator } from './schema/generator';\n\n/**\n * Converts a camelCase string to snake_case\n *\n * @param str - String in camelCase format\n * @returns String in snake_case format\n * @example\n * ```typescript\n * toSnakeCase('meetingsUrl'); // 'meetings_url'\n * toSnakeCase('createdAt'); // 'created_at'\n * toSnakeCase('id'); // 'id'\n * ```\n */\nexport function toSnakeCase(str: string): string {\n  return str\n    .replace(/([A-Z])/g, '_$1')\n    .toLowerCase()\n    .replace(/^_/, '');\n}\n\n/**\n * Converts a snake_case string to camelCase\n *\n * @param str - String in snake_case format\n * @returns String in camelCase format\n * @example\n * ```typescript\n * toCamelCase('meetings_url'); // 'meetingsUrl'\n * toCamelCase('created_at'); // 'createdAt'\n * toCamelCase('id'); // 'id'\n * ```\n */\nexport function toCamelCase(str: string): string {\n  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\n/**\n * Converts all keys in an object from camelCase to snake_case\n *\n * @param obj - Object with camelCase keys\n * @returns Object with snake_case keys\n */\nexport function keysToSnakeCase(obj: Record<string, any>): Record<string, any> {\n  const result: Record<string, any> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    result[toSnakeCase(key)] = value;\n  }\n  return result;\n}\n\n/**\n * Converts all keys in an object from snake_case to camelCase\n *\n * @param obj - Object with snake_case keys\n * @returns Object with camelCase keys\n */\nexport function keysToCamelCase(obj: Record<string, any>): Record<string, any> {\n  const result: Record<string, any> = {};\n  for (const [key, value] of Object.entries(obj)) {\n    result[toCamelCase(key)] = value;\n  }\n  return result;\n}\n\n/**\n * Checks if a field name indicates a date field based on naming conventions\n *\n * Recognizes common date field patterns like '_at', '_date', and 'date'.\n * Used for automatic type inference during schema generation.\n *\n * @param key - Field name to check\n * @returns Boolean indicating if the field is likely a date field\n * @example\n * ```typescript\n * isDateField('created_at'); // true\n * isDateField('updated_date'); // true\n * isDateField('name'); // false\n * ```\n */\nexport function isDateField(key: string) {\n  return key.endsWith('_date') || key.endsWith('_at') || key === 'date';\n}\n\n/**\n * Converts a date string to a Date object\n *\n * @param date - Date as string or Date object\n * @returns Date object\n */\nexport function dateAsString(date: Date | string) {\n  if (typeof date === 'string') {\n    return new Date(date);\n  }\n  return date;\n}\n\n/**\n * Converts a Date object to an ISO string\n *\n * @param date - Date as Date object or string\n * @returns ISO date string or the original string\n */\nexport function dateAsObject(date: Date | string) {\n  if (date instanceof Date) {\n    return date.toISOString();\n  }\n  return date;\n}\n\n/**\n * Extracts field definitions from a class constructor\n *\n * Uses ObjectRegistry cached fields from AST manifest exclusively.\n * No runtime introspection fallback - classes must be decorated with @smrt()\n * for schema generation to work.\n *\n * @param ClassType - Class constructor to extract fields from\n * @param values - Optional values to set for the fields\n * @returns Object containing field definitions with names, types, and values\n * @throws {Error} If the class is not registered in ObjectRegistry\n * @example\n * ```typescript\n * @smrt()\n * class Product extends SmrtObject {\n *   name = text();\n *   price = decimal();\n * }\n *\n * const fields = fieldsFromClass(Product);\n * console.log(fields.name.type); // 'TEXT'\n * console.log(fields.price.type); // 'REAL'\n * ```\n */\nexport function fieldsFromClass(\n  ClassType: new (...args: any[]) => any,\n  values?: Record<string, any>,\n) {\n  const className = ClassType.name;\n  const cachedFields = ObjectRegistry.getFields(className);\n\n  // Phase 2: AST manifest only - no runtime introspection fallback\n  if (cachedFields.size === 0) {\n    // Return empty fields for unregistered classes (for backward compatibility)\n    // generateSchema() will throw if it needs field definitions\n    return {};\n  }\n\n  // Use cached field definitions from AST manifest\n  const fields: Record<string, any> = {};\n\n  for (const [key, field] of cachedFields.entries()) {\n    fields[key] = {\n      name: key,\n      type: field.type || 'TEXT',\n      ...(values && key in values ? { value: values[key] } : {}),\n    };\n  }\n\n  return fields;\n}\n\n/**\n * Generates a complete database schema SQL statement for a class\n *\n * This is now a thin wrapper around SchemaGenerator that provides the\n * single source of truth for schema generation. Uses ObjectRegistry\n * cached fields from AST manifest for consistent schema generation.\n *\n * @param ClassType - Class constructor to generate schema for\n * @param providedFields - Optional fields map (used during registration)\n * @returns SQL schema creation statement with CREATE TABLE and CREATE INDEX statements\n * @example\n * ```typescript\n * const schema = generateSchema(Product);\n * console.log(schema);\n * // Output:\n * // CREATE TABLE IF NOT EXISTS products (\n * //   id TEXT PRIMARY KEY,\n * //   slug TEXT NOT NULL,\n * //   context TEXT NOT NULL DEFAULT CAST('' AS TEXT),\n * //   name TEXT,\n * //   price INTEGER,\n * //   UNIQUE(slug, context)\n * // );\n * ```\n */\nexport function generateSchema(\n  ClassType: new (...args: any[]) => any,\n  providedFields?: Map<string, any>,\n) {\n  const className = ClassType.name;\n  const tableName = tableNameFromClass(ClassType);\n\n  // Use provided fields if available AND non-empty (during registration), otherwise get from registry\n  const cachedFields =\n    providedFields && providedFields.size > 0\n      ? providedFields\n      : ObjectRegistry.getFields(className);\n\n  // Throw error if class is not registered AND no fields provided\n  if (cachedFields.size === 0) {\n    throw new Error(\n      `Cannot generate schema for unregistered class '${className}'. ` +\n        `Ensure the class is decorated with @smrt() for schema generation to work. ` +\n        `Runtime introspection has been removed in Phase 2 of the schema management refactor.`,\n    );\n  }\n\n  // Use SchemaGenerator for consistent SQL generation\n  const generator = new SchemaGenerator();\n  const schemaDefinition = generator.generateSchemaFromRegistry(\n    className,\n    tableName,\n    cachedFields,\n  );\n\n  return generator.generateSQL(schemaDefinition);\n}\n\n/**\n * Generates a table name from a class constructor\n *\n * Checks for SMRT_TABLE_NAME static property first (set by @smrt() decorator),\n * which survives code minification. Falls back to deriving from ClassType.name\n * for backward compatibility.\n *\n * @param ClassType - Class constructor or function\n * @returns Pluralized snake_case table name\n * @example\n * ```typescript\n * // With @smrt() decorator (recommended)\n * @smrt()\n * class Product extends SmrtObject { }\n * tableNameFromClass(Product); // \"products\" (captured before minification)\n *\n * // Without decorator (fallback)\n * class Category extends SmrtObject { }\n * tableNameFromClass(Category); // \"categories\" (derived from runtime name)\n * ```\n */\nexport function tableNameFromClass(\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  ClassType: Function | (new (...args: any[]) => any),\n) {\n  // Check for SMRT_TABLE_NAME property set by @smrt() decorator (survives minification)\n  if ('SMRT_TABLE_NAME' in ClassType) {\n    return (ClassType as any).SMRT_TABLE_NAME;\n  }\n\n  // Fallback: derive from class name (breaks with minification)\n  return (\n    ClassType.name\n      // Insert underscore between lower & upper case letters\n      .replace(/([a-z])([A-Z])/g, '$1_$2')\n      // Convert to lowercase\n      .toLowerCase()\n      // Handle basic pluralization rules\n      .replace(/([^s])$/, '$1s')\n      // Handle special cases ending in 'y'\n      .replace(/y$/, 'ies')\n  );\n}\n\n/**\n * Converts a class name to a table name with pluralization\n *\n * @param className - Name of the class\n * @returns Pluralized snake_case table name\n */\nexport function classnameToTablename(className: string) {\n  // Convert camelCase/PascalCase to snake_case and pluralize\n  const tableName = className\n    // Insert underscore between lower & upper case letters\n    .replace(/([a-z])([A-Z])/g, '$1_$2')\n    // Convert to lowercase\n    .toLowerCase()\n    // Handle basic pluralization rules\n    .replace(/([^s])$/, '$1s')\n    // Handle special cases ending in 'y'\n    .replace(/y$/, 'ies');\n\n  return tableName;\n}\n\n/**\n * Cache of table setup promises to avoid duplicate setup operations\n */\nconst _setupTableFromClassPromises: Record<string, Promise<void> | null> = {};\n\n/**\n * Sets up database tables for a class with caching to prevent duplicate operations\n *\n * Creates the database table, indexes, and triggers for a SMRT class.\n * Uses promise caching to ensure each table is only set up once.\n * Now leverages ObjectRegistry's cached schema for instant retrieval.\n *\n * @param db - Database connection interface\n * @param ClassType - Class constructor to create tables for\n * @returns Promise that resolves when setup is complete\n * @throws {Error} If schema creation or trigger setup fails\n * @example\n * ```typescript\n * await setupTableFromClass(db, Product);\n * // Table 'products' is now ready for use\n * ```\n */\nexport async function setupTableFromClass(db: any, ClassType: any) {\n  const tableName = classnameToTablename(ClassType.name);\n\n  if (\n    _setupTableFromClassPromises[tableName] !== undefined &&\n    _setupTableFromClassPromises[tableName] !== null\n  ) {\n    return _setupTableFromClassPromises[tableName];\n  }\n\n  _setupTableFromClassPromises[tableName] = (async () => {\n    try {\n      const className = ClassType.name;\n\n      // Get fields from registry (from AST manifest)\n      const cachedFields = ObjectRegistry.getFields(className);\n\n      // Always generate fresh schema to ensure latest field mapping is used\n      const schema = generateSchema(ClassType, cachedFields);\n      let _primaryKeyColumn = 'id'; // default\n\n      if (cachedFields.size > 0) {\n        for (const [key, field] of cachedFields.entries()) {\n          if (field.options?.primaryKey) {\n            _primaryKeyColumn = toSnakeCase(key);\n            break;\n          }\n        }\n      }\n\n      await syncSchema({ db, schema });\n    } catch (error) {\n      _setupTableFromClassPromises[tableName] = null; // Allow retry on failure\n      throw error;\n    }\n  })();\n\n  return _setupTableFromClassPromises[tableName];\n}\n\n/**\n * Formats data for JavaScript by converting date strings to Date objects\n * and snake_case column names to camelCase properties\n *\n * @param data - Object with data to format (snake_case column names from DB)\n * @returns Object with properly typed values and camelCase property names for JavaScript\n */\nexport function formatDataJs(data: Record<string, any>) {\n  const normalizedData: Record<string, any> = {};\n  for (const [key, value] of Object.entries(data)) {\n    // Convert snake_case to camelCase for JavaScript\n    const camelKey = toCamelCase(key);\n\n    if (value instanceof Date) {\n      normalizedData[camelKey] = value;\n    } else if (isDateField(key) && typeof value === 'string') {\n      normalizedData[camelKey] = new Date(value);\n    } else {\n      normalizedData[camelKey] = value;\n    }\n  }\n  return normalizedData;\n}\n\n/**\n * Formats data for SQL by converting Date objects to ISO strings\n * and camelCase property names to snake_case column names\n *\n * @param data - Object with data to format (camelCase property names from JavaScript)\n * @returns Object with properly formatted values and snake_case column names for SQL\n */\nexport function formatDataSql(data: Record<string, any>) {\n  const normalizedData: Record<string, any> = {};\n  for (const [key, value] of Object.entries(data)) {\n    // Convert camelCase to snake_case for SQL\n    const snakeKey = toSnakeCase(key);\n\n    if (value instanceof Date) {\n      normalizedData[snakeKey] = value.toISOString(); // Postgres accepts ISO format with timezone\n    } else {\n      normalizedData[snakeKey] = value;\n    }\n  }\n  return normalizedData;\n}\n","/**\n * Global object registry for SMRT classes\n *\n * Maintains a central registry of all @smrt decorated classes, enabling\n * module awareness, automatic API generation, and runtime introspection.\n * The registry tracks class definitions, field metadata, and configuration\n * options for code generation and runtime operations.\n *\n * @example Registering a class manually\n * ```typescript\n * import { ObjectRegistry } from '@smrt/core';\n *\n * ObjectRegistry.register(MyClass, {\n *   api: { exclude: ['delete'] },\n *   cli: true\n * });\n * ```\n *\n * @example Using the decorator (recommended)\n * ```typescript\n * import { smrt } from '@smrt/core';\n *\n * @smrt({ api: { exclude: ['delete'] } })\n * class Product extends SmrtObject {\n *   name = text({ required: true });\n * }\n * ```\n */\n\nimport type { SmrtCollection } from './collection';\nimport { staticManifest } from './manifest/static-manifest';\nimport type { SmrtObject } from './object';\nimport {\n  classnameToTablename,\n  generateSchema,\n  tableNameFromClass,\n} from './utils';\n\n/**\n * Configuration options for SMRT objects registered in the system\n *\n * Controls how objects are exposed through generated APIs, CLIs, and MCP servers.\n * Each section configures a different aspect of code generation and runtime behavior.\n *\n * @interface SmartObjectConfig\n */\nexport interface SmartObjectConfig {\n  /**\n   * Custom name for the object (defaults to class name)\n   */\n  name?: string;\n\n  /**\n   * Custom table name for database storage (defaults to pluralized snake_case class name)\n   * Explicitly setting this ensures the table name survives code minification\n   */\n  tableName?: string;\n\n  /**\n   * API configuration\n   */\n  api?: {\n    /**\n     * Exclude specific endpoints (supports both standard CRUD actions and custom methods)\n     */\n    exclude?: string[];\n\n    /**\n     * Include only specific endpoints (supports both standard CRUD actions and custom methods)\n     */\n    include?: string[];\n\n    /**\n     * Custom middleware for this object's endpoints\n     */\n    middleware?: any[];\n\n    /**\n     * Custom endpoint handlers (supports both standard CRUD actions and custom methods)\n     */\n    customize?: Record<string, (req: any, collection: any) => Promise<any>>;\n  };\n\n  /**\n   * MCP server configuration\n   */\n  mcp?: {\n    /**\n     * Include specific tools (supports both standard CRUD actions and custom methods)\n     */\n    include?: string[];\n\n    /**\n     * Exclude specific tools (supports both standard CRUD actions and custom methods)\n     */\n    exclude?: string[];\n  };\n\n  /**\n   * CLI configuration\n   */\n  cli?:\n    | boolean\n    | {\n        /**\n         * Include specific commands (supports both standard CRUD actions and custom methods)\n         */\n        include?: string[];\n\n        /**\n         * Exclude specific commands (supports both standard CRUD actions and custom methods)\n         */\n        exclude?: string[];\n      };\n\n  /**\n   * AI callable configuration\n   */\n  ai?: {\n    /**\n     * Methods that AI can call\n     * - Array of method names, e.g., ['analyze', 'validate']\n     * - 'public-async' to auto-include all public async methods\n     * - 'all' to include all methods (not recommended)\n     */\n    callable?: string[] | 'public-async' | 'all';\n\n    /**\n     * Methods to exclude from AI calling (higher priority than callable)\n     */\n    exclude?: string[];\n\n    /**\n     * Additional tool descriptions to override method JSDoc\n     */\n    descriptions?: Record<string, string>;\n  };\n\n  /**\n   * Lifecycle hooks\n   */\n  hooks?: {\n    beforeSave?: string | ((instance: any) => Promise<void>);\n    afterSave?: string | ((instance: any) => Promise<void>);\n    beforeCreate?: string | ((instance: any) => Promise<void>);\n    afterCreate?: string | ((instance: any) => Promise<void>);\n    beforeUpdate?: string | ((instance: any) => Promise<void>);\n    afterUpdate?: string | ((instance: any) => Promise<void>);\n    beforeDelete?: string | ((instance: any) => Promise<void>);\n    afterDelete?: string | ((instance: any) => Promise<void>);\n  };\n}\n\n/**\n * Schema definition for a registered class\n */\ninterface SchemaDefinition {\n  /** SQL DDL statement for table creation */\n  ddl: string;\n  /** Index creation statements */\n  indexes: string[];\n  /** Trigger definitions for automatic timestamp management */\n  triggers: Array<{\n    name: string;\n    when: 'BEFORE' | 'AFTER';\n    event: 'INSERT' | 'UPDATE' | 'DELETE';\n    tableName: string;\n    condition?: string;\n    body: string;\n    description?: string;\n  }>;\n  /** Table name derived from class name */\n  tableName: string;\n}\n\n/**\n * Validation function that takes an object instance and returns\n * a ValidationError if validation fails, or null if validation passes\n */\ntype ValidatorFunction = (\n  instance: any,\n) => Promise<import('./errors').ValidationError | null>;\n\n/**\n * Relationship type for the relationship map\n */\nexport type RelationshipType = 'foreignKey' | 'oneToMany' | 'manyToMany';\n\n/**\n * Metadata about a relationship between classes\n */\nexport interface RelationshipMetadata {\n  /** Source class name */\n  sourceClass: string;\n  /** Field name on the source class */\n  fieldName: string;\n  /** Target/related class name */\n  targetClass: string;\n  /** Type of relationship */\n  type: RelationshipType;\n  /** Options for the relationship (onDelete, etc.) */\n  options: any;\n}\n\n/**\n * Internal representation of a registered SMRT class\n *\n * @interface RegisteredClass\n * @private\n */\ninterface RegisteredClass {\n  name: string;\n  constructor: typeof SmrtObject;\n  collectionConstructor?: new (options: any) => SmrtCollection<any>;\n  config: SmartObjectConfig;\n  fields: Map<string, any>;\n  /** Cached schema definition generated during registration */\n  schema?: SchemaDefinition;\n  /** Compiled validation functions for efficient runtime validation */\n  validators?: ValidatorFunction[];\n  /** AI-callable tools generated from methods at build time */\n  tools?: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description?: string;\n      parameters?: Record<string, any>;\n    };\n  }>;\n}\n\n/**\n * Central registry for all SMRT objects\n */\nexport class ObjectRegistry {\n  private static classes = new Map<string, RegisteredClass>();\n  private static collections = new Map<string, typeof SmrtCollection>();\n  private static collectionCache = new Map<string, SmrtCollection<any>>();\n\n  /**\n   * Register a new SMRT object class with the global registry\n   *\n   * @param constructor - The class constructor extending SmrtObject\n   * @param config - Configuration options for API/CLI/MCP generation\n   * @throws {Error} If the class cannot be introspected for field definitions\n   * @example\n   * ```typescript\n   * ObjectRegistry.register(Product, {\n   *   api: { exclude: ['delete'] },\n   *   cli: true,\n   *   mcp: { include: ['list', 'get'] }\n   * });\n   * ```\n   */\n  static register(\n    ctor: typeof SmrtObject,\n    config: SmartObjectConfig = {},\n  ): void {\n    const name = config.name || ctor.name;\n\n    // Prevent duplicate registrations\n    if (ObjectRegistry.classes.has(name)) {\n      return; // Already registered, skip silently\n    }\n\n    // Get field definitions from AST manifest (generated at build time)\n    const manifestEntry = staticManifest.objects[name];\n    const fields = new Map<string, any>();\n\n    if (manifestEntry?.fields) {\n      // Use manifest fields (preferred - from build-time AST scanning)\n      for (const [fieldName, fieldDef] of Object.entries(\n        manifestEntry.fields,\n      )) {\n        fields.set(fieldName, fieldDef);\n      }\n    } else {\n      // Fallback for test classes: detect fields at runtime\n      try {\n        const tempInstance = new (ctor as any)({\n          db: null,\n          ai: null,\n          fs: null,\n          _skipRegistration: true,\n        });\n\n        for (const key of Object.getOwnPropertyNames(tempInstance)) {\n          // Skip protected properties - this fixes Issue #13\n          if (key.startsWith('_') || key.startsWith('#') || key === 'options') {\n            continue;\n          }\n\n          const value = tempInstance[key];\n\n          // Check for Field instances first (from field helpers like text())\n          if (value && typeof value === 'object' && value.type) {\n            fields.set(key, value);\n          }\n        }\n\n        // If no Field instances found, infer from primitive properties\n        if (fields.size === 0) {\n          for (const key of Object.getOwnPropertyNames(tempInstance)) {\n            // Skip protected properties\n            if (\n              key.startsWith('_') ||\n              key.startsWith('#') ||\n              key === 'options'\n            ) {\n              continue;\n            }\n\n            const value = tempInstance[key];\n            const valueType = typeof value;\n\n            // Infer field type from primitive value\n            let fieldType = 'text';\n            if (valueType === 'string') fieldType = 'text';\n            else if (valueType === 'number')\n              fieldType = Number.isInteger(value) ? 'integer' : 'decimal';\n            else if (valueType === 'boolean') fieldType = 'boolean';\n            else if (value instanceof Date) fieldType = 'datetime';\n            else if (Array.isArray(value)) fieldType = 'json';\n            else if (valueType === 'object' && value !== null)\n              fieldType = 'json';\n            else continue; // Skip functions, undefined, null\n\n            fields.set(key, {\n              type: fieldType,\n              options: {},\n            });\n          }\n        }\n      } catch (error) {\n        console.warn(\n          `Warning: Could not extract fields from ${ctor.name}:`,\n          error,\n        );\n      }\n    }\n\n    // Generate and cache schema definition\n    // Use tableName from config if provided (captured by @smrt() decorator)\n    const tableName = config.tableName || tableNameFromClass(ctor);\n    // Pass extracted fields to avoid circular dependency (class isn't registered yet)\n    const schemaDDL = generateSchema(ctor, fields);\n\n    // Parse schema DDL to extract indexes\n    const indexes: string[] = [];\n    const ddlLines = schemaDDL.split('\\n');\n    const tableEndIndex = ddlLines.findIndex((line) => line.includes(');'));\n    const indexLines = ddlLines.slice(tableEndIndex + 1);\n    for (const line of indexLines) {\n      if (line.trim().startsWith('CREATE INDEX')) {\n        indexes.push(line.trim());\n      }\n    }\n\n    // Store complete schema definition\n    const schema: SchemaDefinition = {\n      ddl: schemaDDL,\n      indexes,\n      triggers: [], // No longer using database triggers - timestamps managed by application\n      tableName,\n    };\n\n    // Compile validation functions from field definitions\n    const validators = ObjectRegistry.compileValidators(name, fields);\n\n    ObjectRegistry.classes.set(name, {\n      name,\n      constructor: ctor,\n      config,\n      fields,\n      schema,\n      validators,\n    });\n\n    console.log(\n      `🎯 Registered smrt object: ${name} with schema for ${tableName} and ${validators.length} validators`,\n    );\n  }\n\n  /**\n   * Register a collection class for an object\n   *\n   * @param objectName - Name of the object class this collection manages\n   * @param collectionConstructor - The collection class constructor\n   * @example\n   * ```typescript\n   * ObjectRegistry.registerCollection('Product', ProductCollection);\n   * ```\n   */\n  static registerCollection(\n    objectName: string,\n    collectionConstructor: new (options: any) => SmrtCollection<any>,\n  ): void {\n    const registered = ObjectRegistry.classes.get(objectName);\n    if (registered) {\n      registered.collectionConstructor = collectionConstructor;\n    }\n\n    ObjectRegistry.collections.set(objectName, collectionConstructor as any);\n  }\n\n  /**\n   * Helper method for case-insensitive class lookup\n   * Tries exact match first, then falls back to case-insensitive search\n   *\n   * @param name - Name of the class to find\n   * @returns Registered class information or undefined if not found\n   * @private\n   */\n  private static findClass(name: string): RegisteredClass | undefined {\n    // Try exact match first (fast path)\n    const registered = ObjectRegistry.classes.get(name);\n    if (registered) {\n      return registered;\n    }\n\n    // Fall back to case-insensitive search\n    const lowerName = name.toLowerCase();\n    for (const [key, value] of ObjectRegistry.classes.entries()) {\n      if (key.toLowerCase() === lowerName) {\n        return value;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Get a registered class by name (case-insensitive)\n   *\n   * @param name - Name of the registered class\n   * @returns Registered class information or undefined if not found\n   * @example\n   * ```typescript\n   * const productInfo = ObjectRegistry.getClass('Product');\n   * // Also works with: 'product', 'PRODUCT', etc.\n   * if (productInfo) {\n   *   console.log(productInfo.config.api?.exclude);\n   * }\n   * ```\n   */\n  static getClass(name: string): RegisteredClass | undefined {\n    return ObjectRegistry.findClass(name);\n  }\n\n  /**\n   * Get all registered classes\n   *\n   * @returns Map of class names to registered class information\n   * @example\n   * ```typescript\n   * const allClasses = ObjectRegistry.getAllClasses();\n   * for (const [name, info] of allClasses) {\n   *   console.log(`Class: ${name}, Fields: ${info.fields.size}`);\n   * }\n   * ```\n   */\n  static getAllClasses(): Map<string, RegisteredClass> {\n    return new Map(ObjectRegistry.classes);\n  }\n\n  /**\n   * Get class names\n   */\n  static getClassNames(): string[] {\n    return Array.from(ObjectRegistry.classes.keys());\n  }\n\n  /**\n   * Check if a class is registered (case-insensitive)\n   */\n  static hasClass(name: string): boolean {\n    return ObjectRegistry.findClass(name) !== undefined;\n  }\n\n  /**\n   * Clear all registered classes (mainly for testing)\n   */\n  static clear(): void {\n    ObjectRegistry.classes.clear();\n    ObjectRegistry.collections.clear();\n    ObjectRegistry.collectionCache.clear();\n  }\n\n  /**\n   * Get or create a cached collection instance (Singleton pattern - Phase 4 optimization)\n   *\n   * Returns a cached collection if one exists for the given class and options,\n   * otherwise creates, initializes, and caches a new instance. This significantly\n   * improves performance by avoiding repeated collection initialization.\n   *\n   * **Performance Impact**: 60-80% reduction in collection initialization overhead\n   *\n   * **Cache Key Strategy**: Collections are cached based on:\n   * - className\n   * - persistence configuration (type, url, baseUrl)\n   * - db presence (not full config)\n   * - ai presence (not full config)\n   *\n   * Different persistence configurations create separate cached instances.\n   *\n   * @param className - Name of the object class\n   * @param options - Configuration options for the collection\n   * @returns Cached or newly created collection instance\n   * @throws {Error} If the class is not registered or has no collection\n   *\n   * @example\n   * ```typescript\n   * // First call creates and caches the collection\n   * const orders1 = await ObjectRegistry.getCollection('Order', {\n   *   persistence: { type: 'sql', url: 'orders.db' }\n   * });\n   *\n   * // Subsequent calls return the cached instance (much faster)\n   * const orders2 = await ObjectRegistry.getCollection('Order', {\n   *   persistence: { type: 'sql', url: 'orders.db' }\n   * });\n   * console.log(orders1 === orders2); // true (same instance)\n   *\n   * // Different configuration creates new instance\n   * const orders3 = await ObjectRegistry.getCollection('Order', {\n   *   persistence: { type: 'sql', url: 'orders-copy.db' }\n   * });\n   * console.log(orders1 === orders3); // false (different config)\n   * ```\n   *\n   * @see {@link https://github.com/happyvertical/sdk/blob/main/packages/core/CLAUDE.md#singleton-collection-management-phase-4|Phase 4 Documentation}\n   */\n  static async getCollection<T extends SmrtObject>(\n    className: string,\n    options: any = {},\n  ): Promise<SmrtCollection<T>> {\n    // Create a cache key from className and relevant options\n    // We use a simplified key that includes only persistence config\n    // to avoid cache misses from transient options\n    const cacheKey = `${className}:${JSON.stringify({\n      persistence: options.persistence,\n      db: options.db ? 'present' : undefined,\n      ai: options.ai ? 'present' : undefined,\n    })}`;\n\n    // Return cached instance if available\n    if (ObjectRegistry.collectionCache.has(cacheKey)) {\n      return ObjectRegistry.collectionCache.get(cacheKey) as SmrtCollection<T>;\n    }\n\n    // Get registered class info (case-insensitive)\n    const registered = ObjectRegistry.findClass(className);\n    if (!registered) {\n      throw new Error(\n        `Class ${className} not found in ObjectRegistry. Make sure to register it with @smrt() decorator or ObjectRegistry.register()`,\n      );\n    }\n\n    // Auto-create default collection if not registered\n    let collectionConstructor = registered.collectionConstructor;\n\n    if (!collectionConstructor) {\n      // Lazy-load SmrtCollection to avoid circular dependency\n      const { SmrtCollection: SmrtCollectionClass } = await import(\n        './collection'\n      );\n\n      // Create a default collection class dynamically\n      class DefaultCollection extends SmrtCollectionClass<T> {\n        static readonly _itemClass = registered?.constructor as any;\n      }\n\n      // Register it for future use\n      collectionConstructor = DefaultCollection as any;\n      registered.collectionConstructor = DefaultCollection as any;\n      ObjectRegistry.collections.set(className, DefaultCollection as any);\n    }\n\n    // Create and initialize new collection instance using static factory method\n    // collectionConstructor is guaranteed to be defined here\n    const collection = (await (collectionConstructor as any).create(\n      options,\n    )) as SmrtCollection<T>;\n\n    // Cache the initialized instance\n    ObjectRegistry.collectionCache.set(cacheKey, collection);\n\n    return collection;\n  }\n\n  /**\n   * Compile validation functions from field definitions\n   *\n   * Extracts validation rules from field options and compiles them into\n   * efficient validation functions that can be executed at runtime.\n   *\n   * @param className - Name of the class being validated\n   * @param fields - Map of field definitions\n   * @returns Array of compiled validation functions\n   * @private\n   */\n  private static compileValidators(\n    className: string,\n    fields: Map<string, any>,\n  ): ValidatorFunction[] {\n    const validators: ValidatorFunction[] = [];\n\n    for (const [fieldName, field] of fields) {\n      const options = field.options || {};\n\n      // Required field validator\n      if (options.required) {\n        validators.push(async (instance: any) => {\n          const value = instance[fieldName];\n          if (value === null || value === undefined || value === '') {\n            const ValidationError = await import('./errors').then(\n              (m) => m.ValidationError,\n            );\n            return ValidationError.requiredField(fieldName, className);\n          }\n          return null;\n        });\n      }\n\n      // Numeric range validators\n      if (\n        field.type === 'integer' ||\n        field.type === 'decimal' ||\n        field.type === 'number'\n      ) {\n        if (options.min !== undefined) {\n          validators.push(async (instance: any) => {\n            const value = instance[fieldName];\n            if (value !== null && value !== undefined && value < options.min) {\n              const ValidationError = await import('./errors').then(\n                (m) => m.ValidationError,\n              );\n              return ValidationError.rangeError(\n                fieldName,\n                value,\n                options.min,\n                options.max,\n              );\n            }\n            return null;\n          });\n        }\n\n        if (options.max !== undefined) {\n          validators.push(async (instance: any) => {\n            const value = instance[fieldName];\n            if (value !== null && value !== undefined && value > options.max) {\n              const ValidationError = await import('./errors').then(\n                (m) => m.ValidationError,\n              );\n              return ValidationError.rangeError(\n                fieldName,\n                value,\n                options.min,\n                options.max,\n              );\n            }\n            return null;\n          });\n        }\n      }\n\n      // String length validators\n      if (field.type === 'text') {\n        if (options.minLength !== undefined) {\n          validators.push(async (instance: any) => {\n            const value = instance[fieldName];\n            if (\n              value &&\n              typeof value === 'string' &&\n              value.length < options.minLength\n            ) {\n              const ValidationError = await import('./errors').then(\n                (m) => m.ValidationError,\n              );\n              return ValidationError.invalidValue(\n                fieldName,\n                value,\n                `string with minimum length ${options.minLength}`,\n              );\n            }\n            return null;\n          });\n        }\n\n        if (options.maxLength !== undefined) {\n          validators.push(async (instance: any) => {\n            const value = instance[fieldName];\n            if (\n              value &&\n              typeof value === 'string' &&\n              value.length > options.maxLength\n            ) {\n              const ValidationError = await import('./errors').then(\n                (m) => m.ValidationError,\n              );\n              return ValidationError.invalidValue(\n                fieldName,\n                value,\n                `string with maximum length ${options.maxLength}`,\n              );\n            }\n            return null;\n          });\n        }\n\n        // Pattern validator (regex)\n        if (options.pattern) {\n          const regex = new RegExp(options.pattern);\n          validators.push(async (instance: any) => {\n            const value = instance[fieldName];\n            if (value && typeof value === 'string' && !regex.test(value)) {\n              const ValidationError = await import('./errors').then(\n                (m) => m.ValidationError,\n              );\n              return ValidationError.invalidValue(\n                fieldName,\n                value,\n                `string matching pattern ${options.pattern}`,\n              );\n            }\n            return null;\n          });\n        }\n      }\n\n      // Custom validator function\n      if (options.validate && typeof options.validate === 'function') {\n        validators.push(async (instance: any) => {\n          const value = instance[fieldName];\n          try {\n            const isValid = await options.validate(value);\n            if (!isValid) {\n              const ValidationError = await import('./errors').then(\n                (m) => m.ValidationError,\n              );\n              const message =\n                options.customMessage ||\n                `Field ${fieldName} failed custom validation`;\n              return ValidationError.invalidValue(fieldName, value, message);\n            }\n          } catch (error) {\n            const ValidationError = await import('./errors').then(\n              (m) => m.ValidationError,\n            );\n            return ValidationError.invalidValue(\n              fieldName,\n              value,\n              `custom validation error: ${error instanceof Error ? error.message : String(error)}`,\n            );\n          }\n          return null;\n        });\n      }\n    }\n\n    return validators;\n  }\n\n  /**\n   * Get field definitions for a registered class\n   */\n  static getFields(name: string): Map<string, any> {\n    const registered = ObjectRegistry.classes.get(name);\n    return registered ? registered.fields : new Map();\n  }\n\n  /**\n   * Get configuration for a registered class\n   */\n  static getConfig(name: string): SmartObjectConfig {\n    const registered = ObjectRegistry.classes.get(name);\n    return registered ? registered.config : {};\n  }\n\n  /**\n   * Get cached schema definition for a registered class\n   *\n   * @param name - Name of the registered class\n   * @returns Schema definition or undefined if not found\n   * @example\n   * ```typescript\n   * const schema = ObjectRegistry.getSchema('Product');\n   * console.log(schema.tableName); // 'products'\n   * console.log(schema.ddl);       // 'CREATE TABLE...'\n   * ```\n   */\n  static getSchema(name: string): SchemaDefinition | undefined {\n    const registered = ObjectRegistry.classes.get(name);\n    return registered?.schema;\n  }\n\n  /**\n   * Get SQL DDL statement for a registered class\n   *\n   * @param name - Name of the registered class\n   * @returns SQL DDL statement or undefined if not found\n   * @example\n   * ```typescript\n   * const ddl = ObjectRegistry.getSchemaDDL('Product');\n   * await db.query(ddl);\n   * ```\n   */\n  static getSchemaDDL(name: string): string | undefined {\n    return ObjectRegistry.getSchema(name)?.ddl;\n  }\n\n  /**\n   * Get table name for a registered class\n   *\n   * @param name - Name of the registered class\n   * @returns Table name or undefined if not found\n   * @example\n   * ```typescript\n   * const tableName = ObjectRegistry.getTableName('Product');\n   * console.log(tableName); // 'products'\n   * ```\n   */\n  static getTableName(name: string): string | undefined {\n    return ObjectRegistry.getSchema(name)?.tableName;\n  }\n\n  /**\n   * Get compiled validation functions for a registered class\n   *\n   * Returns pre-compiled validation functions that can be executed\n   * at runtime for efficient validation without repeated setup.\n   *\n   * @param name - Name of the registered class\n   * @returns Array of validation functions or undefined if not found\n   * @example\n   * ```typescript\n   * const validators = ObjectRegistry.getValidators('Product');\n   * for (const validator of validators || []) {\n   *   const error = await validator(productInstance);\n   *   if (error) console.error(error);\n   * }\n   * ```\n   */\n  static getValidators(name: string): ValidatorFunction[] | undefined {\n    const registered = ObjectRegistry.classes.get(name);\n    return registered?.validators;\n  }\n\n  /**\n   * Build dependency graph from foreignKey relationships\n   *\n   * Returns a map where keys are class names and values are arrays\n   * of class names that the key depends on (via foreignKey fields).\n   *\n   * @returns Map of class name to array of dependency class names\n   * @example\n   * ```typescript\n   * const deps = ObjectRegistry.getDependencyGraph();\n   * // { 'Order': ['Customer', 'Product'], 'Customer': [], 'Product': ['Category'] }\n   * ```\n   */\n  static getDependencyGraph(): Map<string, string[]> {\n    const graph = new Map<string, string[]>();\n\n    // Initialize graph with all registered classes\n    for (const [className] of ObjectRegistry.classes) {\n      graph.set(className, []);\n    }\n\n    // Scan all fields for foreignKey relationships\n    for (const [className, registered] of ObjectRegistry.classes) {\n      const dependencies: string[] = [];\n\n      for (const [_fieldName, field] of registered.fields) {\n        if (field.type === 'foreignKey' && field.options?.related) {\n          const relatedClass = field.options.related;\n          // Only add if the related class is registered\n          if (ObjectRegistry.classes.has(relatedClass)) {\n            dependencies.push(relatedClass);\n          }\n        }\n      }\n\n      graph.set(className, dependencies);\n    }\n\n    return graph;\n  }\n\n  /**\n   * Get initialization order for classes based on dependency graph\n   *\n   * Uses topological sort to ensure that classes are initialized in\n   * an order that respects foreignKey dependencies (dependencies first).\n   *\n   * @returns Array of class names in initialization order\n   * @throws {Error} If circular dependencies are detected\n   * @example\n   * ```typescript\n   * const order = ObjectRegistry.getInitializationOrder();\n   * // ['Category', 'Product', 'Customer', 'Order']\n   * // Tables are created in this order to avoid foreign key errors\n   * ```\n   */\n  static getInitializationOrder(): string[] {\n    const graph = ObjectRegistry.getDependencyGraph();\n    const visited = new Set<string>();\n    const visiting = new Set<string>();\n    const order: string[] = [];\n\n    function visit(className: string): void {\n      // Circular dependency check\n      if (visiting.has(className)) {\n        throw new Error(\n          `Circular dependency detected involving class: ${className}`,\n        );\n      }\n\n      // Already processed\n      if (visited.has(className)) {\n        return;\n      }\n\n      visiting.add(className);\n\n      // Visit all dependencies first\n      const dependencies = graph.get(className) || [];\n      for (const dep of dependencies) {\n        visit(dep);\n      }\n\n      visiting.delete(className);\n      visited.add(className);\n      order.push(className);\n    }\n\n    // Visit all classes\n    for (const className of graph.keys()) {\n      if (!visited.has(className)) {\n        visit(className);\n      }\n    }\n\n    return order;\n  }\n\n  /**\n   * Build comprehensive relationship map from all field types\n   *\n   * Returns a map containing all relationships (foreignKey, oneToMany, manyToMany)\n   * discovered in registered classes. This enables runtime relationship traversal\n   * and eager/lazy loading of related objects.\n   *\n   * @returns Map of class name to array of relationship metadata\n   * @example\n   * ```typescript\n   * const relationships = ObjectRegistry.getRelationshipMap();\n   * // {\n   * //   'Order': [\n   * //     { sourceClass: 'Order', fieldName: 'customerId', targetClass: 'Customer',\n   * //       type: 'foreignKey', options: { onDelete: 'restrict' } }\n   * //   ],\n   * //   'Customer': [\n   * //     { sourceClass: 'Customer', fieldName: 'orders', targetClass: 'Order',\n   * //       type: 'oneToMany', options: {} }\n   * //   ]\n   * // }\n   * ```\n   */\n  static getRelationshipMap(): Map<string, RelationshipMetadata[]> {\n    const relationshipMap = new Map<string, RelationshipMetadata[]>();\n\n    // Initialize map with all registered classes\n    for (const [className] of ObjectRegistry.classes) {\n      relationshipMap.set(className, []);\n    }\n\n    // Scan all fields for relationship types\n    for (const [className, registered] of ObjectRegistry.classes) {\n      const relationships: RelationshipMetadata[] = [];\n\n      for (const [fieldName, field] of registered.fields) {\n        // Check for foreignKey relationships\n        if (field.type === 'foreignKey' && field.options?.related) {\n          relationships.push({\n            sourceClass: className,\n            fieldName,\n            targetClass: field.options.related,\n            type: 'foreignKey',\n            options: field.options,\n          });\n        }\n\n        // Check for oneToMany relationships\n        if (field.type === 'oneToMany' && field.options?.related) {\n          relationships.push({\n            sourceClass: className,\n            fieldName,\n            targetClass: field.options.related,\n            type: 'oneToMany',\n            options: field.options,\n          });\n        }\n\n        // Check for manyToMany relationships\n        if (field.type === 'manyToMany' && field.options?.related) {\n          relationships.push({\n            sourceClass: className,\n            fieldName,\n            targetClass: field.options.related,\n            type: 'manyToMany',\n            options: field.options,\n          });\n        }\n      }\n\n      relationshipMap.set(className, relationships);\n    }\n\n    return relationshipMap;\n  }\n\n  /**\n   * Get relationships for a specific class\n   *\n   * @param className - Name of the class to get relationships for\n   * @returns Array of relationship metadata for the class\n   * @example\n   * ```typescript\n   * const orderRelationships = ObjectRegistry.getRelationships('Order');\n   * // [{ sourceClass: 'Order', fieldName: 'customerId', ... }]\n   * ```\n   */\n  static getRelationships(className: string): RelationshipMetadata[] {\n    return ObjectRegistry.getRelationshipMap().get(className) || [];\n  }\n\n  /**\n   * Get complete metadata for a single object (convenience method)\n   *\n   * Returns all available metadata for an object in a single call, including:\n   * - Class information\n   * - Field definitions\n   * - Configuration\n   * - Schema definition\n   * - Validators\n   * - Relationships\n   * - Tools (AI-callable methods)\n   *\n   * This is a convenience method that aggregates multiple registry queries\n   * into a single comprehensive metadata object.\n   *\n   * @param className - Name of the class to get metadata for\n   * @returns Complete metadata object or null if class not found\n   * @example\n   * ```typescript\n   * const productMeta = ObjectRegistry.getObjectMetadata('Product');\n   * if (productMeta) {\n   *   console.log('Name:', productMeta.name);\n   *   console.log('Table:', productMeta.schema.tableName);\n   *   console.log('Fields:', productMeta.fields.size);\n   *   console.log('API config:', productMeta.config.api);\n   *   console.log('Relationships:', productMeta.relationships.length);\n   * }\n   * ```\n   */\n  static getObjectMetadata(className: string): {\n    name: string;\n    constructor: typeof SmrtObject;\n    collectionConstructor?: new (options: any) => SmrtCollection<any>;\n    config: SmartObjectConfig;\n    fields: Map<string, any>;\n    schema: SchemaDefinition | undefined;\n    validators: ValidatorFunction[];\n    relationships: RelationshipMetadata[];\n    inverseRelationships: RelationshipMetadata[];\n    tools?: Array<{\n      type: 'function';\n      function: {\n        name: string;\n        description?: string;\n        parameters?: Record<string, any>;\n      };\n    }>;\n  } | null {\n    const registered = ObjectRegistry.findClass(className);\n    if (!registered) {\n      return null;\n    }\n\n    return {\n      name: registered.name,\n      constructor: registered.constructor,\n      collectionConstructor: registered.collectionConstructor,\n      config: registered.config,\n      fields: new Map(registered.fields), // Return copy to prevent mutations\n      schema: registered.schema,\n      validators: registered.validators || [],\n      relationships: ObjectRegistry.getRelationships(className),\n      inverseRelationships: ObjectRegistry.getInverseRelationships(className),\n      tools: registered.tools,\n    };\n  }\n\n  /**\n   * Get metadata for all registered objects (convenience method)\n   *\n   * Returns comprehensive metadata for every registered object, combining\n   * multiple registry queries into a single convenient data structure.\n   *\n   * This is particularly useful for:\n   * - Admin dashboards showing all objects\n   * - Documentation generation\n   * - Schema visualization\n   * - Debugging and introspection\n   *\n   * @returns Array of complete metadata objects for all registered classes\n   * @example\n   * ```typescript\n   * const allMetadata = ObjectRegistry.getAllObjectMetadata();\n   *\n   * // Generate admin dashboard\n   * for (const meta of allMetadata) {\n   *   console.log(`${meta.name}:`);\n   *   console.log(`  Table: ${meta.schema?.tableName}`);\n   *   console.log(`  Fields: ${meta.fields.size}`);\n   *   console.log(`  API: ${meta.config.api ? 'enabled' : 'disabled'}`);\n   *   console.log(`  Relationships: ${meta.relationships.length}`);\n   * }\n   *\n   * // Generate schema documentation\n   * const schemaDoc = allMetadata.map(meta => ({\n   *   name: meta.name,\n   *   table: meta.schema?.tableName,\n   *   fields: Array.from(meta.fields.entries()).map(([name, field]) => ({\n   *     name,\n   *     type: field.type,\n   *     required: field.options?.required || false\n   *   })),\n   *   relationships: meta.relationships.map(rel => ({\n   *     field: rel.fieldName,\n   *     target: rel.targetClass,\n   *     type: rel.type\n   *   }))\n   * }));\n   * ```\n   */\n  static getAllObjectMetadata(): Array<{\n    name: string;\n    constructor: typeof SmrtObject;\n    collectionConstructor?: new (options: any) => SmrtCollection<any>;\n    config: SmartObjectConfig;\n    fields: Map<string, any>;\n    schema: SchemaDefinition | undefined;\n    validators: ValidatorFunction[];\n    relationships: RelationshipMetadata[];\n    inverseRelationships: RelationshipMetadata[];\n    tools?: Array<{\n      type: 'function';\n      function: {\n        name: string;\n        description?: string;\n        parameters?: Record<string, any>;\n      };\n    }>;\n  }> {\n    const allMetadata: Array<any> = [];\n\n    for (const [className] of ObjectRegistry.classes) {\n      const metadata = ObjectRegistry.getObjectMetadata(className);\n      if (metadata) {\n        allMetadata.push(metadata);\n      }\n    }\n\n    return allMetadata;\n  }\n\n  /**\n   * Get inverse relationships (relationships where this class is the target)\n   *\n   * @param className - Name of the class to find inverse relationships for\n   * @returns Array of relationship metadata where this class is the target\n   * @example\n   * ```typescript\n   * const customerInverseRels = ObjectRegistry.getInverseRelationships('Customer');\n   * // [{ sourceClass: 'Order', fieldName: 'customerId', targetClass: 'Customer', ... }]\n   * ```\n   */\n  static getInverseRelationships(className: string): RelationshipMetadata[] {\n    const allRelationships = ObjectRegistry.getRelationshipMap();\n    const inverseRelationships: RelationshipMetadata[] = [];\n\n    for (const [_sourceClass, relationships] of allRelationships) {\n      for (const rel of relationships) {\n        if (rel.targetClass === className) {\n          inverseRelationships.push(rel);\n        }\n      }\n    }\n\n    return inverseRelationships;\n  }\n\n  /**\n   * Persist registry state to system tables\n   *\n   * Saves all registered class metadata to the _smrt_registry system table\n   * for runtime introspection and debugging. This enables applications to\n   * query what SMRT objects exist and their configurations.\n   *\n   * @param db - Database interface to persist to\n   * @returns Promise that resolves when persistence is complete\n   * @example\n   * ```typescript\n   * // After registering all classes\n   * await ObjectRegistry.persistToDatabase(db);\n   *\n   * // Later, query the system table\n   * const rows = await db.all('SELECT * FROM _smrt_registry');\n   * console.log('Registered classes:', rows.map(r => r.class_name));\n   * ```\n   */\n  static async persistToDatabase(\n    db: import('@have/sql').DatabaseInterface,\n  ): Promise<void> {\n    for (const [className, registered] of ObjectRegistry.classes.entries()) {\n      const fieldsData: any = {};\n      for (const [key, value] of registered.fields) {\n        fieldsData[key] = {\n          type: value.type,\n          options: value.options,\n        };\n      }\n\n      await db.query(\n        `INSERT OR REPLACE INTO _smrt_registry\n         (class_name, schema_version, fields, relationships, config, manifest, last_updated)\n         VALUES (?, ?, ?, ?, ?, ?, ?)`,\n        className,\n        '1.0.0', // Could be derived from package version\n        JSON.stringify(fieldsData),\n        JSON.stringify(ObjectRegistry.getRelationships(className)),\n        JSON.stringify(registered.config),\n        JSON.stringify({\n          name: registered.name,\n          tableName: registered.schema?.tableName,\n          tools: registered.tools,\n        }),\n        new Date(),\n      );\n    }\n  }\n\n  /**\n   * Load registry metadata from system tables\n   *\n   * Reads the _smrt_registry system table to inspect what classes\n   * have been registered. This is primarily for introspection and\n   * debugging - actual class registration happens via @smrt() decorator.\n   *\n   * @param db - Database interface to load from\n   * @returns Promise resolving to array of class metadata\n   * @example\n   * ```typescript\n   * const metadata = await ObjectRegistry.loadFromDatabase(db);\n   * for (const meta of metadata) {\n   *   console.log(`Class: ${meta.class_name}`);\n   *   console.log(`Table: ${JSON.parse(meta.manifest).tableName}`);\n   * }\n   * ```\n   */\n  static async loadFromDatabase(\n    db: import('@have/sql').DatabaseInterface,\n  ): Promise<any[]> {\n    const { rows } = await db.query(\n      'SELECT * FROM _smrt_registry ORDER BY class_name',\n    );\n    return rows;\n  }\n}\n\n/**\n * @smrt decorator for registering classes with the global registry\n *\n * Captures the original class name before minification and stores it as\n * a static property, ensuring table names remain consistent in production builds.\n *\n * @example\n * ```typescript\n * @smrt()\n * class Product extends SmrtObject {\n *   name = text({ required: true });\n *   price = decimal({ min: 0 });\n * }\n *\n * @smrt({ tableName: 'custom_products' })\n * class Product extends SmrtObject {\n *   name = text({ required: true });\n * }\n *\n * @smrt({ api: { exclude: ['delete'] } })\n * class SensitiveData extends SmrtObject {\n *   secret = text({ encrypted: true });\n * }\n * ```\n */\nexport function smrt(config: SmartObjectConfig = {}) {\n  return <T extends typeof SmrtObject>(ctor: T): T => {\n    // Capture table name BEFORE minification (decorator runs at class definition time)\n    // This ensures the table name survives code minification\n    const tableName = config.tableName || classnameToTablename(ctor.name);\n\n    // Store table name in a static property that survives minification\n    Object.defineProperty(ctor, 'SMRT_TABLE_NAME', {\n      value: tableName,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    });\n\n    // Register with the captured table name\n    ObjectRegistry.register(ctor, { ...config, tableName });\n    return ctor;\n  };\n}\n"],"names":[],"mappings":"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"}