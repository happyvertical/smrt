{"version":3,"file":"index.js","sources":["../src/models/Place.ts","../src/models/PlaceType.ts","../src/collections/PlaceTypeCollection.ts","../src/collections/PlaceCollection.ts","../src/utils.ts"],"sourcesContent":["/**\n * Place model - Core entity for hierarchical place management\n *\n * Supports both real-world places with geo data and abstract places\n * (virtual worlds, game zones) by making all geo fields optional.\n */\n\nimport { SmrtObject, smrt } from '@smrt/core';\nimport type { GeoData, PlaceOptions } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class Place extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n\n  // Core fields\n  typeId = ''; // FK to PlaceType\n  parentId = ''; // FK to parent Place for hierarchy (nullable)\n  name = ''; // Place name/title\n  description = ''; // Optional description\n\n  // Optional geo fields (all nullable for abstract places)\n  latitude: number | null = null;\n  longitude: number | null = null;\n  streetNumber = '';\n  streetName = '';\n  city = '';\n  region = '';\n  country = '';\n  postalCode = '';\n  countryCode = '';\n  timezone = '';\n\n  // Metadata\n  externalId = ''; // External system identifier\n  source = ''; // Where this place came from (e.g., 'google', 'osm')\n  metadata = ''; // JSON metadata stored as text\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: PlaceOptions = {}) {\n    super(options);\n\n    // Core fields\n    if (options.typeId) this.typeId = options.typeId;\n    if (options.parentId !== undefined) this.parentId = options.parentId;\n    if (options.name) this.name = options.name;\n    if (options.description !== undefined)\n      this.description = options.description;\n\n    // Geo fields\n    if (options.latitude !== undefined) this.latitude = options.latitude;\n    if (options.longitude !== undefined) this.longitude = options.longitude;\n    if (options.streetNumber !== undefined)\n      this.streetNumber = options.streetNumber;\n    if (options.streetName !== undefined) this.streetName = options.streetName;\n    if (options.city !== undefined) this.city = options.city;\n    if (options.region !== undefined) this.region = options.region;\n    if (options.country !== undefined) this.country = options.country;\n    if (options.postalCode !== undefined) this.postalCode = options.postalCode;\n    if (options.countryCode !== undefined)\n      this.countryCode = options.countryCode;\n    if (options.timezone !== undefined) this.timezone = options.timezone;\n\n    // Metadata\n    if (options.externalId !== undefined) this.externalId = options.externalId;\n    if (options.source !== undefined) this.source = options.source;\n\n    // Handle metadata - can be object or JSON string\n    if (options.metadata !== undefined) {\n      if (typeof options.metadata === 'string') {\n        this.metadata = options.metadata;\n      } else {\n        this.metadata = JSON.stringify(options.metadata);\n      }\n    }\n\n    // Timestamps\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get geographic data for this place\n   *\n   * @returns GeoData object with all geo fields\n   */\n  getGeoData(): GeoData {\n    return {\n      latitude: this.latitude,\n      longitude: this.longitude,\n      streetNumber: this.streetNumber || undefined,\n      streetName: this.streetName || undefined,\n      city: this.city || undefined,\n      region: this.region || undefined,\n      country: this.country || undefined,\n      postalCode: this.postalCode || undefined,\n      countryCode: this.countryCode || undefined,\n      timezone: this.timezone || undefined,\n    };\n  }\n\n  /**\n   * Check if this place has geographic coordinates\n   *\n   * @returns True if latitude and longitude are set\n   */\n  hasCoordinates(): boolean {\n    return this.latitude !== null && this.longitude !== null;\n  }\n\n  /**\n   * Get metadata as parsed object\n   *\n   * @returns Parsed metadata object or empty object if no metadata\n   */\n  getMetadata(): Record<string, any> {\n    if (!this.metadata) return {};\n    try {\n      return JSON.parse(this.metadata);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set metadata from object\n   *\n   * @param data - Metadata object to store\n   */\n  setMetadata(data: Record<string, any>): void {\n    this.metadata = JSON.stringify(data);\n  }\n\n  /**\n   * Update metadata by merging with existing values\n   *\n   * @param updates - Partial metadata to merge\n   */\n  updateMetadata(updates: Record<string, any>): void {\n    const current = this.getMetadata();\n    this.setMetadata({ ...current, ...updates });\n  }\n\n  /**\n   * Get the place type\n   *\n   * @returns PlaceType instance or null if not found\n   */\n  async getType() {\n    if (!this.typeId) return null;\n\n    const { PlaceTypeCollection } = await import(\n      '../collections/PlaceTypeCollection'\n    );\n    const collection = await PlaceTypeCollection.create(this.options);\n\n    return await collection.get({ id: this.typeId });\n  }\n\n  /**\n   * Get the parent place\n   *\n   * @returns Parent Place instance or null if no parent\n   */\n  async getParent(): Promise<Place | null> {\n    if (!this.parentId) return null;\n\n    const { PlaceCollection } = await import('../collections/PlaceCollection');\n    const collection = await PlaceCollection.create(this.options);\n\n    return await collection.get({ id: this.parentId });\n  }\n\n  /**\n   * Get immediate child places\n   *\n   * @returns Array of child Place instances\n   */\n  async getChildren(): Promise<Place[]> {\n    const { PlaceCollection } = await import('../collections/PlaceCollection');\n    const collection = await PlaceCollection.create(this.options);\n\n    return await collection.list({ where: { parentId: this.id } });\n  }\n\n  /**\n   * Get all ancestor places (recursive)\n   *\n   * @returns Array of ancestor places from root to immediate parent\n   */\n  async getAncestors(): Promise<Place[]> {\n    const ancestors: Place[] = [];\n    let currentPlace: Place | null = this;\n\n    while (currentPlace?.parentId) {\n      const parent = await currentPlace.getParent();\n      if (!parent) break;\n      ancestors.unshift(parent); // Add to beginning\n      currentPlace = parent;\n    }\n\n    return ancestors;\n  }\n\n  /**\n   * Get all descendant places (recursive)\n   *\n   * @returns Array of all descendant places\n   */\n  async getDescendants(): Promise<Place[]> {\n    const children = await this.getChildren();\n    const descendants: Place[] = [...children];\n\n    for (const child of children) {\n      const childDescendants = await child.getDescendants();\n      descendants.push(...childDescendants);\n    }\n\n    return descendants;\n  }\n\n  /**\n   * Get full hierarchy for this place\n   *\n   * @returns PlaceHierarchy with ancestors, current, and descendants\n   */\n  async getHierarchy(): Promise<{\n    ancestors: Place[];\n    current: Place;\n    descendants: Place[];\n  }> {\n    const [ancestors, descendants] = await Promise.all([\n      this.getAncestors(),\n      this.getDescendants(),\n    ]);\n\n    return {\n      ancestors,\n      current: this,\n      descendants,\n    };\n  }\n}\n","/**\n * PlaceType model - Defines types/categories of places\n *\n * Examples: 'country', 'city', 'building', 'zone', 'room', 'region'\n */\n\nimport { SmrtObject, smrt } from '@smrt/core';\nimport type { PlaceTypeOptions } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create'] },\n  cli: true,\n})\nexport class PlaceType extends SmrtObject {\n  // id and slug are inherited from SmrtObject\n  // name is also inherited from SmrtObject\n  description = ''; // Optional description\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: PlaceTypeOptions = {}) {\n    super(options);\n    if (options.description !== undefined)\n      this.description = options.description;\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Convenience method for slug-based lookup\n   *\n   * @param slug - The slug to search for\n   * @returns PlaceType instance or null if not found\n   */\n  static async getBySlug(_slug: string): Promise<PlaceType | null> {\n    // Will be auto-implemented by SMRT\n    return null;\n  }\n}\n","/**\n * PlaceTypeCollection - Collection manager for PlaceType objects\n *\n * Provides simple lookup and creation for place types.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { PlaceType } from '../models/PlaceType';\n\nexport class PlaceTypeCollection extends SmrtCollection<PlaceType> {\n  static readonly _itemClass = PlaceType;\n\n  /**\n   * Get or create a place type by slug\n   *\n   * @param slug - PlaceType slug (e.g., 'city', 'building')\n   * @param name - Optional display name (defaults to capitalized slug)\n   * @returns PlaceType instance\n   */\n  async getOrCreate(slug: string, name?: string): Promise<PlaceType> {\n    // First try to find existing type with this slug\n    const existing = await this.get({ slug });\n\n    if (existing) {\n      return existing;\n    }\n\n    // Create new type with auto-generated name if not provided\n    const displayName =\n      name || slug.replace(/-/g, ' ').replace(/\\b\\w/g, (l) => l.toUpperCase());\n\n    return await this.create({\n      slug,\n      name: displayName,\n    });\n  }\n\n  /**\n   * Get a place type by slug\n   *\n   * @param slug - PlaceType slug to search for\n   * @returns PlaceType instance or null if not found\n   */\n  async getBySlug(slug: string): Promise<PlaceType | null> {\n    return await this.get({ slug });\n  }\n\n  /**\n   * Initialize default place types\n   *\n   * Creates standard types if they don't exist:\n   * - country\n   * - region (state/province)\n   * - city\n   * - address\n   * - building\n   * - room\n   * - zone (for abstract/virtual places)\n   *\n   * @returns Array of created/existing place types\n   */\n  async initializeDefaults(): Promise<PlaceType[]> {\n    const defaults = [\n      { slug: 'country', name: 'Country' },\n      { slug: 'region', name: 'Region' },\n      { slug: 'city', name: 'City' },\n      { slug: 'address', name: 'Address' },\n      { slug: 'building', name: 'Building' },\n      { slug: 'room', name: 'Room' },\n      { slug: 'zone', name: 'Zone' },\n      { slug: 'point_of_interest', name: 'Point of Interest' },\n    ];\n\n    const types: PlaceType[] = [];\n    for (const def of defaults) {\n      const type = await this.getOrCreate(def.slug, def.name);\n      types.push(type);\n    }\n\n    return types;\n  }\n}\n","/**\n * PlaceCollection - Collection manager for Place objects\n *\n * Provides hierarchy traversal and organic place database growth via\n * lookupOrCreate method that integrates with @have/geo.\n */\n\nimport type { Location } from '@have/geo';\nimport { getGeoAdapter } from '@have/geo';\nimport { SmrtCollection } from '@smrt/core';\nimport { Place } from '../models/Place';\nimport type { LookupOrCreateOptions } from '../types';\nimport { PlaceTypeCollection } from './PlaceTypeCollection';\n\nexport class PlaceCollection extends SmrtCollection<Place> {\n  static readonly _itemClass = Place;\n\n  /**\n   * Look up a place by query or coordinates, creating it if not found\n   *\n   * This is the key method for organic database growth:\n   * 1. Search local database first\n   * 2. If not found, query @have/geo\n   * 3. Create place from geocoding result\n   * 4. Return place\n   *\n   * @param query - Address or location query string\n   * @param options - Lookup options (provider, type, parent, etc.)\n   * @returns Place instance\n   */\n  async lookupOrCreate(\n    query: string,\n    options: LookupOrCreateOptions = {},\n  ): Promise<Place | null> {\n    const {\n      geoProvider = 'openstreetmap',\n      typeSlug,\n      parentId,\n      createIfNotFound = true,\n      coords,\n    } = options;\n\n    // Step 1: Try to find existing place\n    let existingPlace: Place | null = null;\n\n    // Search by coordinates if provided\n    if (coords) {\n      existingPlace = await this.findByCoordinates(coords.lat, coords.lng);\n    }\n\n    // Search by query text if coordinates didn't match\n    if (!existingPlace) {\n      existingPlace = await this.findByQuery(query);\n    }\n\n    if (existingPlace) {\n      return existingPlace;\n    }\n\n    // Step 2: If not found and createIfNotFound is false, return null\n    if (!createIfNotFound) {\n      return null;\n    }\n\n    // Step 3: Query @have/geo for location data\n    const locations = await this.geocode(\n      query,\n      coords,\n      geoProvider as 'google' | 'openstreetmap',\n    );\n\n    if (locations.length === 0) {\n      return null;\n    }\n\n    // Use first result (most relevant)\n    const location = locations[0];\n\n    // Step 4: Create place from location data\n    return await this.createFromLocation(location, typeSlug, parentId);\n  }\n\n  /**\n   * Find place by coordinates (within small threshold)\n   *\n   * @param latitude - Latitude to search\n   * @param longitude - Longitude to search\n   * @param threshold - Max distance in degrees (default: 0.0001 ~11m)\n   * @returns Place instance or null\n   */\n  private async findByCoordinates(\n    latitude: number,\n    longitude: number,\n    threshold: number = 0.0001,\n  ): Promise<Place | null> {\n    // Get all places with coordinates\n    const places = await this.list({\n      where: {\n        latitude: { $ne: null },\n        longitude: { $ne: null },\n      },\n    });\n\n    // Find closest match within threshold\n    for (const place of places) {\n      if (place.latitude === null || place.longitude === null) continue;\n\n      const latDiff = Math.abs(place.latitude - latitude);\n      const lngDiff = Math.abs(place.longitude - longitude);\n\n      if (latDiff < threshold && lngDiff < threshold) {\n        return place;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find place by query text (matches name, city, region, country)\n   *\n   * @param query - Search query\n   * @returns Place instance or null\n   */\n  private async findByQuery(query: string): Promise<Place | null> {\n    const normalizedQuery = query.toLowerCase().trim();\n\n    // Try exact match on name first\n    const places = await this.list({});\n\n    for (const place of places) {\n      // Match on name\n      if (place.name.toLowerCase().includes(normalizedQuery)) {\n        return place;\n      }\n\n      // Match on full address components\n      const addressParts = [\n        place.streetNumber,\n        place.streetName,\n        place.city,\n        place.region,\n        place.country,\n      ]\n        .filter((p) => p)\n        .join(' ')\n        .toLowerCase();\n\n      if (addressParts.includes(normalizedQuery)) {\n        return place;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Geocode query or coordinates using @have/geo\n   *\n   * @param query - Address query\n   * @param coords - Optional coordinates for reverse geocoding\n   * @param provider - Geo provider to use\n   * @returns Array of Location results\n   */\n  private async geocode(\n    query: string,\n    coords?: { lat: number; lng: number },\n    provider: 'google' | 'openstreetmap' = 'openstreetmap',\n  ): Promise<Location[]> {\n    // Get geo adapter based on provider\n    const geoOptions =\n      provider === 'google'\n        ? {\n            provider: 'google' as const,\n            apiKey: process.env.GOOGLE_MAPS_API_KEY || '',\n          }\n        : {\n            provider: 'openstreetmap' as const,\n            userAgent: '@have/places',\n          };\n\n    const geo = await getGeoAdapter(geoOptions);\n\n    // Use reverse geocode if coords provided, otherwise forward geocode\n    if (coords) {\n      return await geo.reverseGeocode(coords.lat, coords.lng);\n    }\n\n    return await geo.lookup(query);\n  }\n\n  /**\n   * Create place from @have/geo Location data\n   *\n   * @param location - Location from geocoding\n   * @param typeSlug - Optional type slug override\n   * @param parentId - Optional parent place ID\n   * @returns Created Place instance\n   */\n  private async createFromLocation(\n    location: Location,\n    typeSlug?: string,\n    parentId?: string,\n  ): Promise<Place> {\n    // Get or create place type\n    const typeCollection = await PlaceTypeCollection.create(this.options);\n\n    const slug = typeSlug || location.type || 'address';\n    const placeType = await typeCollection.getOrCreate(slug);\n\n    // Extract address components\n    const components = location.addressComponents || {};\n\n    // Create place\n    return await this.create({\n      typeId: placeType.id,\n      parentId: parentId || '',\n      name: location.name,\n      description: '',\n\n      // Geo fields from location\n      latitude: location.latitude,\n      longitude: location.longitude,\n      streetNumber: components.streetNumber || '',\n      streetName: components.streetName || '',\n      city: components.city || '',\n      region: components.region || '',\n      country: components.country || '',\n      postalCode: components.postalCode || '',\n      countryCode: location.countryCode || '',\n      timezone: location.timezone || '',\n\n      // Metadata\n      externalId: location.id,\n      source: location.raw?.provider || 'unknown',\n      metadata: { raw: location.raw },\n    });\n  }\n\n  /**\n   * Get immediate children of a parent place\n   *\n   * @param parentId - The parent place ID\n   * @returns Array of child places\n   */\n  async getChildren(parentId: string): Promise<Place[]> {\n    return await this.list({\n      where: { parentId },\n    });\n  }\n\n  /**\n   * Get root places (no parent)\n   *\n   * @returns Array of root places\n   */\n  async getRootPlaces(): Promise<Place[]> {\n    return await this.list({\n      where: { parentId: '' },\n    });\n  }\n\n  /**\n   * Get places by type\n   *\n   * @param typeSlug - PlaceType slug\n   * @returns Array of places of that type\n   */\n  async getByType(typeSlug: string): Promise<Place[]> {\n    // Get type ID\n    const typeCollection = await PlaceTypeCollection.create(this.options);\n\n    const placeType = await typeCollection.getBySlug(typeSlug);\n    if (!placeType) return [];\n\n    return await this.list({\n      where: { typeId: placeType.id },\n    });\n  }\n\n  /**\n   * Get place hierarchy (all ancestors and descendants)\n   *\n   * @param placeId - The place ID\n   * @returns Object with ancestors, current place, and descendants\n   */\n  async getHierarchy(placeId: string) {\n    const place = await this.get({ id: placeId });\n    if (!place) throw new Error(`Place '${placeId}' not found`);\n\n    return await place.getHierarchy();\n  }\n\n  /**\n   * Search places by proximity to coordinates\n   *\n   * @param latitude - Center latitude\n   * @param longitude - Center longitude\n   * @param radiusKm - Search radius in kilometers\n   * @returns Array of places within radius, sorted by distance\n   */\n  async searchByProximity(\n    latitude: number,\n    longitude: number,\n    radiusKm: number = 10,\n  ): Promise<Place[]> {\n    // Get all places with coordinates\n    const places = await this.list({\n      where: {\n        latitude: { $ne: null },\n        longitude: { $ne: null },\n      },\n    });\n\n    // Calculate distances and filter by radius\n    const placesWithDistance = places\n      .map((place) => {\n        if (place.latitude === null || place.longitude === null) return null;\n\n        const distance = this.calculateDistance(\n          latitude,\n          longitude,\n          place.latitude,\n          place.longitude,\n        );\n\n        return { place, distance };\n      })\n      .filter((p) => p !== null && p.distance <= radiusKm)\n      .sort((a, b) => a?.distance - b?.distance);\n\n    return placesWithDistance.map((p) => p?.place);\n  }\n\n  /**\n   * Calculate distance between two coordinates using Haversine formula\n   *\n   * @param lat1 - First latitude\n   * @param lng1 - First longitude\n   * @param lat2 - Second latitude\n   * @param lng2 - Second longitude\n   * @returns Distance in kilometers\n   */\n  private calculateDistance(\n    lat1: number,\n    lng1: number,\n    lat2: number,\n    lng2: number,\n  ): number {\n    const R = 6371; // Earth radius in km\n    const dLat = this.toRad(lat2 - lat1);\n    const dLng = this.toRad(lng2 - lng1);\n\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(this.toRad(lat1)) *\n        Math.cos(this.toRad(lat2)) *\n        Math.sin(dLng / 2) *\n        Math.sin(dLng / 2);\n\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n\n  /**\n   * Convert degrees to radians\n   */\n  private toRad(degrees: number): number {\n    return degrees * (Math.PI / 180);\n  }\n}\n","/**\n * Utility functions for @have/places package\n */\n\nimport type { Location } from '@have/geo';\nimport type { GeoData } from './types';\n\n/**\n * Map Location type from @have/geo to PlaceType slug\n *\n * @param locationType - Location type from geocoding provider\n * @returns PlaceType slug\n */\nexport function mapLocationTypeToPlaceType(locationType: string): string {\n  const typeMap: Record<string, string> = {\n    // Standard types\n    country: 'country',\n    region: 'region',\n    city: 'city',\n    address: 'address',\n    point_of_interest: 'point_of_interest',\n\n    // Additional mappings\n    state: 'region',\n    province: 'region',\n    town: 'city',\n    village: 'city',\n    building: 'building',\n    room: 'room',\n    zone: 'zone',\n  };\n\n  return typeMap[locationType.toLowerCase()] || 'address';\n}\n\n/**\n * Convert Location from @have/geo to GeoData\n *\n * @param location - Location from geocoding\n * @returns GeoData object\n */\nexport function locationToGeoData(location: Location): GeoData {\n  const components = location.addressComponents || {};\n\n  return {\n    latitude: location.latitude,\n    longitude: location.longitude,\n    streetNumber: components.streetNumber,\n    streetName: components.streetName,\n    city: components.city,\n    region: components.region,\n    country: components.country,\n    postalCode: components.postalCode,\n    countryCode: location.countryCode,\n    timezone: location.timezone,\n  };\n}\n\n/**\n * Validate geographic coordinates\n *\n * @param latitude - Latitude value\n * @param longitude - Longitude value\n * @returns Object with valid flag and optional error message\n */\nexport function validateCoordinates(\n  latitude: number,\n  longitude: number,\n): { valid: boolean; error?: string } {\n  if (latitude < -90 || latitude > 90) {\n    return { valid: false, error: 'Invalid latitude (must be -90 to 90)' };\n  }\n\n  if (longitude < -180 || longitude > 180) {\n    return { valid: false, error: 'Invalid longitude (must be -180 to 180)' };\n  }\n\n  return { valid: true };\n}\n\n/**\n * Calculate distance between two coordinates using Haversine formula\n *\n * @param lat1 - First latitude\n * @param lng1 - First longitude\n * @param lat2 - Second latitude\n * @param lng2 - Second longitude\n * @returns Distance in kilometers\n */\nexport function calculateDistance(\n  lat1: number,\n  lng1: number,\n  lat2: number,\n  lng2: number,\n): number {\n  const R = 6371; // Earth radius in km\n  const dLat = toRad(lat2 - lat1);\n  const dLng = toRad(lng2 - lng1);\n\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRad(lat1)) *\n      Math.cos(toRad(lat2)) *\n      Math.sin(dLng / 2) *\n      Math.sin(dLng / 2);\n\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n}\n\n/**\n * Convert degrees to radians\n */\nfunction toRad(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n/**\n * Format coordinates as string\n *\n * @param latitude - Latitude value\n * @param longitude - Longitude value\n * @param precision - Number of decimal places (default: 6)\n * @returns Formatted coordinate string\n */\nexport function formatCoordinates(\n  latitude: number,\n  longitude: number,\n  precision: number = 6,\n): string {\n  return `${latitude.toFixed(precision)}, ${longitude.toFixed(precision)}`;\n}\n\n/**\n * Parse coordinate string to lat/lng\n *\n * Supports formats:\n * - \"lat, lng\"\n * - \"lat,lng\"\n * - \"lat lng\"\n *\n * @param coordString - Coordinate string\n * @returns Object with lat and lng, or null if invalid\n */\nexport function parseCoordinates(\n  coordString: string,\n): { lat: number; lng: number } | null {\n  // Remove extra whitespace and split\n  const parts = coordString\n    .trim()\n    .replace(/\\s+/g, ' ')\n    .replace(/,\\s*/g, ',')\n    .split(/[,\\s]+/);\n\n  if (parts.length !== 2) return null;\n\n  const lat = parseFloat(parts[0]);\n  const lng = parseFloat(parts[1]);\n\n  if (Number.isNaN(lat) || Number.isNaN(lng)) return null;\n\n  const validation = validateCoordinates(lat, lng);\n  if (!validation.valid) return null;\n\n  return { lat, lng };\n}\n\n/**\n * Normalize address components by trimming and removing empty values\n *\n * @param components - Address components\n * @returns Normalized components\n */\nexport function normalizeAddressComponents(\n  components: Partial<GeoData>,\n): Partial<GeoData> {\n  const normalized: Partial<GeoData> = {};\n\n  for (const [key, value] of Object.entries(components)) {\n    if (value === null || value === undefined) continue;\n\n    if (typeof value === 'string') {\n      const trimmed = value.trim();\n      if (trimmed) {\n        normalized[key as keyof GeoData] = trimmed as any;\n      }\n    } else {\n      normalized[key as keyof GeoData] = value as any;\n    }\n  }\n\n  return normalized;\n}\n\n/**\n * Generate a display name from address components\n *\n * @param components - Address components\n * @returns Formatted display name\n */\nexport function generateDisplayName(components: Partial<GeoData>): string {\n  const parts: string[] = [];\n\n  if (components.streetNumber && components.streetName) {\n    parts.push(`${components.streetNumber} ${components.streetName}`);\n  } else if (components.streetName) {\n    parts.push(components.streetName);\n  }\n\n  if (components.city) parts.push(components.city);\n  if (components.region) parts.push(components.region);\n  if (components.country) parts.push(components.country);\n\n  return parts.join(', ');\n}\n\n/**\n * Check if two coordinates are within a threshold distance\n *\n * @param lat1 - First latitude\n * @param lng1 - First longitude\n * @param lat2 - Second latitude\n * @param lng2 - Second longitude\n * @param thresholdKm - Distance threshold in kilometers\n * @returns True if coordinates are within threshold\n */\nexport function areCoordinatesNear(\n  lat1: number,\n  lng1: number,\n  lat2: number,\n  lng2: number,\n  thresholdKm: number = 0.1,\n): boolean {\n  const distance = calculateDistance(lat1, lng1, lat2, lng2);\n  return distance <= thresholdKm;\n}\n"],"names":["PlaceTypeCollection","PlaceCollection","_init"],"mappings":"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"}