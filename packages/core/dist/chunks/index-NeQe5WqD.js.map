{"version":3,"file":"index-NeQe5WqD.js","sources":["../../src/schema/generator.ts"],"sourcesContent":["/**\n * Schema generator for SMRT objects\n * Converts AST field definitions to database schema definitions\n */\n\nimport { createHash } from 'node:crypto';\nimport type { Field } from '../fields/index';\nimport type { FieldDefinition, SmartObjectDefinition } from '../scanner/types';\nimport type {\n  ColumnDefinition,\n  ForeignKeyDefinition,\n  IndexDefinition,\n  SchemaDefinition,\n  SQLDataType,\n  TriggerDefinition,\n} from './types';\n\nexport class SchemaGenerator {\n  /**\n   * Generate schema definition from SMRT object definition\n   */\n  generateSchema(objectDef: SmartObjectDefinition): SchemaDefinition {\n    const tableName = this.getTableName(objectDef);\n    const columns = this.generateColumns(objectDef.fields);\n    const indexes = this.generateIndexes(objectDef, columns);\n    const triggers = this.generateTriggers(objectDef, tableName);\n    const foreignKeys = this.extractForeignKeys(columns);\n    const dependencies = this.extractDependencies(objectDef, foreignKeys);\n    const version = this.generateVersion(objectDef);\n\n    return {\n      tableName,\n      columns,\n      indexes,\n      triggers,\n      foreignKeys,\n      dependencies,\n      version,\n      packageName: this.extractPackageName(objectDef.filePath),\n      baseClass: objectDef.extends,\n    };\n  }\n\n  /**\n   * Convert field type to SQL data type\n   */\n  private mapFieldTypeToSQL(fieldType: FieldDefinition['type']): SQLDataType {\n    switch (fieldType) {\n      case 'text':\n        return 'TEXT';\n      case 'integer':\n        return 'INTEGER';\n      case 'decimal':\n        return 'REAL';\n      case 'boolean':\n        return 'BOOLEAN';\n      case 'datetime':\n        return 'DATETIME';\n      case 'json':\n        return 'JSON';\n      case 'foreignKey':\n        return 'TEXT'; // Foreign keys are typically TEXT\n      default:\n        return 'TEXT'; // Default fallback\n    }\n  }\n\n  /**\n   * Generate column definitions\n   */\n  private generateColumns(\n    fields: Record<string, FieldDefinition>,\n  ): Record<string, ColumnDefinition> {\n    const columns: Record<string, ColumnDefinition> = {};\n\n    // Always include base SMRT fields\n    columns.id = {\n      type: 'TEXT',\n      primaryKey: true,\n      notNull: true,\n      description: 'Primary identifier',\n    };\n\n    columns.created_at = {\n      type: 'DATETIME',\n      notNull: true,\n      defaultValue: \"datetime('now')\",\n      description: 'Creation timestamp',\n    };\n\n    columns.updated_at = {\n      type: 'DATETIME',\n      notNull: true,\n      defaultValue: \"datetime('now')\",\n      description: 'Last update timestamp',\n    };\n\n    // Add fields from object definition\n    for (const [fieldName, fieldDef] of Object.entries(fields)) {\n      // Skip id fields as we handle them above\n      if (\n        fieldName === 'id' ||\n        fieldName === 'created_at' ||\n        fieldName === 'updated_at'\n      ) {\n        continue;\n      }\n\n      const column: ColumnDefinition = {\n        type: this.mapFieldTypeToSQL(fieldDef.type),\n        notNull: fieldDef.required || false,\n        description: fieldDef.description,\n      };\n\n      // Handle default values\n      if (fieldDef.default !== undefined) {\n        column.defaultValue = fieldDef.default;\n      } else if (\n        !fieldDef.required &&\n        this.mapFieldTypeToSQL(fieldDef.type) === 'TEXT'\n      ) {\n        // For TEXT columns without explicit default or required constraint,\n        // add NOT NULL DEFAULT '' to prevent DuckDB ANY type inference\n        // DuckDB infers ANY type for nullable TEXT columns without defaults\n        column.notNull = true;\n        column.defaultValue = '';\n      }\n\n      // Handle foreign keys\n      if (fieldDef.type === 'foreignKey' && fieldDef.related) {\n        const [table, columnName = 'id'] = fieldDef.related.split('.');\n        column.foreignKey = {\n          table,\n          column: columnName,\n          onDelete: 'CASCADE', // Default behavior\n          onUpdate: 'CASCADE',\n        };\n      }\n\n      // Handle unique constraints\n      if (fieldName === 'slug' || fieldName === 'email') {\n        column.unique = true;\n      }\n\n      columns[fieldName] = column;\n    }\n\n    return columns;\n  }\n\n  /**\n   * Generate index definitions\n   */\n  private generateIndexes(\n    objectDef: SmartObjectDefinition,\n    columns: Record<string, ColumnDefinition>,\n  ): IndexDefinition[] {\n    const indexes: IndexDefinition[] = [];\n    const tableName = this.getTableName(objectDef);\n\n    // Create indexes for foreign keys\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      if (columnDef.foreignKey) {\n        indexes.push({\n          name: `idx_${tableName}_${columnName}`,\n          columns: [columnName],\n          description: `Index for foreign key ${columnName}`,\n        });\n      }\n    }\n\n    // Create index for updated_at (common query pattern)\n    indexes.push({\n      name: `idx_${tableName}_updated_at`,\n      columns: ['updated_at'],\n      description: 'Index for timestamp queries',\n    });\n\n    // Create unique indexes\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      if (columnDef.unique && !columnDef.primaryKey) {\n        indexes.push({\n          name: `idx_${tableName}_${columnName}_unique`,\n          columns: [columnName],\n          unique: true,\n          description: `Unique index for ${columnName}`,\n        });\n      }\n    }\n\n    return indexes;\n  }\n\n  /**\n   * Generate trigger definitions for automatic timestamp updates\n   */\n  private generateTriggers(\n    _objectDef: SmartObjectDefinition,\n    tableName: string,\n  ): TriggerDefinition[] {\n    return [\n      {\n        name: `trg_${tableName}_updated_at`,\n        when: 'BEFORE',\n        event: 'UPDATE',\n        body: `UPDATE ${tableName} SET updated_at = datetime('now') WHERE id = NEW.id;`,\n        description: 'Automatically update updated_at timestamp',\n      },\n    ];\n  }\n\n  /**\n   * Extract foreign key definitions\n   */\n  private extractForeignKeys(\n    columns: Record<string, ColumnDefinition>,\n  ): ForeignKeyDefinition[] {\n    const foreignKeys: ForeignKeyDefinition[] = [];\n\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      if (columnDef.foreignKey) {\n        foreignKeys.push({\n          column: columnName,\n          referencesTable: columnDef.foreignKey.table,\n          referencesColumn: columnDef.foreignKey.column,\n          onDelete: columnDef.foreignKey.onDelete,\n          onUpdate: columnDef.foreignKey.onUpdate,\n        });\n      }\n    }\n\n    return foreignKeys;\n  }\n\n  /**\n   * Extract schema dependencies from foreign keys and inheritance\n   */\n  private extractDependencies(\n    objectDef: SmartObjectDefinition,\n    foreignKeys: ForeignKeyDefinition[],\n  ): string[] {\n    const dependencies = new Set<string>();\n\n    // Add dependencies from foreign keys\n    for (const fk of foreignKeys) {\n      dependencies.add(fk.referencesTable);\n    }\n\n    // Add dependencies from base class\n    if (\n      objectDef.extends &&\n      objectDef.extends !== 'SmrtObject' &&\n      objectDef.extends !== 'SmrtCollection'\n    ) {\n      dependencies.add(this.classNameToTableName(objectDef.extends));\n    }\n\n    return Array.from(dependencies);\n  }\n\n  /**\n   * Generate version hash for schema\n   */\n  private generateVersion(objectDef: SmartObjectDefinition): string {\n    const content = JSON.stringify({\n      className: objectDef.className,\n      fields: objectDef.fields,\n      extends: objectDef.extends,\n    });\n    return createHash('sha256').update(content).digest('hex').substring(0, 8);\n  }\n\n  /**\n   * Get table name from object definition\n   */\n  private getTableName(objectDef: SmartObjectDefinition): string {\n    return this.classNameToTableName(objectDef.className);\n  }\n\n  /**\n   * Convert class name to table name (camelCase to snake_case, pluralized)\n   */\n  private classNameToTableName(className: string): string {\n    return `${className\n      .replace(/([A-Z])/g, '_$1')\n      .toLowerCase()\n      .replace(/^_/, '')\n      .replace(/s$/, '')}s`; // Simple pluralization\n  }\n\n  /**\n   * Extract package name from file path\n   */\n  private extractPackageName(filePath: string): string {\n    const match = filePath.match(/packages\\/([^/]+)/);\n    return match ? match[1] : 'unknown';\n  }\n\n  /**\n   * Generate schema definition from ObjectRegistry fields (runtime)\n   *\n   * This method builds a SchemaDefinition from ObjectRegistry cached fields,\n   * enabling schema generation from decorated classes at runtime.\n   *\n   * @param className - Class name to look up in ObjectRegistry\n   * @param tableName - Table name (from SMRT_TABLE_NAME or derived)\n   * @param fields - Map of Field definitions from ObjectRegistry\n   * @returns Schema definition object\n   */\n  generateSchemaFromRegistry(\n    _className: string,\n    tableName: string,\n    fields: Map<string, Field>,\n  ): SchemaDefinition {\n    const columns: Record<string, ColumnDefinition> = {};\n\n    // Check for custom primary key\n    let hasCustomPK = false;\n    for (const [_fieldName, field] of fields.entries()) {\n      if (field.options?.primaryKey) {\n        hasCustomPK = true;\n        break;\n      }\n    }\n\n    // Add default SMRT fields if no custom primary key\n    if (!hasCustomPK) {\n      columns.id = {\n        type: 'TEXT',\n        primaryKey: true,\n        notNull: true,\n        description: 'Primary identifier',\n      };\n\n      columns.slug = {\n        type: 'TEXT',\n        notNull: true,\n        description: 'URL-friendly identifier',\n      };\n\n      columns.context = {\n        type: 'TEXT',\n        notNull: true,\n        defaultValue: '',\n        description: 'Context for slug scoping',\n      };\n    }\n\n    // Track timestamp fields to avoid duplicates\n    let hasCreatedAt = false;\n    let hasUpdatedAt = false;\n\n    // Add fields from ObjectRegistry\n    for (const [fieldName, field] of fields.entries()) {\n      // Skip default fields if already added\n      if (\n        !hasCustomPK &&\n        (fieldName === 'id' || fieldName === 'slug' || fieldName === 'context')\n      ) {\n        continue;\n      }\n\n      // Track timestamp fields\n      if (fieldName === 'created_at' || fieldName === 'createdAt') {\n        if (hasCreatedAt) continue;\n        hasCreatedAt = true;\n      }\n      if (fieldName === 'updated_at' || fieldName === 'updatedAt') {\n        if (hasUpdatedAt) continue;\n        hasUpdatedAt = true;\n      }\n\n      const sqlType = (field.getSqlType?.() || 'TEXT') as SQLDataType;\n\n      const columnDef: ColumnDefinition = {\n        type: sqlType,\n        notNull: field.options?.required || false,\n        primaryKey: field.options?.primaryKey || false,\n        unique: field.options?.unique || false,\n        description: field.options?.description,\n      };\n\n      // Get default value\n      if (field.options?.default !== undefined) {\n        columnDef.defaultValue = field.options.default;\n      } else if (!columnDef.notNull && columnDef.type === 'TEXT') {\n        // Prevent DuckDB ANY type inference for nullable TEXT columns\n        columnDef.notNull = true;\n        columnDef.defaultValue = '';\n      }\n\n      // Handle foreign keys\n      if (field.type === 'foreignKey') {\n        // Type cast to access relationship-specific properties\n        const relatedName = (field.options as any).related;\n        const onDeleteAction = (field.options as any).onDelete;\n\n        if (relatedName) {\n          columnDef.foreignKey = {\n            table: this.classNameToTableName(relatedName),\n            column: 'id',\n            onDelete: onDeleteAction || 'CASCADE',\n            onUpdate: 'CASCADE',\n          };\n        }\n      }\n\n      columns[this.toSnakeCase(fieldName)] = columnDef;\n    }\n\n    // Ensure timestamp columns exist\n    if (!hasCreatedAt) {\n      columns.created_at = {\n        type: 'DATETIME',\n        notNull: false,\n        description: 'Creation timestamp',\n      };\n    }\n    if (!hasUpdatedAt) {\n      columns.updated_at = {\n        type: 'DATETIME',\n        notNull: false,\n        description: 'Last update timestamp',\n      };\n    }\n\n    // Generate indexes\n    const indexes: IndexDefinition[] = [];\n\n    if (!hasCustomPK) {\n      indexes.push({\n        name: `${tableName}_id_idx`,\n        columns: ['id'],\n        description: 'Primary key index',\n      });\n\n      indexes.push({\n        name: `${tableName}_slug_context_idx`,\n        columns: ['slug', 'context'],\n        unique: true,\n        description: 'Unique index for slug and context',\n      });\n    } else {\n      // Find custom PK column and create index\n      for (const [colName, colDef] of Object.entries(columns)) {\n        if (colDef.primaryKey) {\n          indexes.push({\n            name: `${tableName}_${colName}_idx`,\n            columns: [colName],\n            description: `Primary key index`,\n          });\n          break;\n        }\n      }\n    }\n\n    // Create indexes for foreign keys\n    for (const [colName, colDef] of Object.entries(columns)) {\n      if (colDef.foreignKey) {\n        indexes.push({\n          name: `idx_${tableName}_${colName}`,\n          columns: [colName],\n          description: `Foreign key index for ${colName}`,\n        });\n      }\n    }\n\n    return {\n      tableName,\n      columns,\n      indexes,\n      triggers: [],\n      foreignKeys: this.extractForeignKeys(columns),\n      dependencies: [],\n      version: createHash('sha256')\n        .update(JSON.stringify(columns))\n        .digest('hex')\n        .substring(0, 8),\n      packageName: 'runtime',\n      baseClass: 'SmrtObject',\n    };\n  }\n\n  /**\n   * Convert camelCase to snake_case\n   */\n  private toSnakeCase(str: string): string {\n    return str\n      .replace(/([A-Z])/g, '_$1')\n      .toLowerCase()\n      .replace(/^_/, '');\n  }\n\n  /**\n   * Generate SQL CREATE TABLE statement from schema definition\n   *\n   * This is the single source of truth for SQL generation, consolidating\n   * logic that was previously duplicated across multiple code paths.\n   *\n   * @param schema - Schema definition object\n   * @returns SQL CREATE TABLE statement with indexes\n   */\n  generateSQL(schema: SchemaDefinition): string {\n    const { tableName, columns } = schema;\n\n    // Quote table name to handle SQL reserved keywords\n    let sql = `CREATE TABLE IF NOT EXISTS \"${tableName}\" (\\n`;\n\n    // Track which columns we've added\n    const addedColumns: string[] = [];\n\n    // Add all columns\n    for (const [columnName, columnDef] of Object.entries(columns)) {\n      const parts: string[] = [];\n\n      // Column name and type\n      parts.push(`  ${columnName} ${columnDef.type}`);\n\n      // Primary key\n      if (columnDef.primaryKey) {\n        parts.push('PRIMARY KEY');\n      }\n\n      // Not null constraint\n      if (columnDef.notNull) {\n        parts.push('NOT NULL');\n      }\n\n      // Unique constraint\n      if (columnDef.unique && !columnDef.primaryKey) {\n        parts.push('UNIQUE');\n      }\n\n      // Default value with CAST for DuckDB compatibility\n      if (columnDef.defaultValue !== undefined) {\n        const defaultSQL = this.formatDefaultValue(\n          columnDef.defaultValue,\n          columnDef.type,\n        );\n        parts.push(`DEFAULT ${defaultSQL}`);\n      }\n\n      sql += `${parts.join(' ')},\\n`;\n      addedColumns.push(columnName);\n    }\n\n    // Remove trailing comma and close table\n    sql = `${sql.slice(0, -2)}\\n);`;\n\n    // Add indexes\n    for (const index of schema.indexes) {\n      const indexType = index.unique ? 'UNIQUE INDEX' : 'INDEX';\n      const columnList = index.columns.join(', ');\n      sql += `\\nCREATE ${indexType} IF NOT EXISTS ${index.name} ON ${tableName} (${columnList});`;\n    }\n\n    return sql;\n  }\n\n  /**\n   * Format default value for SQL with proper CAST for DuckDB compatibility\n   *\n   * DuckDB requires explicit CAST for default values to prevent type inference issues.\n   *\n   * @param value - Default value\n   * @param type - Column SQL type\n   * @returns Formatted SQL default value expression\n   */\n  private formatDefaultValue(value: any, type: SQLDataType): string {\n    // Handle SQL expressions (like datetime('now'))\n    if (typeof value === 'string' && value.includes('(')) {\n      return value;\n    }\n\n    // Handle different types\n    if (type === 'TEXT') {\n      const stringValue = String(value);\n      return `CAST('${stringValue.replace(/'/g, \"''\")}' AS TEXT)`;\n    }\n\n    if (type === 'INTEGER' || type === 'REAL') {\n      return `CAST(${value} AS ${type})`;\n    }\n\n    if (type === 'BOOLEAN') {\n      return value ? 'TRUE' : 'FALSE';\n    }\n\n    if (type === 'DATETIME') {\n      if (typeof value === 'string') {\n        return `CAST('${value}' AS DATETIME)`;\n      }\n      return \"datetime('now')\";\n    }\n\n    // Fallback for other types\n    return `'${String(value).replace(/'/g, \"''\")}'`;\n  }\n}\n"],"names":[],"mappings":"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"}