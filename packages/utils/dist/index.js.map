{"version":3,"file":"index.js","sources":["../src/shared/code/extraction.ts","../src/shared/code/sandbox.ts","../src/shared/code/validation.ts","../src/shared/logger.ts","../src/shared/types.ts","../src/shared/universal.ts","../src/cli/parse-args.ts","../src/web.ts"],"sourcesContent":["/**\n * Code extraction utilities for parsing code from text (e.g., AI responses)\n *\n * Provides functions to extract code blocks, JSON data, and function definitions\n * from markdown-formatted text or AI-generated responses.\n */\n\n/**\n * Extracts a code block from markdown-formatted text\n *\n * @param text - The text containing markdown code blocks\n * @param language - Optional language specifier to match (e.g., 'javascript', 'typescript', 'json')\n * @returns The extracted code without markdown delimiters, or empty string if not found\n *\n * @example\n * ```typescript\n * const code = extractCodeBlock(`\n * Here's the function:\n * \\`\\`\\`javascript\n * function hello() {\n *   return 'world';\n * }\n * \\`\\`\\`\n * `, 'javascript');\n * // Returns: \"function hello() {\\n  return 'world';\\n}\"\n * ```\n */\nexport function extractCodeBlock(\n  text: string,\n  language?: string,\n): string {\n  if (!text) {\n    return '';\n  }\n\n  // Build regex pattern based on language\n  const langPattern = language ? `${language}\\\\s*` : '(?:\\\\w+\\\\s*)?';\n  const codeBlockRegex = new RegExp(\n    `\\`\\`\\`${langPattern}\\\\r?\\\\n([\\\\s\\\\S]*?)\\\\r?\\\\n\\`\\`\\``,\n    'i',\n  );\n\n  const match = text.match(codeBlockRegex);\n  if (match && match[1]) {\n    return match[1].trim();\n  }\n\n  // If no markdown code block found, check for inline code\n  const inlineRegex = /`([^`]+)`/;\n  const inlineMatch = text.match(inlineRegex);\n  if (inlineMatch && inlineMatch[1]) {\n    return inlineMatch[1].trim();\n  }\n\n  return '';\n}\n\n/**\n * Extracts and parses JSON from text, handling markdown code blocks\n *\n * @param text - The text containing JSON data\n * @returns The parsed JSON object\n * @throws {SyntaxError} If the JSON is invalid\n *\n * @example\n * ```typescript\n * const data = extractJSON<{ name: string }>(`\n * The result is:\n * \\`\\`\\`json\n * {\n *   \"name\": \"example\"\n * }\n * \\`\\`\\`\n * `);\n * // Returns: { name: \"example\" }\n * ```\n */\nexport function extractJSON<T = any>(text: string): T {\n  if (!text) {\n    throw new SyntaxError('Cannot extract JSON from empty text');\n  }\n\n  // First, try to extract from a JSON code block\n  let jsonText = extractCodeBlock(text, 'json');\n\n  // If no JSON code block, try to extract from any code block\n  if (!jsonText) {\n    jsonText = extractCodeBlock(text);\n  }\n\n  // If still no code block, try to find JSON in the raw text\n  if (!jsonText) {\n    // Look for JSON object or array patterns\n    const jsonObjectMatch = text.match(/\\{[\\s\\S]*\\}/);\n    const jsonArrayMatch = text.match(/\\[[\\s\\S]*\\]/);\n\n    if (jsonObjectMatch) {\n      jsonText = jsonObjectMatch[0];\n    } else if (jsonArrayMatch) {\n      jsonText = jsonArrayMatch[0];\n    } else {\n      // Last resort: use the whole text\n      jsonText = text.trim();\n    }\n  }\n\n  try {\n    return JSON.parse(jsonText) as T;\n  } catch (error) {\n    throw new SyntaxError(\n      `Failed to parse JSON: ${error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n}\n\n/**\n * Extracts all code blocks from markdown-formatted text\n *\n * @param text - The text containing markdown code blocks\n * @param language - Optional language specifier to filter by\n * @returns Array of extracted code blocks\n *\n * @example\n * ```typescript\n * const blocks = extractAllCodeBlocks(`\n * \\`\\`\\`javascript\n * const a = 1;\n * \\`\\`\\`\n *\n * \\`\\`\\`typescript\n * const b: number = 2;\n * \\`\\`\\`\n * `);\n * // Returns: [\"const a = 1;\", \"const b: number = 2;\"]\n * ```\n */\nexport function extractAllCodeBlocks(\n  text: string,\n  language?: string,\n): string[] {\n  if (!text) {\n    return [];\n  }\n\n  const langPattern = language ? `${language}\\\\s*` : '(?:\\\\w+\\\\s*)?';\n  const codeBlockRegex = new RegExp(\n    `\\`\\`\\`${langPattern}\\\\r?\\\\n([\\\\s\\\\S]*?)\\\\r?\\\\n\\`\\`\\``,\n    'gi',\n  );\n\n  const blocks: string[] = [];\n  let match: RegExpExecArray | null;\n\n  while ((match = codeBlockRegex.exec(text)) !== null) {\n    if (match[1]) {\n      blocks.push(match[1].trim());\n    }\n  }\n\n  return blocks;\n}\n\n/**\n * Extracts a specific function definition from code\n *\n * @param code - The code containing function definitions\n * @param functionName - The name of the function to extract\n * @returns The function definition, or empty string if not found\n *\n * @example\n * ```typescript\n * const code = `\n * function foo() { return 1; }\n * function bar() { return 2; }\n * `;\n *\n * const fooFunc = extractFunctionDefinition(code, 'foo');\n * // Returns: \"function foo() { return 1; }\"\n * ```\n */\nexport function extractFunctionDefinition(\n  code: string,\n  functionName: string,\n): string {\n  if (!code || !functionName) {\n    return '';\n  }\n\n  // Patterns to find the start of function definitions\n  const patterns = [\n    // function foo() { ... }\n    {\n      regex: new RegExp(\n        `function\\\\s+${functionName}\\\\s*\\\\([^)]*\\\\)\\\\s*\\\\{`,\n        'i',\n      ),\n      hasBraces: true,\n    },\n    // const foo = function() { ... }\n    {\n      regex: new RegExp(\n        `(?:const|let|var)\\\\s+${functionName}\\\\s*=\\\\s*function\\\\s*\\\\([^)]*\\\\)\\\\s*\\\\{`,\n        'i',\n      ),\n      hasBraces: true,\n    },\n    // const foo = () => { ... }\n    {\n      regex: new RegExp(\n        `(?:const|let|var)\\\\s+${functionName}\\\\s*=\\\\s*\\\\([^)]*\\\\)\\\\s*=>\\\\s*\\\\{`,\n        'i',\n      ),\n      hasBraces: true,\n    },\n    // const foo = () => ... (no braces)\n    {\n      regex: new RegExp(\n        `(?:const|let|var)\\\\s+${functionName}\\\\s*=\\\\s*\\\\([^)]*\\\\)\\\\s*=>\\\\s*[^;]+;?`,\n        'i',\n      ),\n      hasBraces: false,\n    },\n  ];\n\n  for (const { regex, hasBraces } of patterns) {\n    const match = code.match(regex);\n    if (match && match.index !== undefined) {\n      const startIdx = match.index;\n\n      // For arrow functions without braces, return the match directly\n      if (!hasBraces) {\n        return match[0].trim();\n      }\n\n      // For functions with braces, extract the full body using brace counting\n      // Find the position of the opening brace\n      const braceIdx = code.indexOf('{', startIdx);\n      if (braceIdx === -1) continue;\n\n      let idx = braceIdx;\n      let depth = 0;\n      let endIdx = -1;\n\n      // Count braces to find the matching closing brace\n      while (idx < code.length) {\n        const char = code[idx];\n\n        if (char === '{') {\n          depth++;\n        } else if (char === '}') {\n          depth--;\n          if (depth === 0) {\n            endIdx = idx;\n            break;\n          }\n        }\n        idx++;\n      }\n\n      // If we found the matching closing brace, extract the full function\n      if (endIdx !== -1) {\n        return code.slice(startIdx, endIdx + 1).trim();\n      }\n    }\n  }\n\n  return '';\n}\n","/**\n * Sandbox creation and safe code execution utilities\n *\n * Provides secure execution of generated code in isolated VM contexts with\n * controlled globals, timeouts, and resource constraints.\n */\n\nimport * as vm from 'node:vm';\n\n/**\n * Options for creating a sandbox execution context\n */\nexport interface SandboxOptions {\n  /**\n   * Global variables to make available in the sandbox\n   * These will be accessible as global variables in the executed code\n   */\n  globals?: Record<string, any>;\n\n  /**\n   * Maximum execution time in milliseconds\n   * Default: 5000ms (5 seconds)\n   */\n  timeout?: number;\n\n  /**\n   * Allowed built-in JavaScript objects\n   * Default: ['Array', 'Object', 'JSON', 'Math', 'Date', 'String', 'Number', 'Boolean', 'RegExp']\n   */\n  allowedBuiltins?: string[];\n\n  /**\n   * Whether to allow console access (useful for debugging)\n   * Default: false (console will be undefined unless provided in globals)\n   */\n  allowConsole?: boolean;\n}\n\n/**\n * Options for executing code in a sandbox\n */\nexport interface ExecuteOptions {\n  /**\n   * Maximum execution time in milliseconds\n   * Overrides the sandbox-level timeout if provided\n   */\n  timeout?: number;\n\n  /**\n   * Filename to use in error messages and stack traces\n   * Default: 'generated-code.js'\n   */\n  filename?: string;\n\n  /**\n   * Whether to capture and return the last expression value\n   * Default: true\n   */\n  captureResult?: boolean;\n}\n\n/**\n * Default safe built-in objects available in the sandbox\n */\nconst DEFAULT_BUILTINS = [\n  'Array',\n  'Object',\n  'JSON',\n  'Math',\n  'Date',\n  'String',\n  'Number',\n  'Boolean',\n  'RegExp',\n  'Set',\n  'Map',\n  'WeakSet',\n  'WeakMap',\n  'Symbol',\n  'Promise',\n];\n\n/**\n * Creates a secure sandbox execution context with controlled globals\n *\n * @param options - Configuration for the sandbox\n * @returns A VM context that can be used with executeCode()\n *\n * @example\n * ```typescript\n * const sandbox = createSandbox({\n *   globals: {\n *     cheerio: require('cheerio'),\n *     data: { foo: 'bar' }\n *   },\n *   timeout: 5000,\n *   allowedBuiltins: ['Array', 'Object', 'JSON']\n * });\n *\n * const result = executeCode('data.foo', sandbox);\n * // Returns: \"bar\"\n * ```\n */\nexport function createSandbox(options: SandboxOptions = {}): vm.Context {\n  const {\n    globals = {},\n    allowedBuiltins = DEFAULT_BUILTINS,\n    allowConsole = false,\n  } = options;\n\n  // Start with an empty object with null prototype to avoid inheriting anything\n  const sandbox: Record<string, any> = Object.create(null);\n\n  // Add allowed built-ins\n  for (const builtin of allowedBuiltins) {\n    if (builtin in globalThis) {\n      sandbox[builtin] = (globalThis as any)[builtin];\n    }\n  }\n\n  // Add console if allowed (otherwise it remains undefined)\n  if (allowConsole) {\n    sandbox.console = console;\n  }\n\n  // Add user-provided globals\n  Object.assign(sandbox, globals);\n\n  // Create and return the context\n  return vm.createContext(sandbox);\n}\n\n/**\n * Executes code in a sandbox with timeout and error handling\n *\n * @param code - The JavaScript code to execute\n * @param sandbox - The VM context created by createSandbox()\n * @param options - Execution options\n * @returns The result of the code execution\n * @throws {Error} If code execution fails or times out\n *\n * @example\n * ```typescript\n * const sandbox = createSandbox({\n *   globals: { x: 10, y: 20 }\n * });\n *\n * const result = executeCode('x + y', sandbox);\n * // Returns: 30\n *\n * // With a function\n * const funcResult = executeCode(`\n *   function add(a, b) {\n *     return a + b;\n *   }\n *   add(x, y);\n * `, sandbox);\n * // Returns: 30\n * ```\n */\nexport function executeCode<T = any>(\n  code: string,\n  sandbox: vm.Context,\n  options: ExecuteOptions = {},\n): T {\n  const {\n    timeout = 5000,\n    filename = 'generated-code.js',\n    captureResult = true,\n  } = options;\n\n  try {\n    // For simple expressions, wrap in return. For complex code, execute directly\n    let wrappedCode: string;\n\n    if (captureResult) {\n      // Check if code has multiple statements or function definitions\n      const hasMultipleStatements = code.includes(';') || (code.includes('\\n') && code.trim().split('\\n').length > 1);\n      const hasFunctionDef = /function\\s+\\w+|const\\s+\\w+\\s*=\\s*function|const\\s+\\w+\\s*=\\s*\\(/i.test(code);\n\n      if (hasMultipleStatements || hasFunctionDef) {\n        // Execute code as-is (will return last expression)\n        wrappedCode = code;\n      } else {\n        // Simple expression - wrap in return\n        wrappedCode = `(function() { return (${code}); })();`;\n      }\n    } else {\n      wrappedCode = code;\n    }\n\n    const result = vm.runInContext(wrappedCode, sandbox, {\n      timeout,\n      filename,\n      displayErrors: true,\n    });\n\n    return result as T;\n  } catch (error) {\n    // Enhanced error message with context\n    if (error instanceof Error) {\n      const message = `Code execution failed: ${error.message}`;\n      const enhancedError = new Error(message);\n      enhancedError.stack = error.stack;\n      throw enhancedError;\n    }\n    throw error;\n  }\n}\n\n/**\n * Executes async code in a sandbox with timeout and error handling\n *\n * @param code - The JavaScript code to execute (can contain async/await)\n * @param sandbox - The VM context created by createSandbox()\n * @param options - Execution options\n * @returns Promise resolving to the result of the code execution\n * @throws {Error} If code execution fails or times out\n *\n * @example\n * ```typescript\n * const sandbox = createSandbox({\n *   globals: {\n *     fetch: require('node-fetch')\n *   }\n * });\n *\n * const result = await executeCodeAsync(`\n *   const response = await fetch('https://api.example.com/data');\n *   const data = await response.json();\n *   data;\n * `, sandbox);\n * ```\n */\nexport async function executeCodeAsync<T = any>(\n  code: string,\n  sandbox: vm.Context,\n  options: ExecuteOptions = {},\n): Promise<T> {\n  const {\n    timeout = 5000,\n    filename = 'generated-code.js',\n    captureResult = true,\n  } = options;\n\n  try {\n    // For async code, wrap in async function with smart return handling\n    let wrappedCode: string;\n\n    if (captureResult) {\n      // For multi-line code, wrap in async IIFE and return last expression\n      // Split into statements and make last one a return\n      const trimmedCode = code.trim();\n      const lines = trimmedCode.split('\\n');\n\n      if (lines.length > 1 || trimmedCode.includes(';')) {\n        // Multi-line or multiple statements - find last expression\n        const statements = trimmedCode.split('\\n').filter(line => line.trim());\n        const lastLine = statements[statements.length - 1];\n        const otherLines = statements.slice(0, -1);\n\n        // If last line is already a return statement, keep code as-is\n        if (lastLine.trim().startsWith('return ')) {\n          wrappedCode = `(async function() {\n            ${trimmedCode}\n          })();`;\n        } else {\n          // Make last line a return (remove trailing semicolon if present)\n          const lastExpression = lastLine.trim().replace(/;$/, '');\n          wrappedCode = `(async function() {\n            ${otherLines.join('\\n')}\n            return ${lastExpression};\n          })();`;\n        }\n      } else {\n        // Single expression - wrap in return\n        wrappedCode = `(async function() {\n          return (${trimmedCode});\n        })();`;\n      }\n    } else {\n      wrappedCode = `(async function() {\n        ${code}\n      })();`;\n    }\n\n    const result = await vm.runInContext(wrappedCode, sandbox, {\n      timeout,\n      filename,\n      displayErrors: true,\n    });\n\n    return result as T;\n  } catch (error) {\n    // Enhanced error message with context\n    if (error instanceof Error) {\n      const message = `Async code execution failed: ${error.message}`;\n      const enhancedError = new Error(message);\n      enhancedError.stack = error.stack;\n      throw enhancedError;\n    }\n    throw error;\n  }\n}\n\n/**\n * Convenience function to create a sandbox and execute code in one step\n *\n * @param code - The JavaScript code to execute\n * @param options - Combined sandbox and execution options\n * @returns The result of the code execution\n *\n * @example\n * ```typescript\n * const result = executeInSandbox('Math.sqrt(16)', {\n *   globals: { x: 10 },\n *   timeout: 1000\n * });\n * // Returns: 4\n * ```\n */\nexport function executeInSandbox<T = any>(\n  code: string,\n  options: SandboxOptions & ExecuteOptions = {},\n): T {\n  const sandbox = createSandbox(options);\n  return executeCode<T>(code, sandbox, options);\n}\n\n/**\n * Convenience function to create a sandbox and execute async code in one step\n *\n * @param code - The JavaScript code to execute (can contain async/await)\n * @param options - Combined sandbox and execution options\n * @returns Promise resolving to the result of the code execution\n *\n * @example\n * ```typescript\n * const result = await executeInSandboxAsync(`\n *   const data = await Promise.resolve({ value: 42 });\n *   data.value;\n * `, {\n *   timeout: 2000\n * });\n * // Returns: 42\n * ```\n */\nexport async function executeInSandboxAsync<T = any>(\n  code: string,\n  options: SandboxOptions & ExecuteOptions = {},\n): Promise<T> {\n  const sandbox = createSandbox(options);\n  return executeCodeAsync<T>(code, sandbox, options);\n}\n","/**\n * Code validation utilities for checking generated code before execution\n *\n * Provides functions to validate code syntax, check for dangerous patterns,\n * and verify code meets security requirements before sandbox execution.\n */\n\n/**\n * Options for code validation\n */\nexport interface ValidationOptions {\n  /**\n   * List of allowed global variables\n   * If provided, code will be checked for undeclared variables\n   */\n  allowedGlobals?: string[];\n\n  /**\n   * List of disallowed patterns (regex)\n   * Code containing these patterns will fail validation\n   */\n  disallowedPatterns?: RegExp[];\n\n  /**\n   * Maximum code length in characters\n   * Default: 50000\n   */\n  maxLength?: number;\n\n  /**\n   * Whether to allow require() calls\n   * Default: false (dangerous in untrusted code)\n   */\n  allowRequire?: boolean;\n\n  /**\n   * Whether to allow import statements\n   * Default: false (dangerous in untrusted code)\n   */\n  allowImport?: boolean;\n\n  /**\n   * Whether to allow eval() and Function() constructor\n   * Default: false (dangerous in any code)\n   */\n  allowEval?: boolean;\n\n  /**\n   * Whether to perform syntax check\n   * Default: true\n   */\n  checkSyntax?: boolean;\n}\n\n/**\n * Result of code validation\n */\nexport interface ValidationResult {\n  /**\n   * Whether the code passed all validation checks\n   */\n  valid: boolean;\n\n  /**\n   * Critical errors that prevent execution\n   */\n  errors: string[];\n\n  /**\n   * Non-critical warnings about the code\n   */\n  warnings: string[];\n\n  /**\n   * Statistics about the code\n   */\n  stats?: {\n    length: number;\n    lines: number;\n    hasAsync: boolean;\n    hasArrowFunctions: boolean;\n    hasClasses: boolean;\n  };\n}\n\n/**\n * Default dangerous patterns that should be disallowed\n */\nconst DANGEROUS_PATTERNS = [\n  /require\\s*\\(/i, // No require()\n  /import\\s+/i, // No import statements\n  /eval\\s*\\(/i, // No eval()\n  /Function\\s*\\(/i, // No Function constructor\n  /process\\./i, // No process access\n  /fs\\./i, // No filesystem module\n  /child_process/i, // No child process\n  /__dirname/i, // No directory access\n  /__filename/i, // No file access\n  /global\\./i, // No global object manipulation\n];\n\n/**\n * Validates code before execution in a sandbox\n *\n * @param code - The code to validate\n * @param options - Validation options\n * @returns Validation result with errors and warnings\n *\n * @example\n * ```typescript\n * const result = validateCode(`\n *   function parse(data) {\n *     return JSON.parse(data);\n *   }\n * `, {\n *   allowedGlobals: ['JSON'],\n *   maxLength: 10000\n * });\n *\n * if (!result.valid) {\n *   console.error('Code validation failed:', result.errors);\n * }\n * ```\n */\nexport function validateCode(\n  code: string,\n  options: ValidationOptions = {},\n): ValidationResult {\n  const {\n    allowedGlobals,\n    disallowedPatterns = DANGEROUS_PATTERNS,\n    maxLength = 50000,\n    allowRequire = false,\n    allowImport = false,\n    allowEval = false,\n    checkSyntax = true,\n  } = options;\n\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check for empty code\n  if (!code || code.trim().length === 0) {\n    errors.push('Code is empty');\n    return { valid: false, errors, warnings };\n  }\n\n  // Check length\n  if (code.length > maxLength) {\n    errors.push(\n      `Code exceeds maximum length (${code.length} > ${maxLength} characters)`,\n    );\n  }\n\n  // Create explicit pattern to flag mapping for more reliable filtering\n  const patternFlags = new Map([\n    [DANGEROUS_PATTERNS[0], 'require'], // /require\\s*\\(/i\n    [DANGEROUS_PATTERNS[1], 'import'],  // /import\\s+/i\n    [DANGEROUS_PATTERNS[2], 'eval'],    // /eval\\s*\\(/i\n    [DANGEROUS_PATTERNS[3], 'eval'],    // /Function\\s*\\(/i - also controlled by allowEval\n    // Patterns 4-9 are always dangerous (process, fs, child_process, etc.)\n  ]);\n\n  // Filter dangerous patterns based on options using explicit mapping\n  const effectivePatterns = disallowedPatterns.filter((pattern, index) => {\n    const patternType = patternFlags.get(DANGEROUS_PATTERNS[index]);\n\n    if (patternType === 'require' && allowRequire) {\n      return false;\n    }\n    if (patternType === 'import' && allowImport) {\n      return false;\n    }\n    if (patternType === 'eval' && allowEval) {\n      return false;\n    }\n    return true;\n  });\n\n  // Check for dangerous patterns\n  for (const pattern of effectivePatterns) {\n    if (pattern.test(code)) {\n      errors.push(\n        `Code contains disallowed pattern: ${pattern.source.replace(/\\\\/g, '')}`,\n      );\n    }\n  }\n\n  // Check for undeclared variables (if allowed globals specified)\n  if (allowedGlobals) {\n    const undeclaredVars = findUndeclaredVariables(code, allowedGlobals);\n    if (undeclaredVars.length > 0) {\n      warnings.push(\n        `Potentially undeclared variables: ${undeclaredVars.join(', ')}`,\n      );\n    }\n  }\n\n  // Syntax check\n  if (checkSyntax) {\n    const syntaxErrors = checkCodeSyntax(code);\n    errors.push(...syntaxErrors);\n  }\n\n  // Generate statistics\n  const stats = {\n    length: code.length,\n    lines: code.split('\\n').length,\n    hasAsync: /\\basync\\b\\s*(function|\\([\\w\\s,={}[\\]]*\\)\\s*=>|\\w+\\s*\\()/m.test(code),\n    hasArrowFunctions: /=>/.test(code),\n    hasClasses: /\\bclass\\s+\\w+/.test(code),\n  };\n\n  // Add warnings for complex patterns\n  if (stats.lines > 100) {\n    warnings.push(`Code is long (${stats.lines} lines) - consider breaking into smaller functions`);\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n    stats,\n  };\n}\n\n/**\n * Checks code syntax without executing it\n *\n * @param code - The code to check\n * @returns Array of syntax error messages (empty if valid)\n */\nfunction checkCodeSyntax(code: string): string[] {\n  const errors: string[] = [];\n\n  try {\n    // Try to parse as a function body\n    new Function(code);\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      // If it fails because of top-level await, try wrapping in async function\n      const message = error.message;\n      if (message.includes('await is only valid') && /\\bawait\\b/.test(code)) {\n        try {\n          // Wrap in async function and try again\n          new Function(`(async function() { ${code} })()`);\n          // If this succeeds, the code is valid async code\n          return errors;\n        } catch (asyncError) {\n          // Real syntax error even in async context\n          if (asyncError instanceof SyntaxError) {\n            errors.push(`Syntax error: ${asyncError.message}`);\n          }\n        }\n      } else {\n        // Not an await issue, report original error\n        errors.push(`Syntax error: ${message}`);\n      }\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Finds potentially undeclared variables in code\n *\n * **Important Limitations:**\n * This is a basic regex-based static analysis with known limitations:\n * - Cannot detect variables in destructuring assignments\n * - May miss variables declared in nested scopes\n * - Cannot handle dynamic variable access (e.g., obj[varName])\n * - Will have false positives for method calls and object properties\n * - Does not understand scope chains or closures\n *\n * For production use cases requiring accurate variable analysis, consider using\n * a proper AST parser like @babel/parser or acorn.\n *\n * @param code - The code to analyze\n * @param allowedGlobals - List of allowed global variables\n * @returns Array of potentially undeclared variable names (may include false positives)\n */\nfunction findUndeclaredVariables(\n  code: string,\n  allowedGlobals: string[],\n): string[] {\n  // This is a simplified regex-based check with known limitations (see JSDoc)\n  // A full implementation would use an AST parser for accurate analysis\n\n  const undeclaredVars: Set<string> = new Set();\n\n  // Find all variable references (word boundaries)\n  const identifierRegex = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\b/g;\n  const matches = code.matchAll(identifierRegex);\n\n  const declaredVars = new Set<string>();\n\n  // Find declared variables (var, let, const, function)\n  const declarationRegex =\n    /\\b(?:var|let|const|function)\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)/g;\n  const declarations = code.matchAll(declarationRegex);\n\n  for (const match of declarations) {\n    if (match[1]) {\n      declaredVars.add(match[1]);\n    }\n  }\n\n  // Check each identifier\n  for (const match of matches) {\n    const identifier = match[1];\n\n    // Skip keywords\n    if (isJavaScriptKeyword(identifier)) {\n      continue;\n    }\n\n    // Skip if declared in code\n    if (declaredVars.has(identifier)) {\n      continue;\n    }\n\n    // Skip if in allowed globals\n    if (allowedGlobals.includes(identifier)) {\n      continue;\n    }\n\n    // Skip common built-ins\n    if (isCommonBuiltin(identifier)) {\n      continue;\n    }\n\n    undeclaredVars.add(identifier);\n  }\n\n  return Array.from(undeclaredVars);\n}\n\n/**\n * Checks if a word is a JavaScript keyword\n */\nfunction isJavaScriptKeyword(word: string): boolean {\n  const keywords = [\n    'break',\n    'case',\n    'catch',\n    'class',\n    'const',\n    'continue',\n    'debugger',\n    'default',\n    'delete',\n    'do',\n    'else',\n    'export',\n    'extends',\n    'finally',\n    'for',\n    'function',\n    'if',\n    'import',\n    'in',\n    'instanceof',\n    'let',\n    'new',\n    'return',\n    'super',\n    'switch',\n    'this',\n    'throw',\n    'try',\n    'typeof',\n    'var',\n    'void',\n    'while',\n    'with',\n    'yield',\n    'async',\n    'await',\n  ];\n\n  return keywords.includes(word);\n}\n\n/**\n * Checks if a word is a common JavaScript built-in\n */\nfunction isCommonBuiltin(word: string): boolean {\n  const builtins = [\n    'Array',\n    'Object',\n    'String',\n    'Number',\n    'Boolean',\n    'Date',\n    'Math',\n    'JSON',\n    'RegExp',\n    'Error',\n    'Map',\n    'Set',\n    'Promise',\n    'Symbol',\n    'undefined',\n    'null',\n    'true',\n    'false',\n    'console',\n    'parseInt',\n    'parseFloat',\n    'isNaN',\n    'isFinite',\n    'decodeURI',\n    'decodeURIComponent',\n    'encodeURI',\n    'encodeURIComponent',\n  ];\n\n  return builtins.includes(word);\n}\n\n/**\n * Quick validation to check if code is safe for execution\n * Returns true if code passes basic safety checks\n *\n * @param code - The code to check\n * @returns true if code is safe, false otherwise\n *\n * @example\n * ```typescript\n * if (isSafeCode('return x + y')) {\n *   // Safe to execute\n * }\n * ```\n */\nexport function isSafeCode(code: string): boolean {\n  const result = validateCode(code, {\n    maxLength: 50000,\n    checkSyntax: true,\n  });\n\n  return result.valid;\n}\n","/**\n * Universal logging utilities that work in both browser and Node.js\n *\n * Provides a configurable logging system with console and no-op implementations.\n * The global logger can be swapped out for custom implementations as needed.\n */\n\nimport type { Logger } from './types';\n\n/**\n * Console-based logger implementation\n *\n * Routes all log messages to the appropriate console methods with optional context.\n */\nclass ConsoleLogger implements Logger {\n  debug(message: string, context?: Record<string, unknown>): void {\n    if (context) {\n      console.debug(message, context);\n    } else {\n      console.debug(message);\n    }\n  }\n\n  info(message: string, context?: Record<string, unknown>): void {\n    if (context) {\n      console.info(message, context);\n    } else {\n      console.info(message);\n    }\n  }\n\n  warn(message: string, context?: Record<string, unknown>): void {\n    if (context) {\n      console.warn(message, context);\n    } else {\n      console.warn(message);\n    }\n  }\n\n  error(message: string, context?: Record<string, unknown>): void {\n    if (context) {\n      console.error(message, context);\n    } else {\n      console.error(message);\n    }\n  }\n}\n\n/**\n * No-operation logger that discards all log messages\n *\n * Useful for disabling logging in production or testing environments.\n */\nclass NoOpLogger implements Logger {\n  debug(): void {}\n  info(): void {}\n  warn(): void {}\n  error(): void {}\n}\n\n/** Global logger instance used throughout the SDK */\nlet globalLogger: Logger = new ConsoleLogger();\n\n/**\n * Replace the global logger with a custom implementation\n *\n * @param logger - Custom logger implementation\n * @example\n * ```typescript\n * setLogger(new CustomLogger());\n * ```\n */\nexport const setLogger = (logger: Logger): void => {\n  globalLogger = logger;\n};\n\n/**\n * Get the current global logger instance\n *\n * @returns Current logger implementation\n * @example\n * ```typescript\n * const logger = getLogger();\n * logger.info('Application started');\n * ```\n */\nexport const getLogger = (): Logger => {\n  return globalLogger;\n};\n\n/**\n * Disable all logging by switching to no-op logger\n *\n * @example\n * ```typescript\n * if (process.env.NODE_ENV === 'production') {\n *   disableLogging();\n * }\n * ```\n */\nexport const disableLogging = (): void => {\n  globalLogger = new NoOpLogger();\n};\n\n/**\n * Enable console logging by switching to console logger\n *\n * @example\n * ```typescript\n * enableLogging(); // Re-enable after disabling\n * ```\n */\nexport const enableLogging = (): void => {\n  globalLogger = new ConsoleLogger();\n};\n","/**\n * Shared type definitions and interfaces for universal use\n *\n * This module provides standardized error classes and logging interfaces\n * used throughout the HAVE SDK. All error classes extend BaseError to\n * provide consistent error handling with context and timestamps.\n */\n\n/**\n * Standardized error codes used across the HAVE SDK\n *\n * These codes provide consistent error categorization for better error handling\n * and monitoring across all packages in the SDK.\n */\nexport enum ErrorCode {\n  /** Input validation failed */\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  /** API request/response error */\n  API_ERROR = 'API_ERROR',\n  /** File system operation error */\n  FILE_ERROR = 'FILE_ERROR',\n  /** Network connectivity or HTTP error */\n  NETWORK_ERROR = 'NETWORK_ERROR',\n  /** Database operation error */\n  DATABASE_ERROR = 'DATABASE_ERROR',\n  /** Data parsing or format error */\n  PARSING_ERROR = 'PARSING_ERROR',\n  /** Operation timeout error */\n  TIMEOUT_ERROR = 'TIMEOUT_ERROR',\n  /** Unspecified or unexpected error */\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\n}\n\n/**\n * Base error class providing standardized error handling across the HAVE SDK\n *\n * All custom errors extend this class to ensure consistent error structure,\n * context preservation, and debugging capabilities.\n *\n * @example\n * ```typescript\n * throw new BaseError('Something went wrong', ErrorCode.UNKNOWN_ERROR, {\n *   userId: 123,\n *   operation: 'processData'\n * });\n * ```\n */\nexport class BaseError extends Error {\n  /** Error classification code */\n  public readonly code: ErrorCode;\n  /** Additional context data for debugging */\n  public readonly context?: Record<string, unknown>;\n  /** When the error occurred */\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: ErrorCode = ErrorCode.UNKNOWN_ERROR,\n    context?: Record<string, unknown>,\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.context = context;\n    this.timestamp = new Date();\n    Error.captureStackTrace?.(this, this.constructor);\n  }\n\n  /**\n   * Serializes the error to a JSON-compatible object\n   * @returns Object containing all error properties\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      context: this.context,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n}\n\n/**\n * Error thrown when input validation fails\n *\n * @example\n * ```typescript\n * throw new ValidationError('Email format invalid', {\n *   email: 'invalid-email',\n *   field: 'userEmail'\n * });\n * ```\n */\nexport class ValidationError extends BaseError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, ErrorCode.VALIDATION_ERROR, context);\n  }\n}\n\n/**\n * Error thrown for API-related failures\n *\n * @example\n * ```typescript\n * throw new ApiError('HTTP 404 Not Found', {\n *   url: 'https://api.example.com/users/123',\n *   status: 404\n * });\n * ```\n */\nexport class ApiError extends BaseError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, ErrorCode.API_ERROR, context);\n  }\n}\n\n/**\n * Error thrown for file system operation failures\n *\n * @example\n * ```typescript\n * throw new FileError('File not found', {\n *   path: '/path/to/missing/file.txt',\n *   operation: 'read'\n * });\n * ```\n */\nexport class FileError extends BaseError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, ErrorCode.FILE_ERROR, context);\n  }\n}\n\n/**\n * Error thrown for network connectivity or HTTP failures\n *\n * @example\n * ```typescript\n * throw new NetworkError('Connection timeout', {\n *   host: 'example.com',\n *   timeout: 5000,\n *   attempt: 3\n * });\n * ```\n */\nexport class NetworkError extends BaseError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, ErrorCode.NETWORK_ERROR, context);\n  }\n}\n\n/**\n * Error thrown for database operation failures\n *\n * @example\n * ```typescript\n * throw new DatabaseError('Connection failed', {\n *   database: 'production',\n *   query: 'SELECT * FROM users',\n *   errorCode: 'ECONNREFUSED'\n * });\n * ```\n */\nexport class DatabaseError extends BaseError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, ErrorCode.DATABASE_ERROR, context);\n  }\n}\n\n/**\n * Error thrown for data parsing or format failures\n *\n * @example\n * ```typescript\n * throw new ParsingError('Invalid JSON format', {\n *   input: '{invalid json}',\n *   parser: 'JSON.parse',\n *   position: 1\n * });\n * ```\n */\nexport class ParsingError extends BaseError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, ErrorCode.PARSING_ERROR, context);\n  }\n}\n\n/**\n * Error thrown when operations exceed their timeout duration\n *\n * @example\n * ```typescript\n * throw new TimeoutError('Operation timed out', {\n *   timeout: 5000,\n *   operation: 'fetchData',\n *   elapsedTime: 5234\n * });\n * ```\n */\nexport class TimeoutError extends BaseError {\n  constructor(message: string, context?: Record<string, unknown>) {\n    super(message, ErrorCode.TIMEOUT_ERROR, context);\n  }\n}\n\n/**\n * Logging interface for consistent logging across the HAVE SDK\n *\n * All logging implementations should follow this interface to ensure\n * consistent behavior and easy swapping of logging backends.\n *\n * @example\n * ```typescript\n * class CustomLogger implements Logger {\n *   info(message: string, context?: Record<string, unknown>) {\n *     console.log(`INFO: ${message}`, context);\n *   }\n *   // ... implement other methods\n * }\n * ```\n */\nexport interface Logger {\n  /** Log debug information (lowest priority) */\n  debug(message: string, context?: Record<string, unknown>): void;\n  /** Log informational messages */\n  info(message: string, context?: Record<string, unknown>): void;\n  /** Log warning messages */\n  warn(message: string, context?: Record<string, unknown>): void;\n  /** Log error messages (highest priority) */\n  error(message: string, context?: Record<string, unknown>): void;\n}\n","/**\n * Universal utilities that work in both browser and Node.js environments\n */\n\nimport { createId as cuid2CreateId, isCuid } from '@paralleldrive/cuid2';\nimport { add, format, isValid, parse, parseISO } from 'date-fns';\nimport pluralize from 'pluralize';\nimport { ParsingError, TimeoutError } from './types';\n\n/**\n * Generates a unique identifier using CUID2 (preferred) or UUID fallback\n *\n * CUID2 is more secure and collision-resistant than UUIDs, but UUID is provided\n * as a fallback for RFC4122 compliance requirements.\n *\n * @param type - ID type: 'cuid2' (default) or 'uuid'\n * @returns A unique identifier string\n * @example\n * ```typescript\n * const id = makeId(); // CUID2: \"ckx5f8h3z0000qzrmn831i7rn\"\n * const uuid = makeId('uuid'); // UUID: \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n * ```\n */\nexport const makeId = (type: 'cuid2' | 'uuid' = 'cuid2'): string => {\n  if (type === 'cuid2') {\n    return cuid2CreateId();\n  }\n\n  // UUID fallback\n  if (crypto?.randomUUID) {\n    return crypto.randomUUID();\n  }\n\n  // Manual UUID fallback for older environments\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\n/**\n * Generates a CUID2 identifier (collision-resistant, more secure than UUID)\n *\n * CUID2 provides better entropy and security compared to UUID v4, making it\n * ideal for distributed systems and user-facing identifiers.\n *\n * @returns A CUID2 identifier string\n * @example\n * ```typescript\n * const id = createId(); // \"ckx5f8h3z0000qzrmn831i7rn\"\n * ```\n */\nexport const createId = cuid2CreateId;\n\n/**\n * Checks if a string is a valid CUID2\n */\nexport { isCuid };\n\n/**\n * Converts a string to a URL-friendly slug\n *\n * Handles international characters, removes special characters, and replaces\n * spaces with hyphens. Ampersands are converted to \"-38-\" for uniqueness.\n *\n * @param str - The string to convert to a slug\n * @returns A URL-friendly slug string\n * @example\n * ```typescript\n * makeSlug(\"My Example Title & Co.\"); // \"my-example-title-38-co\"\n * makeSlug(\"Café España\"); // \"cafe-espana\"\n * ```\n */\nexport const makeSlug = (str: string): string => {\n  const from =\n    'àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìıİłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż+·/_,:;';\n  const to =\n    'aaaaaaaaaacccddeeeeeeeegghiiiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz--------------';\n  const textToCompare = new RegExp(\n    from.split('').join('|').replace(/\\+/g, '\\\\+'),\n    'g',\n  );\n\n  return str\n    .toString()\n    .toLowerCase()\n    .replace('&', '-38-')\n    .replace(/\\s+/g, '-')\n    .replace(textToCompare, (c) => to.charAt(from.indexOf(c)))\n    .replace(/[&.]/g, '-')\n    .replace(/[^\\w-º+]+/g, '')\n    .replace(/--+/g, '-')\n    .replace(/^-+/, '')\n    .replace(/-+$/, '');\n};\n\n/**\n * Extracts the filename from a URL's pathname\n *\n * Returns the last segment of the URL path. If no filename is found,\n * defaults to 'index.html'.\n *\n * @param url - The URL to extract filename from\n * @returns The filename from the URL\n * @throws {TypeError} When URL is invalid\n * @example\n * ```typescript\n * urlFilename(\"https://example.com/path/file.pdf\"); // \"file.pdf\"\n * urlFilename(\"https://example.com/path/\"); // \"index.html\"\n * ```\n */\nexport const urlFilename = (url: string): string => {\n  const parsedUrl = new URL(url);\n  const pathSegments = parsedUrl.pathname.split('/');\n  const filename = pathSegments[pathSegments.length - 1];\n  return filename || 'index.html';\n};\n\n/**\n * Converts a URL to a file path by joining hostname and pathname\n *\n * Creates a file system compatible path from a URL by combining the hostname\n * with the pathname segments, useful for creating local file structures.\n *\n * @param url - The URL to convert to a path\n * @returns A file path string with hostname and path segments\n * @throws {TypeError} When URL is invalid\n * @example\n * ```typescript\n * urlPath(\"https://example.com/path/to/resource\"); // \"example.com/path/to/resource\"\n * ```\n */\nexport const urlPath = (url: string): string => {\n  const parsedUrl = new URL(url);\n  const pathSegments = [\n    parsedUrl.hostname,\n    ...parsedUrl.pathname.split('/').filter(Boolean),\n  ];\n  return pathSegments.join('/');\n};\n\n/**\n * Creates a Promise that resolves after a specified duration\n *\n * Useful for adding delays in async functions or rate limiting operations.\n *\n * @param duration - Time to wait in milliseconds\n * @returns Promise that resolves after the specified duration\n * @example\n * ```typescript\n * await sleep(1000); // Wait 1 second\n * console.log('1 second has passed');\n * ```\n */\nexport const sleep = (duration: number): Promise<void> => {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, duration);\n  });\n};\n\n/**\n * Repeatedly calls a function until it returns a defined value or times out\n *\n * Polls an async function at regular intervals until it returns a defined value\n * or the timeout is reached. Useful for waiting for conditions to be met.\n *\n * @param it - Async function to poll\n * @param options - Configuration options\n * @param options.timeout - Maximum time to wait in milliseconds (0 = no timeout)\n * @param options.delay - Time between polling attempts in milliseconds\n * @returns Promise that resolves with the function result or rejects on timeout\n * @throws {TimeoutError} When timeout is reached before function returns defined value\n * @example\n * ```typescript\n * // Wait for a file to exist\n * const fileExists = await waitFor(\n *   async () => {\n *     try {\n *       await fs.access('/path/to/file');\n *       return true;\n *     } catch {\n *       return undefined; // Keep polling\n *     }\n *   },\n *   { timeout: 10000, delay: 500 }\n * );\n * ```\n */\nexport function waitFor(\n  it: () => Promise<any>,\n  { timeout = 0, delay = 1000 }: { timeout?: number; delay?: number } = {},\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    const beginTime = Date.now();\n\n    (async function waitATick() {\n      try {\n        const result = await it();\n        if (typeof result !== 'undefined') {\n          return resolve(result);\n        }\n\n        if (timeout > 0) {\n          if (Date.now() > beginTime + timeout) {\n            return reject(\n              new TimeoutError('Function call timed out', {\n                timeout,\n                delay,\n                elapsedTime: Date.now() - beginTime,\n              }),\n            );\n          }\n        }\n\n        setTimeout(waitATick, delay);\n      } catch (error) {\n        reject(error);\n      }\n    })();\n  });\n}\n\n/**\n * Type guard to check if a value is an array\n *\n * @param obj - Value to check\n * @returns True if value is an array, with TypeScript type narrowing\n * @example\n * ```typescript\n * if (isArray(data)) {\n *   // TypeScript knows data is unknown[]\n *   data.forEach(item => console.log(item));\n * }\n * ```\n */\nexport const isArray = (obj: unknown): obj is unknown[] => {\n  return Array.isArray(obj);\n};\n\n/**\n * Type guard to check if a value is a plain object\n *\n * Checks for objects that are not null, arrays, or other non-plain object types.\n *\n * @param obj - Value to check\n * @returns True if value is a plain object, with TypeScript type narrowing\n * @example\n * ```typescript\n * if (isPlainObject(data)) {\n *   // TypeScript knows data is Record<string, unknown>\n *   Object.keys(data).forEach(key => console.log(key, data[key]));\n * }\n * ```\n */\nexport const isPlainObject = (obj: unknown): obj is Record<string, unknown> => {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\n/**\n * Checks if a string is a valid URL\n *\n * Uses the URL constructor to validate the string format. Returns false\n * for any string that cannot be parsed as a valid URL.\n *\n * @param url - String to validate as URL\n * @returns True if string is a valid URL\n * @example\n * ```typescript\n * isUrl(\"https://example.com\"); // true\n * isUrl(\"not-a-url\"); // false\n * ```\n */\nexport const isUrl = (url: string): boolean => {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Converts a string to camelCase\n *\n * Handles kebab-case, snake_case, and space-separated strings.\n * Removes special characters and ensures proper camelCase formatting.\n *\n * @param str - String to convert\n * @returns camelCase formatted string\n * @example\n * ```typescript\n * camelCase(\"hello-world\"); // \"helloWorld\"\n * camelCase(\"snake_case_string\"); // \"snakeCaseString\"\n * camelCase(\"Some Title\"); // \"someTitle\"\n * ```\n */\nexport const camelCase = (str: string): string => {\n  return str\n    .toLowerCase()\n    .replace(/[-_]+/g, ' ')\n    .replace(/[^\\w\\s]/g, '')\n    .replace(/\\s(.)/g, (_, char) => char.toUpperCase())\n    .replace(/\\s/g, '')\n    .replace(/^(.)/, (_, char) => char.toLowerCase());\n};\n\n/**\n * Converts a string to snake_case\n *\n * Handles camelCase, kebab-case, and space-separated strings.\n * Converts to lowercase with underscore separators.\n *\n * @param str - String to convert\n * @returns snake_case formatted string\n * @example\n * ```typescript\n * snakeCase(\"helloWorld\"); // \"hello_world\"\n * snakeCase(\"kebab-case-string\"); // \"kebab_case_string\"\n * snakeCase(\"Some Title\"); // \"some_title\"\n * ```\n */\nexport const snakeCase = (str: string): string => {\n  return str\n    .replace(/([A-Z])/g, '_$1')\n    .toLowerCase()\n    .replace(/^_/, '')\n    .replace(/[-\\s]+/g, '_');\n};\n\n/**\n * Recursively converts all object keys to camelCase\n *\n * Deeply traverses an object or array and converts all keys to camelCase.\n * Preserves the structure and values, only transforming key names.\n *\n * @param obj - Object or array to transform\n * @returns New object/array with camelCase keys\n * @example\n * ```typescript\n * keysToCamel({\n *   user_name: \"john\",\n *   user_details: { first_name: \"John\" }\n * }); // { userName: \"john\", userDetails: { firstName: \"John\" } }\n * ```\n */\nexport const keysToCamel = (obj: unknown): unknown => {\n  if (isPlainObject(obj)) {\n    const n: Record<string, unknown> = {};\n    Object.keys(obj).forEach((k) => {\n      n[camelCase(k)] = keysToCamel(obj[k]);\n    });\n    return n;\n  }\n  if (isArray(obj)) {\n    return obj.map((i) => keysToCamel(i));\n  }\n  return obj;\n};\n\n/**\n * Recursively converts all object keys to snake_case\n *\n * Deeply traverses an object or array and converts all keys to snake_case.\n * Preserves the structure and values, only transforming key names.\n *\n * @param obj - Object or array to transform\n * @returns New object/array with snake_case keys\n * @example\n * ```typescript\n * keysToSnake({\n *   userName: \"john\",\n *   userDetails: { firstName: \"John\" }\n * }); // { user_name: \"john\", user_details: { first_name: \"John\" } }\n * ```\n */\nexport const keysToSnake = (obj: unknown): unknown => {\n  if (isPlainObject(obj)) {\n    const n: Record<string, unknown> = {};\n    Object.keys(obj).forEach((k) => {\n      n[snakeCase(k)] = keysToSnake(obj[k]);\n    });\n    return n;\n  }\n  if (isArray(obj)) {\n    return obj.map((i) => keysToSnake(i));\n  }\n  return obj;\n};\n\n/**\n * Converts a domain string to camelCase\n *\n * Convenience function that applies camelCase conversion to domain strings.\n * Useful for converting API service names or domain identifiers.\n *\n * @param domain - Domain string to convert\n * @returns camelCase formatted domain string\n * @example\n * ```typescript\n * domainToCamel(\"api-service\"); // \"apiService\"\n * domainToCamel(\"user_management\"); // \"userManagement\"\n * ```\n */\nexport const domainToCamel = (domain: string): string => camelCase(domain);\n\n/**\n * Creates a visual progress indicator by cycling through a sequence of characters\n *\n * Useful for creating animated progress indicators in CLI applications.\n * Cycles through provided characters or defaults to dot sequences.\n *\n * @param tick - Current tick state (null to start)\n * @param options - Configuration options\n * @param options.chars - Array of characters to cycle through\n * @returns Next character in the sequence\n * @example\n * ```typescript\n * let tick = null;\n * setInterval(() => {\n *   tick = logTicker(tick);\n *   process.stdout.write(`\\rProcessing ${tick}`);\n * }, 500);\n * // Outputs: \"Processing .\" → \"Processing ..\" → \"Processing ...\"\n * ```\n */\nexport const logTicker = (\n  tick: string | null,\n  options: { chars?: string[] } = {},\n): string => {\n  const { chars = ['.', '..', '...'] } = options;\n  if (tick) {\n    const index = chars.indexOf(tick);\n    return index + 1 >= chars.length ? chars[0] : chars[index + 1];\n  }\n  return chars[0];\n};\n\n/**\n * Parses an Amazon date string format (YYYYMMDDTHHMMSSZ) to a Date object\n *\n * Specifically handles the compact date format used by Amazon AWS services.\n * Validates the format and throws detailed errors for invalid inputs.\n *\n * @param dateStr - Amazon date string in format YYYYMMDDTHHMMSSZ\n * @returns Parsed Date object\n * @throws {ParsingError} When date string format is invalid\n * @example\n * ```typescript\n * parseAmazonDateString('20220223T215409Z');\n * // Returns: Date object for February 23, 2022, 21:54:09 UTC\n * ```\n */\nexport const parseAmazonDateString = (dateStr: string): Date => {\n  const regex =\n    /^([0-9]{4})([0-9]{2})([0-9]{2})T([0-9]{2})([0-9]{2})([0-9]{2})([A-Z0-9]+)/;\n  const match = dateStr.match(regex);\n  if (!match) {\n    throw new ParsingError('Could not parse Amazon date string', {\n      dateString: dateStr,\n      expectedFormat: 'YYYYMMDDTHHMMSSZ',\n    });\n  }\n\n  const [matched, year, month, day, hour, minutes, seconds, timezone] = match;\n  if (matched !== dateStr) {\n    throw new ParsingError('Invalid Amazon date string format', {\n      dateString: dateStr,\n      matched,\n      expectedFormat: 'YYYYMMDDTHHMMSSZ',\n    });\n  }\n\n  const date = new Date(\n    `${year}-${month}-${day}T${hour}:${minutes}:${seconds}${timezone}`,\n  );\n  return date;\n};\n\n/**\n * Extracts and parses a date from a string\n *\n * Intelligently extracts dates from filenames or text strings by looking for\n * common date patterns. Supports multiple formats including:\n * - ISO dates (2023-01-15, 2023/01/15)\n * - US dates (01/15/2023, 01-15-2023)\n * - Natural language (January 15, 2023, Oct 14 2025)\n * - Filenames with dates (Report_January_15_2023.pdf)\n *\n * @param str - String containing date information (filename, title, or text)\n * @returns Parsed Date object or null if no valid date found\n * @example\n * ```typescript\n * dateInString(\"Report_January_15_2023.pdf\"); // Date(2023, 0, 15)\n * dateInString(\"Regular Council Meeting October 14, 2025\"); // Date(2025, 9, 14)\n * dateInString(\"financial-report-dec-2023.pdf\"); // Date(2023, 11, 1)\n * dateInString(\"2023-01-15\"); // Date(2023, 0, 15)\n * dateInString(\"no-date-here.pdf\"); // null\n * ```\n */\nexport const dateInString = (str: string): Date | null => {\n  const cleanStr = str.toLowerCase();\n\n  // Try underscore-separated dates first (YYYY_MM_DD)\n  // Used by DocuShare document management systems\n  const underscoreMatch = str.match(/(\\d{4})_(\\d{1,2})_(\\d{1,2})/);\n  if (underscoreMatch) {\n    const [, year, month, day] = underscoreMatch;\n    const date = new Date(\n      Number.parseInt(year, 10),\n      Number.parseInt(month, 10) - 1,\n      Number.parseInt(day, 10),\n    );\n    if (!Number.isNaN(date.getTime())) return date;\n  }\n\n  // Try US dot format (MM.DD.YYYY)\n  // Used by DocuShare file naming conventions\n  const dotMatch = str.match(/(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})/);\n  if (dotMatch) {\n    const [, month, day, year] = dotMatch;\n    const date = new Date(\n      Number.parseInt(year, 10),\n      Number.parseInt(month, 10) - 1,\n      Number.parseInt(day, 10),\n    );\n    if (!Number.isNaN(date.getTime())) return date;\n  }\n\n  // Try standard date formats (ISO, US, etc.)\n  // Pattern: YYYY-MM-DD or YYYY/MM/DD\n  const isoMatch = cleanStr.match(/(\\d{4})[-/](\\d{1,2})[-/](\\d{1,2})/);\n  if (isoMatch) {\n    const [, year, month, day] = isoMatch;\n    const date = new Date(\n      Number.parseInt(year, 10),\n      Number.parseInt(month, 10) - 1,\n      Number.parseInt(day, 10),\n    );\n    if (!Number.isNaN(date.getTime())) return date;\n  }\n\n  // Pattern: MM/DD/YYYY or MM-DD-YYYY\n  const usMatch = cleanStr.match(/(\\d{1,2})[-/](\\d{1,2})[-/](\\d{4})/);\n  if (usMatch) {\n    const [, month, day, year] = usMatch;\n    const date = new Date(\n      Number.parseInt(year, 10),\n      Number.parseInt(month, 10) - 1,\n      Number.parseInt(day, 10),\n    );\n    if (!Number.isNaN(date.getTime())) return date;\n  }\n\n  // Try to extract date from natural language (month name + day + year)\n  const yearMatch = cleanStr.match(/20\\d{2}/);\n  if (!yearMatch) return null;\n  const year = Number.parseInt(yearMatch[0], 10);\n\n  const monthPatterns: Record<string, number> = {\n    january: 1,\n    jan: 1,\n    february: 2,\n    feb: 2,\n    march: 3,\n    mar: 3,\n    april: 4,\n    apr: 4,\n    may: 5,\n    june: 6,\n    jun: 6,\n    july: 7,\n    jul: 7,\n    august: 8,\n    aug: 8,\n    september: 9,\n    sep: 9,\n    sept: 9,\n    october: 10,\n    oct: 10,\n    november: 11,\n    nov: 11,\n    december: 12,\n    dec: 12,\n  };\n\n  let foundMonth: number | null = null;\n  let monthStart = -1;\n  let monthName = '';\n\n  // Find the first month name in the string\n  for (const [name, monthNum] of Object.entries(monthPatterns)) {\n    const monthIndex = cleanStr.indexOf(name);\n    if (monthIndex !== -1) {\n      foundMonth = monthNum;\n      monthStart = monthIndex;\n      monthName = name;\n      break;\n    }\n  }\n\n  if (!foundMonth) return null;\n\n  // Look for day number near the month name or year (before or after)\n  // Search window: [month-15 chars] MONTH [month+15 chars] ... [year-15 chars] YEAR [year+15 chars]\n  const yearIndex = cleanStr.indexOf(yearMatch[0]);\n\n  const beforeMonth = cleanStr.substring(\n    Math.max(0, monthStart - 15),\n    monthStart,\n  );\n  const afterMonth = cleanStr.substring(\n    monthStart + monthName.length,\n    Math.min(cleanStr.length, monthStart + monthName.length + 15),\n  );\n  const beforeYear = cleanStr.substring(\n    Math.max(0, yearIndex - 15),\n    yearIndex,\n  );\n  const afterYear = cleanStr.substring(\n    yearIndex + 4,\n    Math.min(cleanStr.length, yearIndex + 19),\n  );\n\n  // Try to find day number (1-31) - avoiding matching digits from the year itself\n  // Look for day numbers that are isolated (not part of a longer number like \"2023\")\n  const dayMatch =\n    beforeMonth.match(/(?<!\\d)(\\d{1,2})\\s*$/) || // Day before month (not preceded by another digit)\n    afterMonth.match(/^\\s*(\\d{1,2})(?!\\d)/) || // Day right after month (not followed by another digit)\n    beforeYear.match(/(?<!\\d)(\\d{1,2})\\s*$/) || // Day before year (not preceded by another digit)\n    afterYear.match(/^\\s*(\\d{1,2})(?!\\d)/) || // Day right after year (not followed by another digit)\n    afterMonth.match(/[^\\d](\\d{1,2})(?!\\d)/); // Day with non-digit before and after in month area\n\n  const day = dayMatch ? Number.parseInt(dayMatch[1], 10) : 1; // Default to 1st if no day found\n\n  // Validate day is in reasonable range\n  if (day < 1 || day > 31) return null;\n\n  const date = new Date(year, foundMonth - 1, day);\n  return !Number.isNaN(date.getTime()) ? date : null;\n};\n\n/**\n * Formats a date string into a human-readable format using the system locale\n *\n * Uses the Intl.DateTimeFormat API to create localized, human-readable date strings.\n * Automatically adapts to the user's system locale settings.\n *\n * @param dateString - ISO date string or any valid date string\n * @returns Human-readable date string in system locale\n * @example\n * ```typescript\n * prettyDate(\"2023-01-15T12:00:00Z\"); // \"January 15, 2023\" (in English locale)\n * ```\n */\nexport const prettyDate = (dateString: string): string => {\n  const date = new Date(dateString);\n  return new Intl.DateTimeFormat(undefined, {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  }).format(date);\n};\n\n/**\n * String pluralization utilities using the pluralize library\n *\n * Re-exports the pluralize library function for word pluralization.\n * Handles English pluralization rules including irregular forms.\n *\n * @example\n * ```typescript\n * pluralizeWord(\"cat\"); // \"cats\"\n * pluralizeWord(\"mouse\"); // \"mice\"\n * singularize(\"cats\"); // \"cat\"\n * isPlural(\"cats\"); // true\n * isSingular(\"cat\"); // true\n * ```\n */\nexport const pluralizeWord = pluralize;\nexport const singularize = pluralize.singular;\nexport const isPlural = pluralize.isPlural;\nexport const isSingular = pluralize.isSingular;\n\n/**\n * Enhanced date utilities using date-fns library\n *\n * Re-exports commonly used date-fns functions for date manipulation and formatting.\n * Provides more reliable date handling than native Date methods.\n *\n * @param date - Date object or ISO string to format\n * @param formatStr - Format string (defaults to 'yyyy-MM-dd')\n * @returns Formatted date string\n * @example\n * ```typescript\n * formatDate(new Date(), 'yyyy-MM-dd'); // \"2023-01-15\"\n * formatDate(new Date(), 'MM/dd/yyyy'); // \"01/15/2023\"\n * parseDate('2023-01-15'); // Date object\n * isValidDate(new Date()); // true\n * addInterval(new Date(), { days: 7 }); // Date 7 days from now\n * ```\n */\nexport const formatDate = (\n  date: Date | string,\n  formatStr = 'yyyy-MM-dd',\n): string => {\n  const dateObj = typeof date === 'string' ? new Date(date) : date;\n  return format(dateObj, formatStr);\n};\n\nexport const parseDate = (dateStr: string, formatStr?: string): Date => {\n  if (formatStr) {\n    return parse(dateStr, formatStr, new Date());\n  }\n  return parseISO(dateStr);\n};\n\nexport const isValidDate = isValid;\nexport const addInterval = add;\n\n/**\n * Gets a temporary directory path (cross-platform)\n *\n * Creates a platform-appropriate temporary directory path under the .have-sdk namespace.\n * Uses environment variables in Node.js or falls back to /tmp.\n *\n * @param subfolder - Optional subfolder name within the temp directory\n * @returns Cross-platform temporary directory path\n * @example\n * ```typescript\n * getTempDirectory(); // \"/tmp/.have-sdk\" (Unix) or equivalent\n * getTempDirectory(\"cache\"); // \"/tmp/.have-sdk/cache\"\n * ```\n */\nexport const getTempDirectory = (subfolder?: string): string => {\n  // Use Node.js os.tmpdir() or fallback\n  const tmpBase = process?.env\n    ? process.env.TMPDIR || process.env.TMP || process.env.TEMP || '/tmp'\n    : '/tmp';\n\n  const basePath = `${tmpBase}/.have-sdk`;\n  return subfolder ? `${basePath}/${subfolder}` : basePath;\n};\n","/**\n * CLI Argument Parsing Utility\n *\n * Provides robust parsing for multi-word commands, options, and arguments.\n * Supports Node.js util.parseArgs for option parsing with fallback.\n */\n\nimport { basename } from 'node:path';\nimport { parseArgs as nodeParseArgs } from 'node:util';\n\n/**\n * Command option configuration\n */\nexport interface OptionConfig {\n  type: 'string' | 'boolean';\n  description: string;\n  default?: any;\n  short?: string;\n}\n\n/**\n * Command definition\n */\nexport interface Command {\n  name: string;\n  description: string;\n  aliases?: string[];\n  options?: Record<string, OptionConfig>;\n  args?: string[];\n  handler?: (args: any, options: any) => Promise<void>;\n}\n\n/**\n * Parsed command line arguments\n */\nexport interface ParsedArgs {\n  command?: string;\n  args: string[];\n  options: Record<string, any>;\n}\n\n/**\n * Parse command line arguments with support for multi-word commands\n *\n * Handles:\n * - Multi-word commands (up to 3 words: \"gnode create\", \"foo bar baz\")\n * - Command aliases\n * - Positional arguments\n * - Options using Node.js util.parseArgs\n * - Global flags (--help, --version)\n * - Automatic removal of node/script paths\n *\n * @param argv - Process argv or custom argument array\n * @param commands - Array of command definitions to match against\n * @param builtInCommands - Optional map of additional built-in commands\n * @returns Parsed arguments with command, args, and options\n *\n * @example\n * ```typescript\n * const parsed = parseCliArgs(\n *   ['node', 'cli.js', 'gnode', 'create', 'my-site', '--template=town'],\n *   commands\n * );\n * // { command: 'gnode create', args: ['my-site'], options: { template: 'town' } }\n * ```\n */\nexport function parseCliArgs(\n  argv: string[],\n  commands: Command[],\n  builtInCommands: Record<string, Command> = {},\n): ParsedArgs {\n  // Remove node and script name if present\n  // Be precise: only remove if it's actually the node executable or a .js file\n  // Use basename to avoid matching commands like \"gnode\" which end with \"node\"\n  let args = argv;\n\n  // Check if first arg is node executable (check basename to avoid false matches)\n  if (args.length > 0 && basename(args[0]) === 'node') {\n    args = args.slice(1);\n  }\n\n  // Check if first arg is a .js file (script name)\n  if (args.length > 0 && args[0].endsWith('.js')) {\n    args = args.slice(1);\n  }\n\n  if (args.length === 0) {\n    return { args: [], options: {} };\n  }\n\n  // Handle global --help flag (check for -h later to avoid conflict with command options)\n  if (args.includes('--help')) {\n    return { command: 'help', args: [], options: {} };\n  }\n\n  if (args.includes('--version')) {\n    return { command: 'version', args: [], options: {} };\n  }\n\n  // Try to match multi-word commands (longest match wins)\n  let matchedCommand: Command | undefined;\n  let commandName: string | undefined;\n  let commandWordCount = 0;\n\n  // Try up to 3 words for command name (e.g., \"foo bar baz\")\n  for (let i = Math.min(3, args.length); i > 0; i--) {\n    const possibleCommand = args.slice(0, i).join(' ');\n    const found =\n      builtInCommands[possibleCommand] ||\n      commands.find(\n        (cmd) =>\n          cmd.name === possibleCommand ||\n          cmd.aliases?.includes(possibleCommand),\n      );\n\n    if (found) {\n      matchedCommand = found;\n      commandName = possibleCommand;\n      commandWordCount = i;\n      break;\n    }\n  }\n\n  // If no multi-word match, try single word\n  if (!commandName && args.length > 0) {\n    commandName = args[0];\n    commandWordCount = 1;\n    matchedCommand = commands.find(\n      (cmd) =>\n        cmd.name === commandName ||\n        cmd.aliases?.includes(commandName as string),\n    );\n  }\n\n  // If no command matched, check for global short flags\n  if (!matchedCommand) {\n    if (args.includes('-h')) {\n      return { command: 'help', args: [], options: {} };\n    }\n    if (args.includes('-v')) {\n      return { command: 'version', args: [], options: {} };\n    }\n    // Return unknown command with args filtered\n    return {\n      command: commandName,\n      args: args.slice(1).filter((arg) => !arg.startsWith('-')),\n      options: {},\n    };\n  }\n\n  // Build parseArgs config from command definition\n  const parseConfig: any = {\n    args: args.slice(commandWordCount),\n    options: {},\n    strict: false, // Allow unknown options\n    allowPositionals: true, // Required for mixing positional args and options\n  };\n\n  if (matchedCommand.options) {\n    for (const [name, option] of Object.entries(matchedCommand.options)) {\n      parseConfig.options[name] = {\n        type: option.type === 'boolean' ? 'boolean' : 'string',\n        ...(option.default !== undefined && { default: option.default }),\n      };\n      if (option.short) {\n        parseConfig.options[name].short = option.short;\n      }\n    }\n  }\n\n  try {\n    const parsed = nodeParseArgs(parseConfig);\n    return {\n      command: commandName,\n      args: parsed.positionals || [],\n      options: parsed.values || {},\n    };\n  } catch (error) {\n    // Fallback for parse errors - extract positional args manually\n    return {\n      command: commandName,\n      args: args.slice(commandWordCount).filter((arg) => !arg.startsWith('-')),\n      options: {},\n    };\n  }\n}\n","/**\n * Web and URL utility functions\n *\n * General-purpose utilities for working with URLs and web content.\n * Used by scrapers, note systems, and content processors.\n */\n\nimport { createHash } from 'node:crypto';\n\n/**\n * Normalize URL for consistent key storage\n * Removes tracking params, sorts query string, lowercases, etc.\n *\n * @param url - The URL to normalize\n * @returns Normalized URL string\n */\nexport function normalizeUrl(url: string): string {\n  const parsed = new URL(url);\n\n  // Lowercase scheme and host\n  parsed.protocol = parsed.protocol.toLowerCase();\n  parsed.hostname = parsed.hostname.toLowerCase();\n\n  // Remove www prefix\n  parsed.hostname = parsed.hostname.replace(/^www\\./, '');\n\n  // Remove default ports\n  if (\n    (parsed.protocol === 'http:' && parsed.port === '80') ||\n    (parsed.protocol === 'https:' && parsed.port === '443')\n  ) {\n    parsed.port = '';\n  }\n\n  // Remove fragment\n  parsed.hash = '';\n\n  // Sort and filter query params\n  const params = new URLSearchParams(parsed.search);\n  const filtered = new URLSearchParams();\n  const trackingParams = [\n    'utm_source',\n    'utm_medium',\n    'utm_campaign',\n    'utm_content',\n    'utm_term',\n    'fbclid',\n    'gclid',\n    'msclkid',\n    '_ga',\n    'mc_cid',\n    'mc_eid',\n  ];\n\n  Array.from(params.keys())\n    .sort()\n    .forEach((key) => {\n      if (!trackingParams.includes(key)) {\n        filtered.set(key, params.get(key)!);\n      }\n    });\n\n  parsed.search = filtered.toString();\n\n  return parsed.toString();\n}\n\n/**\n * Generate hierarchical scope from URL for organized note storage\n *\n * @param url - The URL to generate scope from\n * @param baseScope - Base scope prefix (default: 'discovery/parser')\n * @returns Hierarchical scope string\n *\n * @example\n * generateScopeFromUrl('https://cityofboston.gov/meetings/minutes')\n * // Returns: 'discovery/parser/cityofboston.gov/meetings'\n */\nexport function generateScopeFromUrl(\n  url: string,\n  baseScope = 'discovery/parser',\n): string {\n  const parsed = new URL(normalizeUrl(url));\n  const domain = parsed.hostname;\n  const pathParts = parsed.pathname.split('/').filter((p) => p);\n\n  // Use first path segment as page type (e.g., 'meetings', 'documents')\n  const pageType = pathParts[0] || 'index';\n\n  return `${baseScope}/${domain}/${pageType}`;\n}\n\n/**\n * Hash page content for change detection\n * Uses SHA-256 to create a unique fingerprint of the HTML\n *\n * @param html - Page HTML content\n * @returns SHA-256 hash as hex string\n */\nexport function hashPageContent(html: string): string {\n  return createHash('sha256').update(html).digest('hex');\n}\n"],"names":["ErrorCode","cuid2CreateId","year","day","date","nodeParseArgs"],"mappings":"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"}