{"version":3,"file":"index.js","sources":["../src/tag.ts","../src/tag-alias.ts","../src/tags.ts","../src/tag-aliases.ts","../src/utils.ts"],"sourcesContent":["/**\n * Tag model - Core entity for tagging with hierarchy and context support\n *\n * Central table for tag definitions with optional parent-child relationships\n * for taxonomies and category trees.\n */\n\nimport { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';\nimport type { TagOptions, TagMetadata } from './types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class Tag extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  protected _slug = ''; // Unique identifier\n  protected _context = 'global'; // Namespace/grouping\n\n  // Override SmrtObject accessors\n  override get slug(): string {\n    return this._slug;\n  }\n  override set slug(value: string) {\n    this._slug = value;\n  }\n\n  override get context(): string {\n    return this._context;\n  }\n  override set context(value: string) {\n    this._context = value;\n  }\n\n  name = ''; // Display name\n  parentSlug = ''; // FK to parent tag for hierarchy (nullable)\n  level = 0; // Hierarchy depth (0 = root)\n  description = ''; // Optional description\n  metadata = ''; // JSON metadata stored as text\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: TagOptions = {}) {\n    super(options);\n    if (options.slug) this._slug = options.slug;\n    if (options.name) this.name = options.name;\n    if (options.context !== undefined) this._context = options.context;\n    if (options.parentSlug !== undefined) this.parentSlug = options.parentSlug;\n    if (options.level !== undefined) this.level = options.level;\n    if (options.description !== undefined)\n      this.description = options.description;\n\n    // Handle metadata - can be object or JSON string\n    if (options.metadata !== undefined) {\n      if (typeof options.metadata === 'string') {\n        this.metadata = options.metadata;\n      } else {\n        this.metadata = JSON.stringify(options.metadata);\n      }\n    }\n  }\n\n  /**\n   * Get metadata as parsed object\n   *\n   * @returns Parsed metadata object or empty object if no metadata\n   */\n  getMetadata(): TagMetadata {\n    if (!this.metadata) return {};\n    try {\n      return JSON.parse(this.metadata);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set metadata from object\n   *\n   * @param data - Metadata object to store\n   */\n  setMetadata(data: TagMetadata): void {\n    this.metadata = JSON.stringify(data);\n  }\n\n  /**\n   * Update metadata by merging with existing values\n   *\n   * @param updates - Partial metadata to merge\n   */\n  updateMetadata(updates: Partial<TagMetadata>): void {\n    const current = this.getMetadata();\n    this.setMetadata({ ...current, ...updates });\n  }\n\n  /**\n   * Get the parent tag\n   *\n   * @returns Parent Tag instance or null if no parent\n   */\n  async getParent(): Promise<Tag | null> {\n    if (!this.parentSlug) return null;\n\n    const { TagCollection } = await import('./tags');\n    const collection = await TagCollection.create(this.options);\n\n    return await collection.get({ slug: this.parentSlug });\n  }\n\n  /**\n   * Get immediate child tags\n   *\n   * @returns Array of child Tag instances\n   */\n  async getChildren(): Promise<Tag[]> {\n    const { TagCollection } = await import('./tags');\n    const collection = await TagCollection.create(this.options);\n\n    return await collection.list({ where: { parentSlug: this.slug } });\n  }\n\n  /**\n   * Get all ancestor tags (recursive)\n   *\n   * @returns Array of ancestor tags from root to immediate parent\n   */\n  async getAncestors(): Promise<Tag[]> {\n    const ancestors: Tag[] = [];\n    let current: Tag = this;\n\n    while (current.parentSlug) {\n      const parent = await current.getParent();\n      if (!parent) break;\n      ancestors.unshift(parent); // Add to beginning\n      current = parent;\n    }\n\n    return ancestors;\n  }\n\n  /**\n   * Get all descendant tags (recursive)\n   *\n   * @returns Array of all descendant tags\n   */\n  async getDescendants(): Promise<Tag[]> {\n    const children = await this.getChildren();\n    const descendants: Tag[] = [...children];\n\n    for (const child of children) {\n      const childDescendants = await child.getDescendants();\n      descendants.push(...childDescendants);\n    }\n\n    return descendants;\n  }\n\n  /**\n   * Convenience method for slug-based lookup\n   *\n   * @param slug - The slug to search for\n   * @param context - Optional context filter\n   * @returns Tag instance or null if not found\n   */\n  static async getBySlug(slug: string, context?: string): Promise<Tag | null> {\n    // Will be auto-implemented by SMRT\n    return null;\n  }\n\n  /**\n   * Get root tags (no parent) for a context\n   *\n   * @param context - The context to filter by\n   * @returns Array of root tags\n   */\n  static async getRootTags(context: string = 'global'): Promise<Tag[]> {\n    // Will be auto-implemented by SMRT\n    return [];\n  }\n}\n","/**\n * TagAlias model - Alternative names and translations for tags\n *\n * Stores aliases, variations, and multi-language translations for tags.\n * Supports language-neutral aliases and context-scoped variations.\n */\n\nimport { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';\nimport type { TagAliasOptions } from './types';\nimport type { Tag } from './tag';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create'] },\n  cli: true,\n})\nexport class TagAlias extends SmrtObject {\n  // id: UUID (auto-generated by SmrtObject)\n  tagSlug = ''; // FK to Tag.slug\n  alias = ''; // Alternative name or translation\n  language = ''; // ISO 639-1 language code (nullable)\n  protected _context = ''; // Optional context scoping (nullable)\n\n  // Override SmrtObject accessor\n  override get context(): string {\n    return this._context;\n  }\n  override set context(value: string) {\n    this._context = value;\n  }\n\n  // Timestamps\n  createdAt = new Date();\n\n  constructor(options: TagAliasOptions = {}) {\n    super(options);\n    if (options.tagSlug) this.tagSlug = options.tagSlug;\n    if (options.alias) this.alias = options.alias;\n    if (options.language !== undefined) this.language = options.language;\n    if (options.context !== undefined) this._context = options.context;\n  }\n\n  /**\n   * Get the tag this alias belongs to\n   *\n   * @returns Tag instance or null if not found\n   */\n  async getTag(): Promise<Tag | null> {\n    const { TagCollection } = await import('./tags');\n    const collection = await TagCollection.create(this.options);\n\n    return await collection.get({ slug: this.tagSlug });\n  }\n\n  /**\n   * Search tags by alias\n   *\n   * @param alias - The alias to search for\n   * @param language - Optional language filter\n   * @returns Array of matching tags\n   */\n  static async searchByAlias(alias: string, language?: string): Promise<Tag[]> {\n    // Will be auto-implemented by SMRT\n    return [];\n  }\n\n  /**\n   * Get all aliases for a tag\n   *\n   * @param tagSlug - The tag slug to get aliases for\n   * @returns Array of TagAlias instances\n   */\n  static async getAliasesForTag(tagSlug: string): Promise<TagAlias[]> {\n    // Will be auto-implemented by SMRT\n    return [];\n  }\n}\n","/**\n * TagCollection - Collection manager for Tag objects\n *\n * Provides hierarchy traversal, context filtering, and advanced tag operations.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { Tag } from './tag';\nimport type { TagHierarchy } from './types';\n\nexport class TagCollection extends SmrtCollection<Tag> {\n  static readonly _itemClass = Tag;\n\n  /**\n   * Get or create a tag with context\n   *\n   * @param slug - Tag slug\n   * @param context - Tag context (default: 'global')\n   * @returns Tag instance\n   */\n  async getOrCreate(slug: string, context: string = 'global'): Promise<Tag> {\n    // First try to find existing tag with this slug and context\n    const existing = await this.list({\n      where: { slug, context },\n      limit: 1,\n    });\n\n    if (existing.length > 0) {\n      return existing[0];\n    }\n\n    // Create new tag\n    return await this.create({\n      slug,\n      name: slug.replace(/-/g, ' ').replace(/\\b\\w/g, (l) => l.toUpperCase()),\n      context,\n      level: 0,\n    });\n  }\n\n  /**\n   * List tags by context with optional parent filtering\n   *\n   * @param context - The context to filter by\n   * @param parentSlug - Optional parent slug to filter children\n   * @returns Array of matching tags\n   */\n  async listByContext(context: string, parentSlug?: string): Promise<Tag[]> {\n    const where: any = { context };\n    if (parentSlug !== undefined) {\n      where.parentSlug = parentSlug;\n    }\n    return await this.list({ where });\n  }\n\n  /**\n   * Get root tags (no parent) for a context\n   *\n   * @param context - The context to filter by (default: 'global')\n   * @returns Array of root tags\n   */\n  async getRootTags(context: string = 'global'): Promise<Tag[]> {\n    return await this.list({\n      where: { context, parentSlug: null },\n    });\n  }\n\n  /**\n   * Get immediate children of a parent tag\n   *\n   * @param parentSlug - The parent tag slug\n   * @returns Array of child tags\n   */\n  async getChildren(parentSlug: string): Promise<Tag[]> {\n    return await this.list({\n      where: { parentSlug },\n    });\n  }\n\n  /**\n   * Get tag hierarchy (all ancestors and descendants)\n   *\n   * @param slug - The tag slug\n   * @returns Object with ancestors, current tag, and descendants\n   */\n  async getHierarchy(slug: string): Promise<TagHierarchy> {\n    const tag = await this.get({ slug });\n    if (!tag) throw new Error(`Tag '${slug}' not found`);\n\n    const ancestors = await this.getAncestors(tag);\n    const descendants = await this.getDescendants(tag);\n\n    return { ancestors, current: tag, descendants };\n  }\n\n  /**\n   * Move a tag to a new parent (updates level automatically)\n   *\n   * @param slug - The tag to move\n   * @param newParentSlug - The new parent slug (null for root)\n   * @throws Error if circular reference detected\n   */\n  async moveTag(slug: string, newParentSlug: string | null): Promise<void> {\n    const tag = await this.get({ slug });\n    if (!tag) throw new Error(`Tag '${slug}' not found`);\n\n    // Check for circular reference\n    if (newParentSlug) {\n      const hasCircular = await this.hasCircularReference(slug, newParentSlug);\n      if (hasCircular) {\n        throw new Error(\n          `Cannot move tag: circular reference detected (${slug} -> ${newParentSlug})`,\n        );\n      }\n    }\n\n    // Calculate new level\n    const newLevel = await this.calculateLevel(newParentSlug);\n\n    // Update tag\n    tag.parentSlug = newParentSlug || '';\n    tag.level = newLevel;\n    await tag.save();\n\n    // Recursively update levels for all descendants\n    await this.updateDescendantLevels(tag);\n  }\n\n  /**\n   * Merge one tag into another (updates all references)\n   *\n   * Note: This method updates the tag itself but consuming packages\n   * are responsible for updating their join tables (e.g., asset_tags)\n   *\n   * @param fromSlug - The tag to merge from\n   * @param toSlug - The tag to merge into\n   */\n  async mergeTag(fromSlug: string, toSlug: string): Promise<void> {\n    const fromTag = await this.get({ slug: fromSlug });\n    const toTag = await this.get({ slug: toSlug });\n\n    if (!fromTag) throw new Error(`Source tag '${fromSlug}' not found`);\n    if (!toTag) throw new Error(`Target tag '${toSlug}' not found`);\n\n    // Move all children of fromTag to toTag\n    const children = await this.getChildren(fromSlug);\n    for (const child of children) {\n      child.parentSlug = toSlug;\n      await child.save();\n    }\n\n    // Copy aliases from fromTag to toTag\n    const { TagAliasCollection } = await import('./tag-aliases');\n    const aliasCollection = await TagAliasCollection.create(this.options);\n\n    const aliases = await aliasCollection.list({\n      where: { tagSlug: fromSlug },\n    });\n    for (const alias of aliases) {\n      alias.tagSlug = toSlug;\n      await alias.save();\n    }\n\n    // Delete the fromTag\n    await fromTag.delete();\n  }\n\n  /**\n   * Remove tags with no references (cleanup unused tags)\n   *\n   * Note: This requires consuming packages to provide usage information.\n   * By default, only removes tags with no children and no aliases.\n   *\n   * @param context - Optional context to filter cleanup\n   */\n  async cleanupUnused(context?: string): Promise<number> {\n    const where: any = {};\n    if (context) where.context = context;\n\n    const tags = await this.list({ where });\n    const { TagAliasCollection } = await import('./tag-aliases');\n    const aliasCollection = await TagAliasCollection.create(this.options);\n\n    let deletedCount = 0;\n\n    for (const tag of tags) {\n      // Check if tag has children\n      const children = await this.getChildren(tag.slug);\n      if (children.length > 0) continue;\n\n      // Check if tag has aliases\n      const aliases = await aliasCollection.list({\n        where: { tagSlug: tag.slug },\n      });\n      if (aliases.length > 0) continue;\n\n      // No children, no aliases - safe to delete\n      await tag.delete();\n      deletedCount++;\n    }\n\n    return deletedCount;\n  }\n\n  /**\n   * Calculate hierarchy level for a tag\n   *\n   * @param parentSlug - The parent tag slug (null for root)\n   * @returns The calculated level\n   */\n  async calculateLevel(parentSlug: string | null): Promise<number> {\n    if (!parentSlug) return 0;\n\n    const parent = await this.get({ slug: parentSlug });\n    if (!parent) return 0;\n\n    return parent.level + 1;\n  }\n\n  /**\n   * Check if moving a tag would create a circular reference\n   *\n   * @param slug - The tag being moved\n   * @param newParentSlug - The proposed new parent\n   * @returns True if circular reference detected\n   */\n  private async hasCircularReference(\n    slug: string,\n    newParentSlug: string,\n  ): Promise<boolean> {\n    let current = newParentSlug;\n\n    while (current) {\n      if (current === slug) return true; // Circular reference found\n\n      const parent = await this.get({ slug: current });\n      if (!parent || !parent.parentSlug) break;\n\n      current = parent.parentSlug;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get all ancestor tags (recursive)\n   *\n   * @param tag - The tag to get ancestors for\n   * @returns Array of ancestor tags from root to immediate parent\n   */\n  private async getAncestors(tag: Tag): Promise<Tag[]> {\n    const ancestors: Tag[] = [];\n    let current = tag;\n\n    while (current.parentSlug) {\n      const parent = await this.get({ slug: current.parentSlug });\n      if (!parent) break;\n      ancestors.unshift(parent); // Add to beginning\n      current = parent;\n    }\n\n    return ancestors;\n  }\n\n  /**\n   * Get all descendant tags (recursive)\n   *\n   * @param tag - The tag to get descendants for\n   * @returns Array of all descendant tags\n   */\n  private async getDescendants(tag: Tag): Promise<Tag[]> {\n    const children = await this.list({ where: { parentSlug: tag.slug } });\n    const descendants: Tag[] = [...children];\n\n    for (const child of children) {\n      const childDescendants = await this.getDescendants(child);\n      descendants.push(...childDescendants);\n    }\n\n    return descendants;\n  }\n\n  /**\n   * Update levels for all descendants after moving a tag\n   *\n   * @param tag - The tag that was moved\n   */\n  private async updateDescendantLevels(tag: Tag): Promise<void> {\n    const children = await this.getChildren(tag.slug);\n\n    for (const child of children) {\n      child.level = tag.level + 1;\n      await child.save();\n      await this.updateDescendantLevels(child); // Recursive\n    }\n  }\n}\n","/**\n * TagAliasCollection - Collection manager for TagAlias objects\n *\n * Provides alias management, multi-language search, and bulk operations.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { TagAlias } from './tag-alias';\nimport type { Tag } from './tag';\n\nexport class TagAliasCollection extends SmrtCollection<TagAlias> {\n  static readonly _itemClass = TagAlias;\n\n  /**\n   * Add an alias to a tag (get or create)\n   *\n   * @param tagSlug - The tag slug\n   * @param alias - The alias text\n   * @param language - Optional language code\n   * @param context - Optional context\n   * @returns TagAlias instance\n   */\n  async addAlias(\n    tagSlug: string,\n    alias: string,\n    language?: string,\n    context?: string,\n  ): Promise<TagAlias> {\n    // Check if alias already exists\n    const where: any = { tagSlug, alias };\n    if (language) where.language = language;\n    if (context) where.context = context;\n\n    const existing = await this.list({ where, limit: 1 });\n    if (existing.length > 0) {\n      return existing[0];\n    }\n\n    // Create new alias\n    return await this.create({\n      tagSlug,\n      alias,\n      language,\n      context,\n    });\n  }\n\n  /**\n   * Search tags by alias\n   *\n   * @param alias - The alias to search for\n   * @param language - Optional language filter\n   * @returns Array of matching tags\n   */\n  async searchByAlias(alias: string, language?: string): Promise<Tag[]> {\n    const where: any = { alias };\n    if (language) where.language = language;\n\n    const aliases = await this.list({ where });\n    const tagSlugs = [...new Set(aliases.map((a) => a.tagSlug))];\n\n    const { TagCollection } = await import('./tags');\n    const tagCollection = await TagCollection.create(this.options);\n\n    const tags: Tag[] = [];\n    for (const slug of tagSlugs) {\n      const tag = await tagCollection.get({ slug });\n      if (tag) tags.push(tag);\n    }\n\n    return tags;\n  }\n\n  /**\n   * Get all aliases for a tag\n   *\n   * @param tagSlug - The tag slug\n   * @param language - Optional language filter\n   * @returns Array of TagAlias instances\n   */\n  async getAliasesForTag(\n    tagSlug: string,\n    language?: string,\n  ): Promise<TagAlias[]> {\n    const where: any = { tagSlug };\n    if (language) where.language = language;\n\n    return await this.list({ where });\n  }\n\n  /**\n   * Remove an alias by ID\n   *\n   * @param aliasId - The alias UUID\n   */\n  async removeAlias(aliasId: string): Promise<void> {\n    const alias = await this.get({ id: aliasId });\n    if (alias) {\n      await alias.delete();\n    }\n  }\n\n  /**\n   * Bulk add aliases to a tag\n   *\n   * @param tagSlug - The tag slug\n   * @param aliases - Array of alias configurations\n   * @returns Array of created TagAlias instances\n   */\n  async bulkAddAliases(\n    tagSlug: string,\n    aliases: Array<{\n      alias: string;\n      language?: string;\n      context?: string;\n    }>,\n  ): Promise<TagAlias[]> {\n    const created: TagAlias[] = [];\n\n    for (const aliasData of aliases) {\n      const tagAlias = await this.addAlias(\n        tagSlug,\n        aliasData.alias,\n        aliasData.language,\n        aliasData.context,\n      );\n      created.push(tagAlias);\n    }\n\n    return created;\n  }\n\n  /**\n   * Get aliases grouped by language\n   *\n   * @param tagSlug - The tag slug\n   * @returns Map of language code to array of aliases\n   */\n  async getAliasesByLanguage(tagSlug: string): Promise<Map<string, string[]>> {\n    const aliases = await this.getAliasesForTag(tagSlug);\n    const grouped = new Map<string, string[]>();\n\n    for (const alias of aliases) {\n      const lang = alias.language || 'default';\n      if (!grouped.has(lang)) {\n        grouped.set(lang, []);\n      }\n      grouped.get(lang)?.push(alias.alias);\n    }\n\n    return grouped;\n  }\n\n  /**\n   * Find similar aliases (case-insensitive partial match)\n   *\n   * Note: This is a simple implementation. For production use,\n   * consider using full-text search or fuzzy matching.\n   *\n   * @param query - The search query\n   * @param language - Optional language filter\n   * @returns Array of matching TagAlias instances\n   */\n  async findSimilar(query: string, language?: string): Promise<TagAlias[]> {\n    const where: any = {};\n    if (language) where.language = language;\n\n    const all = await this.list({ where });\n    const queryLower = query.toLowerCase();\n\n    return all.filter((alias) =>\n      alias.alias.toLowerCase().includes(queryLower),\n    );\n  }\n}\n","/**\n * Utility functions for tag management\n */\n\nimport type { TagCollection } from './tags';\n\n/**\n * Validate slug format (lowercase, alphanumeric + hyphens)\n *\n * @param slug - The slug to validate\n * @returns True if slug is valid\n */\nexport function validateSlug(slug: string): boolean {\n  // Slug must be lowercase alphanumeric with hyphens\n  const slugPattern = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;\n  return slugPattern.test(slug);\n}\n\n/**\n * Sanitize slug input\n *\n * Converts to lowercase, replaces spaces with hyphens,\n * removes invalid characters, and ensures proper format.\n *\n * @param input - The input string to sanitize\n * @returns Sanitized slug\n */\nexport function sanitizeSlug(input: string): string {\n  return input\n    .toLowerCase() // Convert to lowercase\n    .trim() // Remove leading/trailing whitespace\n    .replace(/\\s+/g, '-') // Replace spaces with hyphens\n    .replace(/[^a-z0-9-]/g, '') // Remove invalid characters\n    .replace(/-+/g, '-') // Replace multiple hyphens with single\n    .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens\n}\n\n/**\n * Validate hierarchy for circular references\n *\n * Checks if setting a parent would create a circular reference\n * (e.g., making a tag its own ancestor).\n *\n * @param slug - The tag being moved\n * @param parentSlug - The proposed new parent\n * @param tagCollection - TagCollection instance for queries\n * @returns True if circular reference detected\n */\nexport async function hasCircularReference(\n  slug: string,\n  parentSlug: string,\n  tagCollection: TagCollection,\n): Promise<boolean> {\n  let current = parentSlug;\n\n  while (current) {\n    if (current === slug) return true; // Circular reference found\n\n    const parent = await tagCollection.get({ slug: current });\n    if (!parent || !parent.parentSlug) break;\n\n    current = parent.parentSlug;\n  }\n\n  return false;\n}\n\n/**\n * Calculate hierarchy level\n *\n * Determines the level (depth) of a tag based on its parent.\n * Root tags have level 0, their children have level 1, etc.\n *\n * @param parentSlug - The parent tag slug (null for root)\n * @param tagCollection - TagCollection instance for queries\n * @returns The calculated level\n */\nexport async function calculateLevel(\n  parentSlug: string | null,\n  tagCollection: TagCollection,\n): Promise<number> {\n  if (!parentSlug) return 0;\n\n  const parent = await tagCollection.get({ slug: parentSlug });\n  if (!parent) return 0;\n\n  return parent.level + 1;\n}\n\n/**\n * Generate a unique slug from a name\n *\n * Creates a slug and ensures uniqueness by appending a number if needed.\n *\n * @param name - The name to convert to slug\n * @param context - The context for uniqueness checking\n * @param tagCollection - TagCollection instance for queries\n * @returns Unique slug\n */\nexport async function generateUniqueSlug(\n  name: string,\n  context: string,\n  tagCollection: TagCollection,\n): Promise<string> {\n  const baseSlug = sanitizeSlug(name);\n  let slug = baseSlug;\n  let counter = 1;\n\n  // Check if slug exists, append number if needed\n  while (true) {\n    const existing = await tagCollection.list({\n      where: { slug, context },\n      limit: 1,\n    });\n\n    if (existing.length === 0) break;\n\n    slug = `${baseSlug}-${counter}`;\n    counter++;\n  }\n\n  return slug;\n}\n"],"names":["TagCollection","_init","TagAliasCollection","tags"],"mappings":"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"}