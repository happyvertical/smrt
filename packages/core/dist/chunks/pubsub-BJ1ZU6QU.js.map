{"version":3,"file":"pubsub-BJ1ZU6QU.js","sources":["../../src/adapters/pubsub.ts"],"sourcesContent":["/**\n * Pub/Sub Adapter for Signal System\n *\n * Broadcasts signals to subscribers for real-time updates.\n * Supports multiple subscriber types (callbacks, WebSocket, SSE).\n */\n\nimport type { SignalAdapter, Signal } from '@smrt/types';\n\n/**\n * Signal filter function\n *\n * @param signal - Signal to evaluate\n * @returns True if signal should be sent to subscriber\n */\nexport type SignalFilter = (signal: Signal) => boolean;\n\n/**\n * Signal subscriber callback\n */\nexport type SignalSubscriber = (signal: Signal) => void | Promise<void>;\n\n/**\n * Subscription configuration\n */\nexport interface Subscription {\n  /** Unique subscription ID */\n  id: string;\n  /** Callback to invoke with signals */\n  callback: SignalSubscriber;\n  /** Optional filter to apply before sending */\n  filter?: SignalFilter;\n}\n\n/**\n * Pub/Sub Adapter - Broadcasts signals to subscribers\n *\n * Enables real-time updates for UI clients via WebSocket/SSE or\n * internal event-driven architectures via callbacks.\n *\n * Features:\n * - Multiple subscribers with independent filters\n * - Fire-and-forget delivery (errors don't block other subscribers)\n * - Flexible filtering (by class, method, type, etc.)\n * - Subscription management (add, remove, list)\n *\n * @example\n * ```typescript\n * const pubsub = new PubSubAdapter();\n * signalBus.register(pubsub);\n *\n * // Subscribe to all error signals\n * const subId = pubsub.subscribe(\n *   (signal) => console.error('Error:', signal),\n *   (signal) => signal.type === 'error'\n * );\n *\n * // Later, unsubscribe\n * pubsub.unsubscribe(subId);\n * ```\n */\nexport class PubSubAdapter implements SignalAdapter {\n  private subscriptions: Map<string, Subscription> = new Map();\n  private nextSubscriptionId = 1;\n\n  /**\n   * Handle a signal and broadcast to subscribers\n   *\n   * @param signal - Signal to broadcast\n   */\n  async handle(signal: Signal): Promise<void> {\n    // Broadcast to all matching subscribers\n    const promises: Promise<void>[] = [];\n\n    for (const subscription of this.subscriptions.values()) {\n      // Apply filter if present\n      if (subscription.filter && !subscription.filter(signal)) {\n        continue;\n      }\n\n      // Execute callback with error handling\n      const promise = (async () => {\n        try {\n          await subscription.callback(signal);\n        } catch (error) {\n          console.error(\n            `PubSubAdapter: Subscriber ${subscription.id} error:`,\n            error,\n          );\n        }\n      })();\n\n      promises.push(promise);\n    }\n\n    // Wait for all subscribers to process (fire-and-forget style)\n    await Promise.allSettled(promises);\n  }\n\n  /**\n   * Subscribe to signals\n   *\n   * @param callback - Function to call with matching signals\n   * @param filter - Optional filter to apply before sending\n   * @returns Subscription ID for later unsubscribe\n   */\n  subscribe(callback: SignalSubscriber, filter?: SignalFilter): string {\n    const id = `sub-${this.nextSubscriptionId++}`;\n\n    this.subscriptions.set(id, {\n      id,\n      callback,\n      filter,\n    });\n\n    return id;\n  }\n\n  /**\n   * Unsubscribe from signals\n   *\n   * @param subscriptionId - ID returned from subscribe()\n   * @returns True if subscription was found and removed\n   */\n  unsubscribe(subscriptionId: string): boolean {\n    return this.subscriptions.delete(subscriptionId);\n  }\n\n  /**\n   * Get count of active subscriptions\n   *\n   * @returns Number of active subscribers\n   */\n  get subscriberCount(): number {\n    return this.subscriptions.size;\n  }\n\n  /**\n   * Clear all subscriptions\n   *\n   * Removes all subscribers. Useful for cleanup or testing.\n   */\n  clearSubscriptions(): void {\n    this.subscriptions.clear();\n  }\n\n  /**\n   * Create filter for specific class\n   *\n   * @param className - Class name to match\n   * @returns Filter function\n   */\n  static filterByClass(className: string): SignalFilter {\n    return (signal: Signal) => signal.className === className;\n  }\n\n  /**\n   * Create filter for specific method\n   *\n   * @param methodName - Method name to match\n   * @returns Filter function\n   */\n  static filterByMethod(methodName: string): SignalFilter {\n    return (signal: Signal) => signal.method === methodName;\n  }\n\n  /**\n   * Create filter for specific signal type\n   *\n   * @param type - Signal type to match\n   * @returns Filter function\n   */\n  static filterByType(type: 'start' | 'step' | 'end' | 'error'): SignalFilter {\n    return (signal: Signal) => signal.type === type;\n  }\n\n  /**\n   * Create filter for specific class and method\n   *\n   * @param className - Class name to match\n   * @param methodName - Method name to match\n   * @returns Filter function\n   */\n  static filterByClassAndMethod(\n    className: string,\n    methodName: string,\n  ): SignalFilter {\n    return (signal: Signal) =>\n      signal.className === className && signal.method === methodName;\n  }\n\n  /**\n   * Combine multiple filters with AND logic\n   *\n   * @param filters - Filters to combine\n   * @returns Combined filter function\n   */\n  static combineFilters(...filters: SignalFilter[]): SignalFilter {\n    return (signal: Signal) => filters.every((filter) => filter(signal));\n  }\n}\n"],"names":[],"mappings":"AA6DO,MAAM,cAAuC;AAAA,EAC1C,oCAA+C,IAAA;AAAA,EAC/C,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO7B,MAAM,OAAO,QAA+B;AAE1C,UAAM,WAA4B,CAAA;AAElC,eAAW,gBAAgB,KAAK,cAAc,OAAA,GAAU;AAEtD,UAAI,aAAa,UAAU,CAAC,aAAa,OAAO,MAAM,GAAG;AACvD;AAAA,MACF;AAGA,YAAM,WAAW,YAAY;AAC3B,YAAI;AACF,gBAAM,aAAa,SAAS,MAAM;AAAA,QACpC,SAAS,OAAO;AACd,kBAAQ;AAAA,YACN,6BAA6B,aAAa,EAAE;AAAA,YAC5C;AAAA,UAAA;AAAA,QAEJ;AAAA,MACF,GAAA;AAEA,eAAS,KAAK,OAAO;AAAA,IACvB;AAGA,UAAM,QAAQ,WAAW,QAAQ;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,UAA4B,QAA+B;AACnE,UAAM,KAAK,OAAO,KAAK,oBAAoB;AAE3C,SAAK,cAAc,IAAI,IAAI;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,gBAAiC;AAC3C,WAAO,KAAK,cAAc,OAAO,cAAc;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,kBAA0B;AAC5B,WAAO,KAAK,cAAc;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAA2B;AACzB,SAAK,cAAc,MAAA;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,cAAc,WAAiC;AACpD,WAAO,CAAC,WAAmB,OAAO,cAAc;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,eAAe,YAAkC;AACtD,WAAO,CAAC,WAAmB,OAAO,WAAW;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,aAAa,MAAwD;AAC1E,WAAO,CAAC,WAAmB,OAAO,SAAS;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,uBACL,WACA,YACc;AACd,WAAO,CAAC,WACN,OAAO,cAAc,aAAa,OAAO,WAAW;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,kBAAkB,SAAuC;AAC9D,WAAO,CAAC,WAAmB,QAAQ,MAAM,CAAC,WAAW,OAAO,MAAM,CAAC;AAAA,EACrE;AACF;"}