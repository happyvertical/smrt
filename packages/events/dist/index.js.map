{"version":3,"file":"index.js","sources":["../src/models/EventType.ts","../src/models/EventSeries.ts","../src/models/Event.ts","../src/models/EventParticipant.ts","../src/collections/EventTypeCollection.ts","../src/collections/EventSeriesCollection.ts","../src/collections/EventCollection.ts","../src/collections/EventParticipantCollection.ts","../src/utils.ts"],"sourcesContent":["/**\n * EventType model - Defines types/categories of events\n *\n * Examples: 'basketball-game', 'concert', 'conference', 'goal', 'period'\n */\n\nimport { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';\nimport type { EventTypeOptions } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create'] },\n  cli: true,\n})\nexport class EventType extends SmrtObject {\n  // id, slug, name inherited from SmrtObject\n  description = ''; // Optional description\n  schema = ''; // JSON schema for event metadata (stored as text)\n  participantSchema = ''; // JSON schema for participant metadata (stored as text)\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: EventTypeOptions = {}) {\n    super(options);\n    if (options.description !== undefined)\n      this.description = options.description;\n\n    // Handle schema - can be object or JSON string\n    if (options.schema !== undefined) {\n      if (typeof options.schema === 'string') {\n        this.schema = options.schema;\n      } else {\n        this.schema = JSON.stringify(options.schema);\n      }\n    }\n\n    // Handle participant schema\n    if (options.participantSchema !== undefined) {\n      if (typeof options.participantSchema === 'string') {\n        this.participantSchema = options.participantSchema;\n      } else {\n        this.participantSchema = JSON.stringify(options.participantSchema);\n      }\n    }\n\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get schema as parsed object\n   *\n   * @returns Parsed schema object or empty object if no schema\n   */\n  getSchema(): Record<string, any> {\n    if (!this.schema) return {};\n    try {\n      return JSON.parse(this.schema);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set schema from object\n   *\n   * @param data - Schema object to store\n   */\n  setSchema(data: Record<string, any>): void {\n    this.schema = JSON.stringify(data);\n  }\n\n  /**\n   * Get participant schema as parsed object\n   *\n   * @returns Parsed participant schema object or empty object\n   */\n  getParticipantSchema(): Record<string, any> {\n    if (!this.participantSchema) return {};\n    try {\n      return JSON.parse(this.participantSchema);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set participant schema from object\n   *\n   * @param data - Participant schema object to store\n   */\n  setParticipantSchema(data: Record<string, any>): void {\n    this.participantSchema = JSON.stringify(data);\n  }\n\n  /**\n   * Convenience method for slug-based lookup\n   *\n   * @param slug - The slug to search for\n   * @returns EventType instance or null if not found\n   */\n  static async getBySlug(slug: string): Promise<EventType | null> {\n    // Will be auto-implemented by SMRT\n    return null;\n  }\n}\n","/**\n * EventSeries model - Groups related events (season, tour, conference, etc.)\n *\n * Examples: '2024 NBA Finals', 'Summer Tour 2024', 'Town Council 2024'\n */\n\nimport { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';\nimport type { EventSeriesOptions, RecurrencePattern } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class EventSeries extends SmrtObject {\n  // id, slug, name inherited from SmrtObject\n\n  typeId = ''; // FK to EventType\n  organizerId = ''; // FK to Profile (from @smrt/profiles)\n  description = '';\n  startDate: Date | null = null;\n  endDate: Date | null = null;\n  recurrence = ''; // JSON recurrence pattern (stored as text)\n  metadata = ''; // JSON metadata (stored as text)\n  externalId = ''; // External system identifier\n  source = ''; // Source system (e.g., 'ticketmaster', 'espn')\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: EventSeriesOptions = {}) {\n    super(options);\n\n    if (options.typeId) this.typeId = options.typeId;\n    if (options.organizerId) this.organizerId = options.organizerId;\n    if (options.description !== undefined)\n      this.description = options.description;\n    if (options.startDate !== undefined)\n      this.startDate = options.startDate || null;\n    if (options.endDate !== undefined) this.endDate = options.endDate || null;\n    if (options.externalId !== undefined) this.externalId = options.externalId;\n    if (options.source !== undefined) this.source = options.source;\n\n    // Handle recurrence - can be object or JSON string\n    if (options.recurrence !== undefined) {\n      if (typeof options.recurrence === 'string') {\n        this.recurrence = options.recurrence;\n      } else {\n        this.recurrence = JSON.stringify(options.recurrence);\n      }\n    }\n\n    // Handle metadata - can be object or JSON string\n    if (options.metadata !== undefined) {\n      if (typeof options.metadata === 'string') {\n        this.metadata = options.metadata;\n      } else {\n        this.metadata = JSON.stringify(options.metadata);\n      }\n    }\n\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get recurrence pattern as parsed object\n   *\n   * @returns Parsed recurrence pattern or null\n   */\n  getRecurrence(): RecurrencePattern | null {\n    if (!this.recurrence) return null;\n    try {\n      return JSON.parse(this.recurrence) as RecurrencePattern;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Set recurrence pattern from object\n   *\n   * @param pattern - Recurrence pattern to store\n   */\n  setRecurrence(pattern: RecurrencePattern): void {\n    this.recurrence = JSON.stringify(pattern);\n  }\n\n  /**\n   * Get metadata as parsed object\n   *\n   * @returns Parsed metadata object or empty object\n   */\n  getMetadata(): Record<string, any> {\n    if (!this.metadata) return {};\n    try {\n      return JSON.parse(this.metadata);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set metadata from object\n   *\n   * @param data - Metadata object to store\n   */\n  setMetadata(data: Record<string, any>): void {\n    this.metadata = JSON.stringify(data);\n  }\n\n  /**\n   * Update metadata by merging with existing values\n   *\n   * @param updates - Partial metadata to merge\n   */\n  updateMetadata(updates: Record<string, any>): void {\n    const current = this.getMetadata();\n    this.setMetadata({ ...current, ...updates });\n  }\n\n  /**\n   * Get the event type for this series\n   *\n   * @returns EventType instance or null\n   */\n  async getType() {\n    if (!this.typeId) return null;\n\n    const { EventTypeCollection } = await import(\n      '../collections/EventTypeCollection'\n    );\n    const collection = await EventTypeCollection.create(this.options);\n\n    return await collection.get({ id: this.typeId });\n  }\n\n  /**\n   * Get the organizer profile for this series\n   *\n   * @returns Profile instance or null\n   */\n  async getOrganizer() {\n    if (!this.organizerId) return null;\n\n    // Import Profile from @smrt/profiles\n    try {\n      const { ProfileCollection } = await import('@smrt/profiles');\n      const collection = await ProfileCollection.create(this.options);\n\n      return await collection.get({ id: this.organizerId });\n    } catch {\n      // @smrt/profiles not available\n      return null;\n    }\n  }\n\n  /**\n   * Get all events in this series\n   *\n   * @returns Array of Event instances\n   */\n  async getEvents() {\n    const { EventCollection } = await import('../collections/EventCollection');\n    const collection = await EventCollection.create(this.options);\n\n    return await collection.list({ where: { seriesId: this.id } });\n  }\n\n  /**\n   * Check if series is currently active\n   *\n   * @returns True if current date is between start and end\n   */\n  isActive(): boolean {\n    const now = new Date();\n    if (this.startDate && now < this.startDate) return false;\n    if (this.endDate && now > this.endDate) return false;\n    return true;\n  }\n}\n","/**\n * Event model - Hierarchical event instances\n *\n * Infinitely nestable: Game → Period → Goal → Assist\n */\n\nimport { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';\nimport type { EventOptions, EventStatus } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class Event extends SmrtObject {\n  // id, slug, name inherited from SmrtObject\n\n  seriesId = ''; // FK to EventSeries (nullable for standalone events)\n  parentEventId = ''; // FK to Event (nullable, self-referencing for hierarchy)\n  typeId = ''; // FK to EventType\n  placeId = ''; // FK to Place (from @smrt/places)\n  description = '';\n  startDate: Date | null = null;\n  endDate: Date | null = null;\n  status: EventStatus = 'scheduled';\n  round: number | null = null; // Sequence/round number in series\n  metadata = ''; // JSON metadata (stored as text)\n  externalId = ''; // External system identifier\n  source = ''; // Source system\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: EventOptions = {}) {\n    super(options);\n\n    if (options.seriesId !== undefined) this.seriesId = options.seriesId;\n    if (options.parentEventId !== undefined)\n      this.parentEventId = options.parentEventId;\n    if (options.typeId) this.typeId = options.typeId;\n    if (options.placeId !== undefined) this.placeId = options.placeId;\n    if (options.description !== undefined)\n      this.description = options.description;\n    if (options.startDate !== undefined)\n      this.startDate = options.startDate || null;\n    if (options.endDate !== undefined) this.endDate = options.endDate || null;\n    if (options.status !== undefined) this.status = options.status;\n    if (options.round !== undefined) this.round = options.round;\n    if (options.externalId !== undefined) this.externalId = options.externalId;\n    if (options.source !== undefined) this.source = options.source;\n\n    // Handle metadata - can be object or JSON string\n    if (options.metadata !== undefined) {\n      if (typeof options.metadata === 'string') {\n        this.metadata = options.metadata;\n      } else {\n        this.metadata = JSON.stringify(options.metadata);\n      }\n    }\n\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get metadata as parsed object\n   *\n   * @returns Parsed metadata object or empty object\n   */\n  getMetadata(): Record<string, any> {\n    if (!this.metadata) return {};\n    try {\n      return JSON.parse(this.metadata);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set metadata from object\n   *\n   * @param data - Metadata object to store\n   */\n  setMetadata(data: Record<string, any>): void {\n    this.metadata = JSON.stringify(data);\n  }\n\n  /**\n   * Update metadata by merging with existing values\n   *\n   * @param updates - Partial metadata to merge\n   */\n  updateMetadata(updates: Record<string, any>): void {\n    const current = this.getMetadata();\n    this.setMetadata({ ...current, ...updates });\n  }\n\n  /**\n   * Update event status\n   *\n   * @param newStatus - New status to set\n   */\n  async updateStatus(newStatus: EventStatus): Promise<void> {\n    this.status = newStatus;\n    this.updatedAt = new Date();\n    await this.save();\n  }\n\n  /**\n   * Get the series for this event\n   *\n   * @returns EventSeries instance or null\n   */\n  async getSeries() {\n    if (!this.seriesId) return null;\n\n    const { EventSeriesCollection } = await import(\n      '../collections/EventSeriesCollection'\n    );\n    const collection = await EventSeriesCollection.create(this.options);\n\n    return await collection.get({ id: this.seriesId });\n  }\n\n  /**\n   * Get the event type\n   *\n   * @returns EventType instance or null\n   */\n  async getType() {\n    if (!this.typeId) return null;\n\n    const { EventTypeCollection } = await import(\n      '../collections/EventTypeCollection'\n    );\n    const collection = await EventTypeCollection.create(this.options);\n\n    return await collection.get({ id: this.typeId });\n  }\n\n  /**\n   * Get the place for this event\n   *\n   * @returns Place instance or null\n   */\n  async getPlace() {\n    if (!this.placeId) return null;\n\n    try {\n      const { PlaceCollection } = await import('@smrt/places');\n      const collection = await PlaceCollection.create(this.options);\n\n      return await collection.get({ id: this.placeId });\n    } catch {\n      // @smrt/places not available\n      return null;\n    }\n  }\n\n  /**\n   * Get the parent event\n   *\n   * @returns Parent Event instance or null\n   */\n  async getParent(): Promise<Event | null> {\n    if (!this.parentEventId) return null;\n\n    const { EventCollection } = await import('../collections/EventCollection');\n    const collection = await EventCollection.create(this.options);\n\n    return await collection.get({ id: this.parentEventId });\n  }\n\n  /**\n   * Get immediate child events\n   *\n   * @returns Array of child Event instances\n   */\n  async getChildren(): Promise<Event[]> {\n    const { EventCollection } = await import('../collections/EventCollection');\n    const collection = await EventCollection.create(this.options);\n\n    return await collection.list({ where: { parentEventId: this.id } });\n  }\n\n  /**\n   * Get all ancestor events (recursive)\n   *\n   * @returns Array of ancestor events from root to immediate parent\n   */\n  async getAncestors(): Promise<Event[]> {\n    const ancestors: Event[] = [];\n    let currentEvent: Event | null = this;\n\n    while (currentEvent && currentEvent.parentEventId) {\n      const parent = await currentEvent.getParent();\n      if (!parent) break;\n      ancestors.unshift(parent); // Add to beginning\n      currentEvent = parent;\n    }\n\n    return ancestors;\n  }\n\n  /**\n   * Get all descendant events (recursive)\n   *\n   * @returns Array of all descendant events\n   */\n  async getDescendants(): Promise<Event[]> {\n    const children = await this.getChildren();\n    const descendants: Event[] = [...children];\n\n    for (const child of children) {\n      const childDescendants = await child.getDescendants();\n      descendants.push(...childDescendants);\n    }\n\n    return descendants;\n  }\n\n  /**\n   * Get root event (top-level event with no parent)\n   *\n   * @returns Root event instance\n   */\n  async getRootEvent(): Promise<Event> {\n    const ancestors = await this.getAncestors();\n    return ancestors.length > 0 ? ancestors[0] : this;\n  }\n\n  /**\n   * Get full hierarchy for this event\n   *\n   * @returns Object with ancestors, current, and descendants\n   */\n  async getHierarchy(): Promise<{\n    ancestors: Event[];\n    current: Event;\n    descendants: Event[];\n  }> {\n    const [ancestors, descendants] = await Promise.all([\n      this.getAncestors(),\n      this.getDescendants(),\n    ]);\n\n    return {\n      ancestors,\n      current: this,\n      descendants,\n    };\n  }\n\n  /**\n   * Get all participants for this event\n   *\n   * @returns Array of EventParticipant instances\n   */\n  async getParticipants() {\n    const { EventParticipantCollection } = await import(\n      '../collections/EventParticipantCollection'\n    );\n    const collection = await EventParticipantCollection.create(this.options);\n\n    return await collection.list({ where: { eventId: this.id } });\n  }\n\n  /**\n   * Check if event is currently in progress\n   *\n   * @returns True if current time is between start and end\n   */\n  isInProgress(): boolean {\n    if (this.status !== 'in_progress') return false;\n\n    const now = new Date();\n    if (this.startDate && now < this.startDate) return false;\n    if (this.endDate && now > this.endDate) return false;\n\n    return true;\n  }\n\n  /**\n   * Check if event is a root event (no parent)\n   *\n   * @returns True if parentEventId is empty\n   */\n  isRoot(): boolean {\n    return !this.parentEventId;\n  }\n}\n","/**\n * EventParticipant model - Links participants to events\n *\n * Tracks who participated in an event with role and placement\n */\n\nimport { SmrtObject, type SmrtObjectOptions, smrt } from '@smrt/core';\nimport type { EventParticipantOptions, ParticipantRole } from '../types';\n\n@smrt({\n  api: { include: ['list', 'get', 'create', 'update', 'delete'] },\n  mcp: { include: ['list', 'get', 'create', 'update'] },\n  cli: true,\n})\nexport class EventParticipant extends SmrtObject {\n  // id inherited from SmrtObject\n\n  eventId = ''; // FK to Event\n  profileId = ''; // FK to Profile (from @smrt/profiles)\n  role: string = ''; // Participant role (ParticipantRole or custom)\n  placement: number | null = null; // Numeric position/placement\n  groupId = ''; // Optional grouping (e.g., team ID for individual players)\n  metadata = ''; // JSON metadata (stored as text)\n  externalId = ''; // External system identifier\n  source = ''; // Source system\n\n  // Timestamps\n  createdAt = new Date();\n  updatedAt = new Date();\n\n  constructor(options: EventParticipantOptions = {}) {\n    super(options);\n\n    if (options.eventId) this.eventId = options.eventId;\n    if (options.profileId) this.profileId = options.profileId;\n    if (options.role !== undefined) this.role = options.role;\n    if (options.placement !== undefined) this.placement = options.placement;\n    if (options.groupId !== undefined) this.groupId = options.groupId;\n    if (options.externalId !== undefined) this.externalId = options.externalId;\n    if (options.source !== undefined) this.source = options.source;\n\n    // Handle metadata - can be object or JSON string\n    if (options.metadata !== undefined) {\n      if (typeof options.metadata === 'string') {\n        this.metadata = options.metadata;\n      } else {\n        this.metadata = JSON.stringify(options.metadata);\n      }\n    }\n\n    if (options.createdAt) this.createdAt = options.createdAt;\n    if (options.updatedAt) this.updatedAt = options.updatedAt;\n  }\n\n  /**\n   * Get metadata as parsed object\n   *\n   * @returns Parsed metadata object or empty object\n   */\n  getMetadata(): Record<string, any> {\n    if (!this.metadata) return {};\n    try {\n      return JSON.parse(this.metadata);\n    } catch {\n      return {};\n    }\n  }\n\n  /**\n   * Set metadata from object\n   *\n   * @param data - Metadata object to store\n   */\n  setMetadata(data: Record<string, any>): void {\n    this.metadata = JSON.stringify(data);\n  }\n\n  /**\n   * Update metadata by merging with existing values\n   *\n   * @param updates - Partial metadata to merge\n   */\n  updateMetadata(updates: Record<string, any>): void {\n    const current = this.getMetadata();\n    this.setMetadata({ ...current, ...updates });\n  }\n\n  /**\n   * Get the event for this participant\n   *\n   * @returns Event instance or null\n   */\n  async getEvent() {\n    if (!this.eventId) return null;\n\n    const { EventCollection } = await import('../collections/EventCollection');\n    const collection = await EventCollection.create(this.options);\n\n    return await collection.get({ id: this.eventId });\n  }\n\n  /**\n   * Get the profile for this participant\n   *\n   * @returns Profile instance or null\n   */\n  async getProfile() {\n    if (!this.profileId) return null;\n\n    try {\n      const { ProfileCollection } = await import('@smrt/profiles');\n      const collection = await ProfileCollection.create(this.options);\n\n      return await collection.get({ id: this.profileId });\n    } catch {\n      // @smrt/profiles not available\n      return null;\n    }\n  }\n\n  /**\n   * Get group participants (others with same groupId)\n   *\n   * @returns Array of EventParticipant instances\n   */\n  async getGroupParticipants(): Promise<EventParticipant[]> {\n    if (!this.groupId) return [];\n\n    const { EventParticipantCollection } = await import(\n      '../collections/EventParticipantCollection'\n    );\n    const collection = await EventParticipantCollection.create(this.options);\n\n    const participants = await collection.list({\n      where: { eventId: this.eventId, groupId: this.groupId },\n    });\n\n    // Exclude self from results\n    return participants.filter((p) => p.id !== this.id);\n  }\n\n  /**\n   * Check if this is a home participant (placement = 0)\n   *\n   * @returns True if placement is 0\n   */\n  isHome(): boolean {\n    return this.placement === 0;\n  }\n\n  /**\n   * Check if this is an away participant (placement = 1)\n   *\n   * @returns True if placement is 1\n   */\n  isAway(): boolean {\n    return this.placement === 1;\n  }\n}\n","/**\n * EventTypeCollection - Collection manager for EventType objects\n *\n * Provides lookup and creation for event types.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { EventType } from '../models/EventType';\n\nexport class EventTypeCollection extends SmrtCollection<EventType> {\n  static readonly _itemClass = EventType;\n\n  /**\n   * Get or create an event type by slug\n   *\n   * @param slug - EventType slug (e.g., 'basketball-game', 'concert')\n   * @param name - Optional display name (defaults to capitalized slug)\n   * @returns EventType instance\n   */\n  async getOrCreate(slug: string, name?: string): Promise<EventType> {\n    // First try to find existing type with this slug\n    const existing = await this.get({ slug });\n\n    if (existing) {\n      return existing;\n    }\n\n    // Create new type with auto-generated name if not provided\n    const displayName =\n      name || slug.replace(/-/g, ' ').replace(/\\b\\w/g, (l) => l.toUpperCase());\n\n    return await this.create({\n      slug,\n      name: displayName,\n    });\n  }\n\n  /**\n   * Get an event type by slug\n   *\n   * @param slug - EventType slug to search for\n   * @returns EventType instance or null if not found\n   */\n  async getBySlug(slug: string): Promise<EventType | null> {\n    return await this.get({ slug });\n  }\n\n  /**\n   * Initialize default event types\n   *\n   * Creates common event types if they don't exist:\n   * - Sports: game, period, goal, assist, penalty\n   * - Entertainment: concert, performance, song\n   * - Professional: conference, session, presentation, workshop\n   * - Community: meeting, agenda-item, motion, vote\n   *\n   * @returns Array of created/existing event types\n   */\n  async initializeDefaults(): Promise<EventType[]> {\n    const defaults = [\n      // Sports\n      { slug: 'game', name: 'Game' },\n      { slug: 'match', name: 'Match' },\n      { slug: 'period', name: 'Period' },\n      { slug: 'quarter', name: 'Quarter' },\n      { slug: 'inning', name: 'Inning' },\n      { slug: 'goal', name: 'Goal' },\n      { slug: 'assist', name: 'Assist' },\n      { slug: 'penalty', name: 'Penalty' },\n      { slug: 'substitution', name: 'Substitution' },\n\n      // Entertainment\n      { slug: 'concert', name: 'Concert' },\n      { slug: 'performance', name: 'Performance' },\n      { slug: 'set', name: 'Set' },\n      { slug: 'song', name: 'Song' },\n      { slug: 'theater', name: 'Theater' },\n      { slug: 'show', name: 'Show' },\n\n      // Professional\n      { slug: 'conference', name: 'Conference' },\n      { slug: 'session', name: 'Session' },\n      { slug: 'presentation', name: 'Presentation' },\n      { slug: 'workshop', name: 'Workshop' },\n      { slug: 'seminar', name: 'Seminar' },\n      { slug: 'keynote', name: 'Keynote' },\n      { slug: 'panel', name: 'Panel' },\n\n      // Community\n      { slug: 'meeting', name: 'Meeting' },\n      { slug: 'town-hall', name: 'Town Hall' },\n      { slug: 'agenda-item', name: 'Agenda Item' },\n      { slug: 'motion', name: 'Motion' },\n      { slug: 'amendment', name: 'Amendment' },\n      { slug: 'vote', name: 'Vote' },\n      { slug: 'discussion', name: 'Discussion' },\n\n      // General\n      { slug: 'event', name: 'Event' },\n      { slug: 'activity', name: 'Activity' },\n      { slug: 'action', name: 'Action' },\n    ];\n\n    const types: EventType[] = [];\n    for (const def of defaults) {\n      const type = await this.getOrCreate(def.slug, def.name);\n      types.push(type);\n    }\n\n    return types;\n  }\n}\n","/**\n * EventSeriesCollection - Collection manager for EventSeries objects\n *\n * Provides queries for series by organizer, status, and date ranges.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { EventSeries } from '../models/EventSeries';\nimport type { EventSeriesSearchFilters } from '../types';\n\nexport class EventSeriesCollection extends SmrtCollection<EventSeries> {\n  static readonly _itemClass = EventSeries;\n\n  /**\n   * Get series by organizer\n   *\n   * @param organizerId - Profile ID of the organizer\n   * @returns Array of EventSeries instances\n   */\n  async getByOrganizer(organizerId: string): Promise<EventSeries[]> {\n    return await this.list({ where: { organizerId } });\n  }\n\n  /**\n   * Get currently active series\n   *\n   * @returns Array of EventSeries instances active today\n   */\n  async getActive(): Promise<EventSeries[]> {\n    const allSeries = await this.list({});\n    const now = new Date();\n\n    return allSeries.filter((series) => {\n      if (series.startDate && now < series.startDate) return false;\n      if (series.endDate && now > series.endDate) return false;\n      return true;\n    });\n  }\n\n  /**\n   * Get upcoming series\n   *\n   * @param limit - Maximum number of series to return\n   * @returns Array of EventSeries instances starting in the future\n   */\n  async getUpcoming(limit?: number): Promise<EventSeries[]> {\n    const allSeries = await this.list({});\n    const now = new Date();\n\n    const upcoming = allSeries\n      .filter((series) => series.startDate && series.startDate > now)\n      .sort((a, b) => {\n        if (!a.startDate || !b.startDate) return 0;\n        return a.startDate.getTime() - b.startDate.getTime();\n      });\n\n    return limit ? upcoming.slice(0, limit) : upcoming;\n  }\n\n  /**\n   * Get series by type\n   *\n   * @param typeId - EventType ID\n   * @returns Array of EventSeries instances\n   */\n  async getByType(typeId: string): Promise<EventSeries[]> {\n    return await this.list({ where: { typeId } });\n  }\n\n  /**\n   * Search series with filters\n   *\n   * @param query - Search query for name/description\n   * @param filters - Additional filter criteria\n   * @returns Array of matching EventSeries instances\n   */\n  async search(\n    query: string,\n    filters?: EventSeriesSearchFilters,\n  ): Promise<EventSeries[]> {\n    let series = await this.list({});\n\n    // Filter by query\n    if (query) {\n      const lowerQuery = query.toLowerCase();\n      series = series.filter(\n        (s) =>\n          s.name?.toLowerCase().includes(lowerQuery) ||\n          s.description?.toLowerCase().includes(lowerQuery),\n      );\n    }\n\n    // Apply filters\n    if (filters) {\n      if (filters.typeId) {\n        series = series.filter((s) => s.typeId === filters.typeId);\n      }\n      if (filters.organizerId) {\n        series = series.filter((s) => s.organizerId === filters.organizerId);\n      }\n      if (filters.startDate) {\n        series = series.filter(\n          (s) => s.startDate && s.startDate >= filters.startDate!,\n        );\n      }\n      if (filters.endDate) {\n        series = series.filter(\n          (s) => s.endDate && s.endDate <= filters.endDate!,\n        );\n      }\n    }\n\n    return series;\n  }\n}\n","/**\n * EventCollection - Collection manager for Event objects\n *\n * Provides hierarchy traversal, filtering, and search capabilities.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { Event } from '../models/Event';\nimport type { EventSearchFilters, EventStatus } from '../types';\n\nexport class EventCollection extends SmrtCollection<Event> {\n  static readonly _itemClass = Event;\n\n  /**\n   * Get events by series\n   *\n   * @param seriesId - EventSeries ID\n   * @returns Array of Event instances\n   */\n  async getBySeriesId(seriesId: string): Promise<Event[]> {\n    return await this.list({ where: { seriesId } });\n  }\n\n  /**\n   * Get events at a specific place\n   *\n   * @param placeId - Place ID\n   * @returns Array of Event instances\n   */\n  async getByPlace(placeId: string): Promise<Event[]> {\n    return await this.list({ where: { placeId } });\n  }\n\n  /**\n   * Get events by date range\n   *\n   * @param startDate - Start of date range\n   * @param endDate - End of date range\n   * @returns Array of Event instances\n   */\n  async getByDateRange(startDate: Date, endDate: Date): Promise<Event[]> {\n    const allEvents = await this.list({});\n\n    return allEvents.filter((event) => {\n      if (!event.startDate) return false;\n      return event.startDate >= startDate && event.startDate <= endDate;\n    });\n  }\n\n  /**\n   * Get upcoming events\n   *\n   * @param limit - Maximum number of events to return\n   * @returns Array of Event instances starting in the future\n   */\n  async getUpcoming(limit?: number): Promise<Event[]> {\n    const allEvents = await this.list({});\n    const now = new Date();\n\n    const upcoming = allEvents\n      .filter((event) => event.startDate && event.startDate > now)\n      .sort((a, b) => {\n        if (!a.startDate || !b.startDate) return 0;\n        return a.startDate.getTime() - b.startDate.getTime();\n      });\n\n    return limit ? upcoming.slice(0, limit) : upcoming;\n  }\n\n  /**\n   * Get events by status\n   *\n   * @param status - Event status to filter by\n   * @returns Array of Event instances\n   */\n  async getByStatus(status: EventStatus): Promise<Event[]> {\n    return await this.list({ where: { status } });\n  }\n\n  /**\n   * Get events by type\n   *\n   * @param typeId - EventType ID\n   * @returns Array of Event instances\n   */\n  async getByType(typeId: string): Promise<Event[]> {\n    return await this.list({ where: { typeId } });\n  }\n\n  /**\n   * Get root events (no parent)\n   *\n   * @returns Array of Event instances with no parent\n   */\n  async getRootEvents(): Promise<Event[]> {\n    const allEvents = await this.list({});\n    return allEvents.filter((event) => !event.parentEventId);\n  }\n\n  /**\n   * Get children of a parent event\n   *\n   * @param parentEventId - Parent event ID\n   * @returns Array of child Event instances\n   */\n  async getByParent(parentEventId: string): Promise<Event[]> {\n    return await this.list({ where: { parentEventId } });\n  }\n\n  /**\n   * Get full event tree (hierarchy)\n   *\n   * @param eventId - Root event ID\n   * @returns Object with root event and nested children\n   */\n  async getEventTree(eventId: string): Promise<Event | null> {\n    const event = await this.get({ id: eventId });\n    if (!event) return null;\n\n    return await event.getHierarchy().then((h) => h.current);\n  }\n\n  /**\n   * Search events with filters\n   *\n   * @param query - Search query for name/description\n   * @param filters - Additional filter criteria\n   * @returns Array of matching Event instances\n   */\n  async search(query: string, filters?: EventSearchFilters): Promise<Event[]> {\n    let events = await this.list({});\n\n    // Filter by query\n    if (query) {\n      const lowerQuery = query.toLowerCase();\n      events = events.filter(\n        (e) =>\n          e.name?.toLowerCase().includes(lowerQuery) ||\n          e.description?.toLowerCase().includes(lowerQuery),\n      );\n    }\n\n    // Apply filters\n    if (filters) {\n      if (filters.typeId) {\n        events = events.filter((e) => e.typeId === filters.typeId);\n      }\n      if (filters.seriesId) {\n        events = events.filter((e) => e.seriesId === filters.seriesId);\n      }\n      if (filters.placeId) {\n        events = events.filter((e) => e.placeId === filters.placeId);\n      }\n      if (filters.status) {\n        if (Array.isArray(filters.status)) {\n          events = events.filter((e) => filters.status!.includes(e.status));\n        } else {\n          events = events.filter((e) => e.status === filters.status);\n        }\n      }\n      if (filters.startDate) {\n        events = events.filter(\n          (e) => e.startDate && e.startDate >= filters.startDate!,\n        );\n      }\n      if (filters.endDate) {\n        events = events.filter(\n          (e) => e.startDate && e.startDate <= filters.endDate!,\n        );\n      }\n      if (filters.organizerId) {\n        // Filter by series organizer\n        events = events.filter(async (e) => {\n          const series = await e.getSeries();\n          return series && series.organizerId === filters.organizerId;\n        });\n      }\n    }\n\n    return events;\n  }\n\n  /**\n   * Get events in progress\n   *\n   * @returns Array of Event instances currently in progress\n   */\n  async getInProgress(): Promise<Event[]> {\n    const inProgressEvents = await this.getByStatus('in_progress');\n    return inProgressEvents.filter((event) => event.isInProgress());\n  }\n}\n","/**\n * EventParticipantCollection - Collection manager for EventParticipant objects\n *\n * Provides queries for participants by event, profile, role, and placement.\n */\n\nimport { SmrtCollection } from '@smrt/core';\nimport { EventParticipant } from '../models/EventParticipant';\nimport type { ParticipantRole, ParticipantSearchFilters } from '../types';\n\nexport class EventParticipantCollection extends SmrtCollection<EventParticipant> {\n  static readonly _itemClass = EventParticipant;\n\n  /**\n   * Get participants for an event\n   *\n   * @param eventId - Event ID\n   * @returns Array of EventParticipant instances\n   */\n  async getByEvent(eventId: string): Promise<EventParticipant[]> {\n    return await this.list({ where: { eventId } });\n  }\n\n  /**\n   * Get events for a participant (profile)\n   *\n   * @param profileId - Profile ID\n   * @returns Array of EventParticipant instances\n   */\n  async getByProfile(profileId: string): Promise<EventParticipant[]> {\n    return await this.list({ where: { profileId } });\n  }\n\n  /**\n   * Get participants by role for an event\n   *\n   * @param eventId - Event ID\n   * @param role - Participant role\n   * @returns Array of EventParticipant instances\n   */\n  async getByRole(\n    eventId: string,\n    role: ParticipantRole | string,\n  ): Promise<EventParticipant[]> {\n    const participants = await this.getByEvent(eventId);\n    return participants.filter((p) => p.role === role);\n  }\n\n  /**\n   * Get participants ordered by placement\n   *\n   * @param eventId - Event ID\n   * @returns Array of EventParticipant instances sorted by placement\n   */\n  async getByPlacement(eventId: string): Promise<EventParticipant[]> {\n    const participants = await this.getByEvent(eventId);\n\n    return participants.sort((a, b) => {\n      if (a.placement === null && b.placement === null) return 0;\n      if (a.placement === null) return 1;\n      if (b.placement === null) return -1;\n      return a.placement - b.placement;\n    });\n  }\n\n  /**\n   * Get participants by group\n   *\n   * @param eventId - Event ID\n   * @param groupId - Group ID\n   * @returns Array of EventParticipant instances\n   */\n  async getByGroup(\n    eventId: string,\n    groupId: string,\n  ): Promise<EventParticipant[]> {\n    const participants = await this.getByEvent(eventId);\n    return participants.filter((p) => p.groupId === groupId);\n  }\n\n  /**\n   * Get home participant(s) (placement = 0)\n   *\n   * @param eventId - Event ID\n   * @returns Array of EventParticipant instances with placement 0\n   */\n  async getHome(eventId: string): Promise<EventParticipant[]> {\n    const participants = await this.getByEvent(eventId);\n    return participants.filter((p) => p.placement === 0);\n  }\n\n  /**\n   * Get away participant(s) (placement = 1)\n   *\n   * @param eventId - Event ID\n   * @returns Array of EventParticipant instances with placement 1\n   */\n  async getAway(eventId: string): Promise<EventParticipant[]> {\n    const participants = await this.getByEvent(eventId);\n    return participants.filter((p) => p.placement === 1);\n  }\n\n  /**\n   * Search participants with filters\n   *\n   * @param filters - Filter criteria\n   * @returns Array of matching EventParticipant instances\n   */\n  async search(filters: ParticipantSearchFilters): Promise<EventParticipant[]> {\n    let participants = await this.list({});\n\n    if (filters.eventId) {\n      participants = participants.filter((p) => p.eventId === filters.eventId);\n    }\n    if (filters.profileId) {\n      participants = participants.filter(\n        (p) => p.profileId === filters.profileId,\n      );\n    }\n    if (filters.role) {\n      participants = participants.filter((p) => p.role === filters.role);\n    }\n    if (filters.groupId) {\n      participants = participants.filter((p) => p.groupId === filters.groupId);\n    }\n\n    return participants;\n  }\n\n  /**\n   * Get participant statistics for a profile\n   *\n   * @param profileId - Profile ID\n   * @param eventTypeId - Optional event type filter\n   * @returns Statistics object\n   */\n  async getParticipantStats(\n    profileId: string,\n    eventTypeId?: string,\n  ): Promise<{\n    totalEvents: number;\n    byRole: Record<string, number>;\n    byPlacement: Record<number, number>;\n  }> {\n    const participants = await this.getByProfile(profileId);\n\n    // Filter by event type if provided\n    let filteredParticipants = participants;\n    if (eventTypeId) {\n      filteredParticipants = [];\n      for (const participant of participants) {\n        const event = await participant.getEvent();\n        if (event && event.typeId === eventTypeId) {\n          filteredParticipants.push(participant);\n        }\n      }\n    }\n\n    // Calculate statistics\n    const byRole: Record<string, number> = {};\n    const byPlacement: Record<number, number> = {};\n\n    for (const participant of filteredParticipants) {\n      // Count by role\n      byRole[participant.role] = (byRole[participant.role] || 0) + 1;\n\n      // Count by placement\n      if (participant.placement !== null) {\n        byPlacement[participant.placement] =\n          (byPlacement[participant.placement] || 0) + 1;\n      }\n    }\n\n    return {\n      totalEvents: filteredParticipants.length,\n      byRole,\n      byPlacement,\n    };\n  }\n}\n","/**\n * Utility functions for @have/events package\n */\n\nimport type { EventStatus, RecurrencePattern } from './types';\n\n/**\n * Validate event status transition\n *\n * @param currentStatus - Current event status\n * @param newStatus - Proposed new status\n * @returns True if transition is valid\n */\nexport function validateEventStatus(\n  currentStatus: EventStatus,\n  newStatus: EventStatus,\n): boolean {\n  // Define valid transitions\n  const validTransitions: Record<EventStatus, EventStatus[]> = {\n    scheduled: ['in_progress', 'cancelled', 'postponed'],\n    in_progress: ['completed', 'cancelled'],\n    completed: [], // Cannot transition from completed\n    cancelled: ['scheduled'], // Can reschedule\n    postponed: ['scheduled', 'cancelled'],\n  };\n\n  return validTransitions[currentStatus]?.includes(newStatus) || false;\n}\n\n/**\n * Format event date range as string\n *\n * @param startDate - Event start date\n * @param endDate - Event end date (optional)\n * @returns Formatted date range string\n */\nexport function formatEventDateRange(\n  startDate: Date,\n  endDate?: Date | null,\n): string {\n  const start = startDate.toLocaleDateString();\n\n  if (!endDate) {\n    return start;\n  }\n\n  // Same day\n  if (startDate.toDateString() === endDate.toDateString()) {\n    return `${start} ${startDate.toLocaleTimeString()} - ${endDate.toLocaleTimeString()}`;\n  }\n\n  // Multi-day\n  return `${start} - ${endDate.toLocaleDateString()}`;\n}\n\n/**\n * Generate unique slug for an event\n *\n * @param name - Event name\n * @param date - Event date\n * @returns URL-friendly slug\n */\nexport function generateEventSlug(name: string, date: Date): string {\n  const namePart = name\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-|-$/g, '');\n\n  const datePart = date.toISOString().split('T')[0]; // YYYY-MM-DD\n\n  return `${namePart}-${datePart}`;\n}\n\n/**\n * Check if events have scheduling conflict\n *\n * @param event1Start - First event start\n * @param event1End - First event end\n * @param event2Start - Second event start\n * @param event2End - Second event end\n * @returns True if events overlap\n */\nexport function checkSchedulingConflict(\n  event1Start: Date,\n  event1End: Date | null,\n  event2Start: Date,\n  event2End: Date | null,\n): boolean {\n  // If either event has no end date, assume it's instantaneous\n  const e1End = event1End || event1Start;\n  const e2End = event2End || event2Start;\n\n  // Check for overlap\n  return event1Start < e2End && e1End > event2Start;\n}\n\n/**\n * Parse recurrence pattern from various formats\n *\n * @param pattern - Recurrence pattern (object or string)\n * @returns Parsed RecurrencePattern or null\n */\nexport function parseRecurrencePattern(\n  pattern: RecurrencePattern | string | null,\n): RecurrencePattern | null {\n  if (!pattern) return null;\n\n  if (typeof pattern === 'string') {\n    try {\n      return JSON.parse(pattern) as RecurrencePattern;\n    } catch {\n      return null;\n    }\n  }\n\n  return pattern;\n}\n\n/**\n * Calculate next occurrence for a recurring event\n *\n * @param pattern - Recurrence pattern\n * @param fromDate - Date to calculate from\n * @returns Next occurrence date or null\n */\nexport function calculateNextOccurrence(\n  pattern: RecurrencePattern,\n  fromDate: Date,\n): Date | null {\n  const { frequency, interval = 1, until, count } = pattern;\n\n  // Check if recurrence has ended\n  if (until && fromDate >= until) return null;\n\n  // Calculate next date based on frequency\n  const nextDate = new Date(fromDate);\n\n  switch (frequency) {\n    case 'daily':\n      nextDate.setDate(nextDate.getDate() + interval);\n      break;\n    case 'weekly':\n      nextDate.setDate(nextDate.getDate() + interval * 7);\n      break;\n    case 'monthly':\n      nextDate.setMonth(nextDate.getMonth() + interval);\n      break;\n    case 'yearly':\n      nextDate.setFullYear(nextDate.getFullYear() + interval);\n      break;\n    default:\n      return null;\n  }\n\n  // Check if we've exceeded until date\n  if (until && nextDate > until) return null;\n\n  return nextDate;\n}\n\n/**\n * Calculate duration between two dates\n *\n * @param startDate - Start date\n * @param endDate - End date\n * @returns Duration in milliseconds\n */\nexport function calculateDuration(startDate: Date, endDate: Date): number {\n  return endDate.getTime() - startDate.getTime();\n}\n\n/**\n * Format duration as human-readable string\n *\n * @param durationMs - Duration in milliseconds\n * @returns Formatted duration string\n */\nexport function formatDuration(durationMs: number): string {\n  const seconds = Math.floor(durationMs / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n  const days = Math.floor(hours / 24);\n\n  if (days > 0) {\n    return `${days}d ${hours % 24}h`;\n  }\n  if (hours > 0) {\n    return `${hours}h ${minutes % 60}m`;\n  }\n  if (minutes > 0) {\n    return `${minutes}m ${seconds % 60}s`;\n  }\n  return `${seconds}s`;\n}\n\n/**\n * Check if an event is happening now\n *\n * @param startDate - Event start date\n * @param endDate - Event end date (optional)\n * @returns True if event is currently in progress\n */\nexport function isEventNow(startDate: Date, endDate?: Date | null): boolean {\n  const now = new Date();\n\n  if (now < startDate) return false;\n  if (endDate && now > endDate) return false;\n\n  return true;\n}\n\n/**\n * Get event status based on dates\n *\n * @param startDate - Event start date\n * @param endDate - Event end date (optional)\n * @param currentStatus - Current status (optional)\n * @returns Suggested event status\n */\nexport function getEventStatusFromDates(\n  startDate: Date,\n  endDate?: Date | null,\n  currentStatus?: EventStatus,\n): EventStatus {\n  // Don't override cancelled or postponed status\n  if (currentStatus === 'cancelled' || currentStatus === 'postponed') {\n    return currentStatus;\n  }\n\n  const now = new Date();\n\n  if (now < startDate) {\n    return 'scheduled';\n  }\n\n  if (endDate && now > endDate) {\n    return 'completed';\n  }\n\n  return 'in_progress';\n}\n\n/**\n * Sort events by start date\n *\n * @param events - Array of objects with startDate property\n * @param ascending - Sort ascending (default: true)\n * @returns Sorted array\n */\nexport function sortEventsByDate<T extends { startDate: Date | null }>(\n  events: T[],\n  ascending: boolean = true,\n): T[] {\n  return events.sort((a, b) => {\n    if (!a.startDate && !b.startDate) return 0;\n    if (!a.startDate) return 1;\n    if (!b.startDate) return -1;\n\n    const diff = a.startDate.getTime() - b.startDate.getTime();\n    return ascending ? diff : -diff;\n  });\n}\n"],"names":["EventTypeCollection","EventCollection","_init","EventSeriesCollection","EventParticipantCollection"],"mappings":"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"}