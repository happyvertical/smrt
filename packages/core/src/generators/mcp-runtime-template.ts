/**
 * Runtime bootstrap template for generated MCP servers
 *
 * This template provides stdio transport integration for SMRT-generated MCP servers.
 * It handles:
 * - Server initialization with @modelcontextprotocol/sdk
 * - Tool registration from MCPGenerator
 * - Stdio transport connection
 * - Error handling and logging
 * - Graceful shutdown
 */

import type { MCPConfig, MCPContext } from './mcp.js';

export interface RuntimeOptions {
  /** Server name (defaults to package name) */
  name?: string;

  /** Server version (defaults to package version) */
  version?: string;

  /** Server description */
  description?: string;

  /** MCP generator configuration */
  config?: MCPConfig;

  /** MCP context (database, AI client, etc.) */
  context?: MCPContext;

  /** Enable debug logging */
  debug?: boolean;
}

/**
 * Generate runtime bootstrap code for MCP server
 *
 * @param options - Runtime configuration options
 * @returns TypeScript code for server entry point
 */
export function generateRuntimeBootstrap(options: RuntimeOptions = {}): string {
  const {
    name = 'smrt-mcp-server',
    version = '1.0.0',
    description = 'Auto-generated MCP server from SMRT objects',
    debug = false,
  } = options;

  return `#!/usr/bin/env node
/**
 * Auto-generated MCP Server
 * Generated by @smrt/core MCPGenerator
 *
 * This server exposes SMRT objects as MCP tools for AI integration.
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  type CallToolRequest,
  type ListToolsRequest,
} from '@modelcontextprotocol/sdk/types.js';
import { MCPGenerator } from '@smrt/core/generators/mcp';
import { getDatabase } from '@have/sql';
import { getAI } from '@have/ai';

// Server configuration
const SERVER_NAME = ${JSON.stringify(name)};
const SERVER_VERSION = ${JSON.stringify(version)};
const SERVER_DESCRIPTION = ${JSON.stringify(description)};
const DEBUG = ${debug};

/**
 * Initialize MCP generator with context
 */
async function initializeGenerator() {
  // Setup database connection (optional)
  const db = process.env.DATABASE_URL
    ? await getDatabase({ url: process.env.DATABASE_URL })
    : undefined;

  // Setup AI client (optional)
  const ai = process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY
    ? await getAI({
        provider: process.env.OPENAI_API_KEY ? 'openai' : 'anthropic',
        apiKey: process.env.OPENAI_API_KEY || process.env.ANTHROPIC_API_KEY,
      })
    : undefined;

  // Create generator with context
  const generator = new MCPGenerator(
    {
      name: SERVER_NAME,
      version: SERVER_VERSION,
      description: SERVER_DESCRIPTION,
    },
    {
      db,
      ai,
    }
  );

  return generator;
}

/**
 * Main server startup function
 */
async function main() {
  try {
    if (DEBUG) {
      console.error(\`[MCP] Starting server: \${SERVER_NAME} v\${SERVER_VERSION}\`);
    }

    // Initialize generator
    const generator = await initializeGenerator();

    // Generate tools from registered SMRT objects
    const tools = generator.generateTools();

    if (DEBUG) {
      console.error(\`[MCP] Generated \${tools.length} tools from SMRT objects\`);
      console.error(\`[MCP] Available tools:\`, tools.map(t => t.name).join(', '));
    }

    // Create MCP server
    const server = new Server(
      {
        name: SERVER_NAME,
        version: SERVER_VERSION,
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    // Register ListTools handler
    server.setRequestHandler(ListToolsRequestSchema, async (_request: ListToolsRequest) => {
      if (DEBUG) {
        console.error(\`[MCP] ListTools request received\`);
      }

      return {
        tools: tools.map(tool => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema,
        })),
      };
    });

    // Register CallTool handler
    server.setRequestHandler(CallToolRequestSchema, async (request: CallToolRequest) => {
      const { name: toolName, arguments: args } = request.params;

      if (DEBUG) {
        console.error(\`[MCP] CallTool request: \${toolName}\`);
        console.error(\`[MCP] Arguments:\`, JSON.stringify(args, null, 2));
      }

      try {
        // Execute tool via generator
        const result = await generator.handleToolCall({
          method: 'tools/call',
          params: {
            name: toolName,
            arguments: args || {},
          },
        });

        if (DEBUG) {
          console.error(\`[MCP] Tool executed successfully: \${toolName}\`);
        }

        return result;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        console.error(\`[MCP] Tool execution failed: \${toolName}\`, error);

        return {
          content: [
            {
              type: 'text',
              text: \`Error executing tool \${toolName}: \${errorMessage}\`,
            },
          ],
          isError: true,
        };
      }
    });

    // Setup stdio transport
    const transport = new StdioServerTransport();

    // Connect server to transport
    await server.connect(transport);

    if (DEBUG) {
      console.error(\`[MCP] Server connected via stdio transport\`);
      console.error(\`[MCP] Ready to receive requests\`);
    }

    // Handle graceful shutdown
    process.on('SIGINT', async () => {
      if (DEBUG) {
        console.error(\`[MCP] Received SIGINT, shutting down gracefully\`);
      }
      await server.close();
      process.exit(0);
    });

    process.on('SIGTERM', async () => {
      if (DEBUG) {
        console.error(\`[MCP] Received SIGTERM, shutting down gracefully\`);
      }
      await server.close();
      process.exit(0);
    });
  } catch (error) {
    console.error('[MCP] Fatal error during server startup:', error);
    process.exit(1);
  }
}

// Start the server
main().catch((error) => {
  console.error('[MCP] Unhandled error:', error);
  process.exit(1);
});
`;
}

/**
 * Generate package.json script for running MCP server
 *
 * @param serverPath - Path to generated server file (relative to package root)
 * @returns Script command for package.json
 */
export function generateMCPScript(
  serverPath: string = 'dist/mcp-server.js',
): string {
  return `node ${serverPath}`;
}

/**
 * Generate Claude Desktop configuration example
 *
 * @param serverName - Name for the MCP server
 * @param serverPath - Absolute path to server file
 * @returns Configuration object for claude_desktop_config.json
 */
export function generateClaudeConfig(
  serverName: string,
  serverPath: string,
): object {
  return {
    mcpServers: {
      [serverName]: {
        command: 'node',
        args: [serverPath],
      },
    },
  };
}

/**
 * Generate README documentation for MCP server setup
 *
 * @param serverName - Name of the MCP server
 * @param serverPath - Path to the server file
 * @returns Markdown documentation
 */
export function generateMCPDocumentation(
  serverName: string,
  serverPath: string,
): string {
  return `# MCP Server Setup

This project includes an auto-generated MCP (Model Context Protocol) server that exposes SMRT objects as tools for AI integration.

## Quick Start

### 1. Build the MCP Server

\`\`\`bash
npm run build
\`\`\`

This generates the MCP server at: \`${serverPath}\`

### 2. Configure Claude Desktop

Add the following to your Claude Desktop configuration file:

**macOS**: \`~/.config/Claude/claude_desktop_config.json\`
**Windows**: \`%APPDATA%\\Claude\\claude_desktop_config.json\`

\`\`\`json
{
  "mcpServers": {
    "${serverName}": {
      "command": "node",
      "args": ["/absolute/path/to/${serverPath}"]
    }
  }
}
\`\`\`

Replace \`/absolute/path/to/\` with the actual absolute path to your project directory.

### 3. Restart Claude Desktop

Close and reopen Claude Desktop to load the new MCP server.

### 4. Test the Integration

In Claude Code, you can now use the auto-generated tools. For example:

- \`list_products\` - List all products
- \`get_product\` - Get a specific product by ID
- \`create_product\` - Create a new product
- And more...

## Environment Variables

The MCP server supports optional environment variables:

- \`DATABASE_URL\` - Database connection string
- \`OPENAI_API_KEY\` or \`ANTHROPIC_API_KEY\` - AI provider API key

## Troubleshooting

### Server Not Appearing in Claude

1. Check that the path in \`claude_desktop_config.json\` is absolute
2. Verify the server file exists at the specified path
3. Check Claude Desktop logs for errors

### Tools Not Working

1. Ensure your database is accessible (if using one)
2. Check that SMRT objects are properly decorated with \`@smrt()\`
3. Look for errors in the MCP server output

### Debug Mode

To enable debug logging, set the \`DEBUG\` constant to \`true\` in the generated server file.

## Generated Tools

The following tools are automatically generated from your SMRT objects:

- **CRUD Operations**: \`list_\`, \`get_\`, \`create_\`, \`update_\`, \`delete_\` for each object type
- **Custom Actions**: Any custom methods included in the \`@smrt()\` decorator configuration

See the SMRT object definitions for the complete list of available tools and their parameters.
`;
}
