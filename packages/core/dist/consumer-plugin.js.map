{"version":3,"file":"consumer-plugin.js","sources":["../src/consumer-plugin/index.ts"],"sourcesContent":["/**\n * Vite plugin for consuming SMRT packages\n * Solves virtual module resolution in downstream projects\n */\n\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport type { Plugin } from 'vite';\nimport { generateDeclarations } from '../prebuild/index.js';\n\nexport interface SmrtConsumerOptions {\n  /** SMRT packages to scan (e.g., ['@my-org/products', '@my-org/content']) */\n  packages?: string[];\n  /** Generate TypeScript declarations */\n  generateTypes?: boolean;\n  /** Output directory for generated types */\n  typesDir?: string;\n  /** Project root path */\n  projectRoot?: string;\n  /** SvelteKit integration mode */\n  svelteKit?: boolean;\n  /** Use static types only (for federation builds) */\n  staticTypes?: boolean;\n  /** Disable file scanning */\n  disableScanning?: boolean;\n}\n\nconst VIRTUAL_MODULES = {\n  '@smrt/routes': 'smrt:routes',\n  '@smrt/client': 'smrt:client',\n  '@smrt/mcp': 'smrt:mcp',\n  '@smrt/types': 'smrt:types',\n  '@smrt/manifest': 'smrt:manifest',\n};\n\n/**\n * Consumer plugin for projects that use SMRT packages\n */\nexport function smrtConsumer(options: SmrtConsumerOptions = {}): Plugin {\n  const {\n    packages = [],\n    generateTypes = true,\n    typesDir = 'src/types/smrt-generated',\n    projectRoot = process.cwd(),\n    disableScanning = false,\n  } = options;\n\n  let smrtPackages: string[] = [];\n  let typeManifest: any = null;\n  let typesGenerated = false;\n\n  return {\n    name: 'smrt-consumer',\n\n    async buildStart() {\n      console.log('[smrt:consumer] Initializing SMRT consumer plugin');\n\n      // Discover SMRT packages if not explicitly specified\n      if (packages.length === 0 && !disableScanning) {\n        smrtPackages = await discoverSmrtPackages(projectRoot);\n      } else {\n        smrtPackages = packages;\n      }\n\n      if (smrtPackages.length > 0) {\n        console.log(\n          `[smrt:consumer] Found SMRT packages: ${smrtPackages.join(', ')}`,\n        );\n\n        // Aggregate type manifests from discovered packages\n        typeManifest = await aggregateTypeManifests(smrtPackages, projectRoot);\n\n        // Generate types if requested\n        if (generateTypes && !typesGenerated) {\n          await generateProjectTypes(typeManifest, typesDir, projectRoot);\n          typesGenerated = true;\n        }\n      } else {\n        console.log('[smrt:consumer] No SMRT packages found');\n        typeManifest = { version: '1.0.0', timestamp: Date.now(), objects: {} };\n      }\n    },\n\n    resolveId(id, _importer) {\n      // Resolve virtual modules to generated type declarations\n      if (id in VIRTUAL_MODULES) {\n        const typeFileName = getTypeFileName(id);\n        const typePath = path.join(projectRoot, typesDir, typeFileName);\n\n        // If types file exists, resolve to it\n        if (fs.existsSync(typePath)) {\n          return typePath;\n        }\n\n        // Otherwise use virtual module ID for runtime resolution\n        return `\\0${VIRTUAL_MODULES[id as keyof typeof VIRTUAL_MODULES]}`;\n      }\n      return null;\n    },\n\n    async load(id) {\n      // Handle virtual modules if types aren't available\n      const cleanId = id.startsWith('\\0') ? id.slice(1) : id;\n\n      if (!typeManifest) {\n        typeManifest = { version: '1.0.0', timestamp: Date.now(), objects: {} };\n      }\n\n      switch (cleanId) {\n        case 'smrt:routes':\n          return generateFallbackRoutesModule();\n\n        case 'smrt:client':\n          return generateFallbackClientModule(typeManifest);\n\n        case 'smrt:mcp':\n          return generateFallbackMcpModule();\n\n        case 'smrt:types':\n          return generateFallbackTypesModule(typeManifest);\n\n        case 'smrt:manifest':\n          return generateFallbackManifestModule(typeManifest);\n\n        default:\n          return null;\n      }\n    },\n  };\n}\n\n/**\n * Discover SMRT packages in node_modules\n */\nasync function discoverSmrtPackages(projectRoot: string): Promise<string[]> {\n  const packages: string[] = [];\n  const nodeModulesPath = path.join(projectRoot, 'node_modules');\n\n  if (!fs.existsSync(nodeModulesPath)) {\n    return packages;\n  }\n\n  try {\n    // Check package.json for workspace dependencies\n    const packageJsonPath = path.join(projectRoot, 'package.json');\n    if (fs.existsSync(packageJsonPath)) {\n      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));\n      const allDeps = {\n        ...packageJson.dependencies,\n        ...packageJson.devDependencies,\n        ...packageJson.peerDependencies,\n      };\n\n      // Look for packages that likely contain SMRT objects\n      for (const [name, version] of Object.entries(allDeps)) {\n        if (\n          typeof version === 'string' &&\n          (name.includes('smrt') ||\n            name.includes('@have/') ||\n            (await hasSmrtManifest(nodeModulesPath, name)))\n        ) {\n          packages.push(name);\n        }\n      }\n    }\n  } catch (error) {\n    console.warn('[smrt:consumer] Error discovering packages:', error);\n  }\n\n  return packages;\n}\n\n/**\n * Check if a package has SMRT manifest\n */\nasync function hasSmrtManifest(\n  nodeModulesPath: string,\n  packageName: string,\n): Promise<boolean> {\n  const packagePath = path.join(nodeModulesPath, packageName);\n  const manifestPath = path.join(\n    packagePath,\n    'dist',\n    'manifest',\n    'static-manifest.js',\n  );\n  return fs.existsSync(manifestPath);\n}\n\n/**\n * Aggregate type manifests from multiple packages\n */\nasync function aggregateTypeManifests(\n  packages: string[],\n  projectRoot: string,\n): Promise<any> {\n  const aggregatedManifest = {\n    version: '1.0.0',\n    timestamp: Date.now(),\n    objects: {} as Record<string, any>,\n  };\n\n  for (const packageName of packages) {\n    try {\n      const manifestPath = path.join(\n        projectRoot,\n        'node_modules',\n        packageName,\n        'dist',\n        'manifest',\n        'static-manifest.js',\n      );\n\n      if (fs.existsSync(manifestPath)) {\n        // Import the manifest\n        const manifestModule = await import(manifestPath);\n        const manifest =\n          manifestModule.staticManifest || manifestModule.default;\n\n        if (manifest?.objects) {\n          Object.assign(aggregatedManifest.objects, manifest.objects);\n        }\n      }\n    } catch (error) {\n      console.warn(\n        `[smrt:consumer] Error loading manifest from ${packageName}:`,\n        error,\n      );\n    }\n  }\n\n  return aggregatedManifest;\n}\n\n/**\n * Generate project-specific types\n */\nasync function generateProjectTypes(\n  typeManifest: any,\n  typesDir: string,\n  projectRoot: string,\n): Promise<void> {\n  if (!typeManifest || Object.keys(typeManifest.objects).length === 0) {\n    console.log(\n      '[smrt:consumer] No SMRT objects found, skipping type generation',\n    );\n    return;\n  }\n\n  await generateDeclarations({\n    manifest: typeManifest,\n    outDir: typesDir,\n    projectRoot,\n    includeVirtualModules: true,\n    includeObjectTypes: true,\n  });\n\n  console.log(\n    `[smrt:consumer] Generated types for ${Object.keys(typeManifest.objects).length} objects`,\n  );\n}\n\n/**\n * Get type file name for virtual module\n */\nfunction getTypeFileName(virtualModule: string): string {\n  const moduleMap: Record<string, string> = {\n    '@smrt/routes': 'smrt-routes.d.ts',\n    '@smrt/client': 'smrt-client.d.ts',\n    '@smrt/mcp': 'smrt-mcp.d.ts',\n    '@smrt/types': 'smrt-types.d.ts',\n    '@smrt/manifest': 'smrt-manifest.d.ts',\n  };\n  return moduleMap[virtualModule] || 'smrt-unknown.d.ts';\n}\n\n/**\n * Fallback modules for when types aren't available\n */\nfunction generateFallbackRoutesModule(): string {\n  return `\n// Fallback routes module\nexport function setupRoutes(app) {\n  console.warn('[smrt:consumer] No routes available - SMRT packages may not be properly configured');\n}\nexport default setupRoutes;\n`;\n}\n\nfunction generateFallbackClientModule(manifest: any): string {\n  const objects = Object.entries(manifest?.objects || {});\n  if (objects.length === 0) {\n    return `\n// Fallback client module\nexport function createClient(basePath = '/api/v1') {\n  console.warn('[smrt:consumer] No API client available - SMRT packages may not be properly configured');\n  return {};\n}\nexport default createClient;\n`;\n  }\n\n  // Generate basic client from manifest\n  const clientMethods = objects\n    .map(([name, obj]: [string, any]) => {\n      const { collection } = obj;\n      return `\n  ${name}: {\n    list: () => fetch(basePath + '/${collection}').then(r => r.json()),\n    get: (id) => fetch(basePath + '/${collection}/' + id).then(r => r.json()),\n    create: (data) => fetch(basePath + '/${collection}', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    }).then(r => r.json()),\n    update: (id, data) => fetch(basePath + '/${collection}/' + id, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    }).then(r => r.json()),\n    delete: (id) => fetch(basePath + '/${collection}/' + id, {\n      method: 'DELETE'\n    }).then(r => r.ok)\n  }`;\n    })\n    .join(',');\n\n  return `\n// Auto-generated API client from SMRT consumer\nexport function createClient(basePath = '/api/v1') {\n  return {${clientMethods}\n  };\n}\nexport default createClient;\n`;\n}\n\nfunction generateFallbackMcpModule(): string {\n  return `\n// Fallback MCP module\nexport const tools = [];\nexport function createMCPServer() {\n  console.warn('[smrt:consumer] No MCP tools available - SMRT packages may not be properly configured');\n  return { name: 'smrt-consumer', version: '1.0.0', tools: [] };\n}\nexport default createMCPServer;\n`;\n}\n\nfunction generateFallbackTypesModule(manifest: any): string {\n  const objects = Object.entries(manifest?.objects || {});\n  if (objects.length === 0) {\n    return `// No types available`;\n  }\n\n  // Generate basic interfaces\n  const interfaces = objects.map(([_name, obj]: [string, any]) => {\n    return `export interface ${obj.className}Data {\n  id?: string;\n  created_at?: string;\n  updated_at?: string;\n  [key: string]: any;\n}`;\n  });\n\n  return interfaces.join('\\n\\n');\n}\n\nfunction generateFallbackManifestModule(manifest: any): string {\n  return `\n// Auto-generated manifest from SMRT consumer\nexport const manifest = ${JSON.stringify(manifest, null, 2)};\nexport default manifest;\n`;\n}\n"],"names":[],"mappings":"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"}