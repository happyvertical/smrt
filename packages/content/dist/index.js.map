{"version":3,"file":"index.js","sources":["../src/content.ts","../src/contents.ts","../src/utils.ts"],"sourcesContent":["import type { SmrtObjectOptions } from '@smrt/core';\nimport { SmrtObject, smrt } from '@smrt/core';\n\n/**\n * Options for Content initialization\n */\nexport interface ContentOptions extends SmrtObjectOptions {\n  /**\n   * Content type classification\n   */\n  type?: string | null;\n\n  /**\n   * Content variant for namespaced classification within types\n   * Format: generator:domain:specific-type\n   * Example: \"praeco:meeting:upcoming\"\n   */\n  variant?: string | null;\n\n  /**\n   * Reference to file storage key\n   */\n  fileKey?: string | null;\n\n  /**\n   * Author of the content\n   */\n  author?: string | null;\n\n  /**\n   * Content title\n   */\n  title?: string | null;\n\n  /**\n   * Short description or summary\n   */\n  description?: string | null;\n\n  /**\n   * Main content body text\n   */\n  body?: string | null;\n\n  /**\n   * Date when content was published\n   */\n  publish_date?: Date | null;\n\n  /**\n   * URL source of the content\n   */\n  url?: string | null;\n\n  /**\n   * Original source identifier\n   */\n  source?: string | null;\n\n  /**\n   * Publication status\n   */\n  status?: 'published' | 'draft' | 'archived' | 'deleted' | null;\n\n  /**\n   * Content state flag\n   */\n  state?: 'deprecated' | 'active' | 'highlighted' | null;\n\n  /**\n   * Original URL of the content\n   */\n  original_url?: string | null;\n\n  /**\n   * Content language\n   */\n  language?: string | null;\n\n  /**\n   * Content tags\n   */\n  tags?: string[];\n\n  /**\n   * Additional metadata\n   */\n  metadata?: Record<string, any>;\n}\n\n/**\n * Structured content object with metadata and body text\n *\n * Content represents any text-based content with metadata such as\n * title, author, description, and publishing information. It supports\n * referencing related content objects.\n */\n@smrt({\n  api: {\n    include: ['list', 'get', 'create', 'update', 'delete'], // Full CRUD operations\n  },\n  mcp: {\n    include: ['list', 'get', 'create', 'update'], // AI tools for content management\n  },\n  cli: true, // Enable CLI commands for content management\n})\nexport class Content extends SmrtObject {\n  /**\n   * Array of referenced content objects\n   */\n  protected references: Content[] = [];\n\n  /**\n   * Content type classification\n   */\n  public type: string | null = null;\n\n  /**\n   * Content variant for namespaced classification within types\n   * Format: generator:domain:specific-type\n   * Example: \"praeco:meeting:upcoming\"\n   */\n  public variant: string | null = null;\n\n  /**\n   * Reference to file storage key\n   */\n  public fileKey: string | null = null;\n\n  /**\n   * Author of the content\n   */\n  public author: string | null = null;\n\n  /**\n   * Content title\n   */\n  public title = '';\n\n  /**\n   * Short description or summary\n   */\n  public description: string | null = null;\n\n  /**\n   * Main content body text\n   */\n  public body = '';\n\n  /**\n   * Date when content was published\n   */\n  public publish_date: Date | null = null;\n\n  /**\n   * URL source of the content\n   */\n  public url: string | null = null;\n\n  /**\n   * Original source identifier\n   */\n  public source: string | null = null;\n\n  /**\n   * Original URL of the content\n   */\n  public original_url: string | null = null;\n\n  /**\n   * Content language\n   */\n  public language: string | null = null;\n\n  /**\n   * Content tags\n   */\n  public tags: string[] = [];\n\n  /**\n   * Publication status\n   */\n  public status: 'published' | 'draft' | 'archived' | 'deleted' = 'draft';\n\n  /**\n   * Content state flag\n   */\n  public state: 'deprecated' | 'active' | 'highlighted' = 'active';\n\n  /**\n   * Additional JSON metadata for flexible schema extension\n   */\n  public metadata: Record<string, any> = {};\n\n  /**\n   * Creates a new Content instance\n   */\n  constructor(options: ContentOptions = {}) {\n    super(options);\n    this.type = options.type || null;\n    this.variant = options.variant || null;\n    this.fileKey = options.fileKey || null;\n    this.author = options.author || null;\n    this.title = options.title || '';\n    this.description = options.description || null;\n    this.body = options.body || '';\n    this.publish_date = options.publish_date || null;\n    this.source = options.source || null;\n    this.original_url = options.original_url || null;\n    this.language = options.language || null;\n    this.status = options.status || 'draft';\n    this.tags = options.tags || [];\n    this.state = options.state || 'active';\n    this.metadata = options.metadata || {};\n  }\n\n  /**\n   * Initializes this content object\n   *\n   * @returns Promise that resolves to this instance\n   */\n  async initialize(): Promise<this> {\n    await super.initialize();\n    // Set name to title for SmrtObject compatibility\n    if (this.title && !this.name) {\n      this.name = this.title;\n    }\n    return this;\n  }\n\n  /**\n   * Loads referenced content objects\n   *\n   * @returns Promise that resolves when references are loaded\n   */\n  public async loadReferences() {}\n\n  /**\n   * Adds a reference to another content object\n   *\n   * @param content - Content object or URL to reference\n   * @returns Promise that resolves when the reference is added\n   */\n  public async addReference(content: Content | string) {\n    if (typeof content === 'string') {\n      content = new Content({\n        url: content,\n      } as any);\n      await content.initialize();\n    }\n    this.references.push(content);\n  }\n\n  /**\n   * Gets all referenced content objects\n   *\n   * @returns Promise resolving to an array of referenced Content objects\n   */\n  public async getReferences() {\n    return this.references;\n  }\n\n  /**\n   * Converts this content object to a plain JSON object\n   *\n   * @returns JSON representation of this content\n   */\n  public toJSON() {\n    return {\n      id: this.id || '',\n      slug: this.slug || '',\n      context: this.context || '',\n      type: this.type,\n      variant: this.variant || '',\n      fileKey: this.fileKey || '',\n      author: this.author || '',\n      title: this.title || '',\n      description: this.description || '',\n      body: this.body || '',\n      publish_date: this.publish_date || '',\n      url: this.url || '',\n      source: this.source || '',\n      status: this.status || 'draft',\n      state: this.state || 'active',\n    };\n  }\n}\n","import { writeFile } from 'node:fs/promises';\nimport path from 'node:path';\nimport type { AIClientOptions } from '@have/ai';\nimport { fetchDocument } from '@have/documents';\nimport { ensureDirectoryExists } from '@have/files';\nimport { makeSlug } from '@have/utils';\nimport type { SmrtCollectionOptions } from '@smrt/core';\nimport { SmrtCollection } from '@smrt/core';\nimport YAML from 'yaml';\nimport { Content } from './content';\n\n/**\n * Configuration options for Contents collection\n */\nexport interface ContentsOptions extends SmrtCollectionOptions {\n  /**\n   * AI client configuration options\n   */\n  ai?: AIClientOptions;\n\n  /**\n   * Directory to store content files\n   */\n  contentDir?: string;\n}\n\n/**\n * Collection for managing Content objects\n *\n * The Contents collection provides functionality for managing and manipulating\n * collections of Content objects, including saving to the filesystem and\n * mirroring content from remote URLs.\n */\nexport class Contents extends SmrtCollection<Content> {\n  /**\n   * Class constructor for collection items\n   */\n  static _itemClass = Content;\n\n  /**\n   * Configuration options\n   */\n  public options: ContentsOptions = {} as ContentsOptions;\n\n  /**\n   * Directory to store content files\n   */\n  public contentDir?: string;\n\n  /**\n   * Cache for loaded content\n   */\n  public loaded: Map<string, Content>;\n\n  /**\n   * Creates a new Contents collection\n   *\n   * Use the static `create()` method inherited from SmrtCollection for proper initialization.\n   *\n   * @param options - Configuration options\n   */\n  constructor(options: ContentsOptions) {\n    super(options);\n    this.options = options; //needed cause redeclare above i think ?\n    this.loaded = new Map();\n  }\n\n  /**\n   * Gets the database interface\n   *\n   * @returns Database interface\n   */\n  getDb() {\n    return this._db;\n  }\n\n  /**\n   * Initializes the collection\n   *\n   * @returns Promise that resolves to this instance\n   */\n  public async initialize(): Promise<this> {\n    await super.initialize();\n    return this;\n  }\n\n  /**\n   * Mirrors content from a remote URL\n   *\n   * Downloads and stores content from a remote URL, extracting text\n   * and saving it as a Content object.\n   *\n   * @param options - Mirror options\n   * @param options.url - URL to mirror\n   * @param options.mirrorDir - Directory for caching mirrored files\n   * @param options.context - Context for the mirrored content\n   * @returns Promise resolving to the mirrored Content object\n   * @throws Error if URL is invalid or missing\n   */\n  public async mirror(options: {\n    url: string;\n    mirrorDir?: string;\n    context?: string;\n  }) {\n    if (!options.url) {\n      throw new Error('No URL provided');\n    }\n    let url: URL;\n    try {\n      // const url = new URL(options.url);\n      // const existing = await this.db\n      //   .oO`SELECT * FROM contents WHERE url = ${options.url}`;\n      url = new URL(options.url); // validate url\n    } catch (error) {\n      console.error(error);\n      throw new Error(`Invalid URL provided: ${options.url}`);\n    }\n    const existing = await this.get({ url: options.url });\n    if (existing) {\n      return existing;\n    }\n\n    // Fetch and process the document using @have/documents\n    const doc = await fetchDocument(options.url, {\n      cacheDir: options?.mirrorDir,\n    });\n\n    const filename = url.pathname.split('/').pop();\n    const nameWithoutExtension = filename?.replace(/\\.[^/.]+$/, '');\n    const title = nameWithoutExtension?.replace(/[-_]/g, ' ');\n    const slug = makeSlug(title as string);\n\n    // Extract text from all document parts\n    const body = doc.parts.map((part) => part.content).join('\\n\\n');\n    if (body) {\n      const content = new Content({\n        url: options.url,\n        type: 'mirror',\n        title,\n        slug,\n        context: options.context || '',\n        body,\n      } as any);\n      await content.initialize();\n      await content.save();\n      return content;\n    }\n  }\n\n  /**\n   * Writes a Content object to the filesystem as a markdown file\n   *\n   * @param options - Options for writing the content file\n   * @param options.content - Content object to write\n   * @param options.contentDir - Directory to write the file to\n   * @returns Promise that resolves when the file is written\n   * @throws Error if contentDir is not provided\n   */\n  public async writeContentFile(options: {\n    content: Content;\n    contentDir: string;\n  }) {\n    const { content, contentDir } = options;\n    if (!contentDir) {\n      throw new Error('No content dir provided');\n    }\n\n    const { body } = content;\n    const frontMatter = {\n      title: content.title,\n      slug: content.slug,\n      context: content.context,\n      author: content.author,\n      publish_date: content.publish_date,\n    };\n\n    let output = '';\n    if (frontMatter && Object.keys(frontMatter).length > 0) {\n      output += '---\\n';\n      output += YAML.stringify(frontMatter);\n      output += '---\\n';\n    }\n\n    // Format body as markdown if it's plain text\n    let formattedBody = body || '';\n    if (body && !this.isMarkdown(body)) {\n      formattedBody = this.formatAsMarkdown(body);\n    }\n    output += formattedBody;\n\n    const pathParts = [\n      contentDir,\n      content.context || '', // if empty, use empty string\n      content.slug,\n      'index.md',\n    ].filter(Boolean); // remove empty strings\n\n    const outputFile = path.join(...(pathParts as string[]));\n    await ensureDirectoryExists(path.dirname(outputFile));\n    await writeFile(outputFile, output);\n  }\n\n  /**\n   * Checks if text appears to be in markdown format\n   *\n   * @param text - Text to check\n   * @returns Boolean indicating if the text contains markdown syntax\n   */\n  private isMarkdown(text: string): boolean {\n    // Basic check for common markdown indicators\n    const markdownIndicators = [\n      /^#\\s/m, // Headers\n      /\\*\\*.+\\*\\*/, // Bold\n      /\\*.+\\*/, // Italic\n      /\\[.+\\]\\(.+\\)/, // Links\n      /^\\s*[-*+]\\s/m, // Lists\n      /^\\s*\\d+\\.\\s/m, // Numbered lists\n      /```[\\s\\S]*```/, // Code blocks\n      /^\\s*>/m, // Blockquotes\n    ];\n\n    return markdownIndicators.some((indicator) => indicator.test(text));\n  }\n\n  /**\n   * Formats plain text as simple markdown\n   *\n   * @param text - Plain text to format\n   * @returns Text formatted as basic markdown\n   */\n  private formatAsMarkdown(text: string): string {\n    // Basic formatting of plain text to markdown\n    return text\n      .split(/\\n\\n+/)\n      .map((paragraph) => paragraph.trim())\n      .filter(Boolean)\n      .join('\\n\\n');\n  }\n\n  /**\n   * Synchronizes content to the filesystem\n   *\n   * Writes all article-type Content objects to the filesystem\n   * as markdown files.\n   *\n   * @param options - Sync options\n   * @param options.contentDir - Directory to write content files to\n   * @returns Promise that resolves when synchronization is complete\n   */\n  public async syncContentDir(options: { contentDir?: string }) {\n    const contentFilter = {\n      type: 'article',\n    };\n\n    const contents = await this.list({ where: contentFilter });\n    for (const content of contents) {\n      await this.writeContentFile({\n        content,\n        contentDir: options.contentDir || this.options.contentDir || '',\n      });\n    }\n  }\n\n  // public async list(options: {\n  //   where?: object;\n  //   filter?: object;\n  //   offset?: number;\n  //   limit?: number;\n  // }): Promise<Content[]> {\n  //   const { where, filter, offset, limit } = options;\n\n  //   const replacements: any[] = [];\n  //   let currIndex = 1;\n\n  //   let whereSql = '';\n  //   if (where) {\n  //     whereSql = 'where ';\n  //     for (const [key, value] of Object.entries(where)) {\n  //       whereSql += ` AND ${key} = $${currIndex++}`;\n  //       replacements.push(value);\n  //     }\n  //   }\n\n  //   let whereNotSql = '';\n  //   if (filter) {\n  //     if (whereSql) {\n  //       whereNotSql = ' and ';\n  //     } else {\n  //       whereNotSql += ' where ';\n  //     }\n  //     for (const [key, value] of Object.entries(filter)) {\n  //       whereNotSql += `${key} != $${currIndex++}`;\n  //       replacements.push(value);\n  //     }\n  //   }\n\n  //   const { rows } = await this._db.query(\n  //     `SELECT * FROM contents ${whereSql} ${whereNotSql} LIMIT ${limit} OFFSET ${offset}`,\n  //     replacements,\n  //   );\n\n  //   return Promise.all(rows.map((row: any) => this.create(row)));\n  // }\n}\n","import yaml from 'yaml';\nimport type { Content } from './content';\n\n/**\n * Converts a Content object to a string with YAML frontmatter\n *\n * @param content - Content object to convert\n * @returns String with YAML frontmatter and body content\n */\nexport function contentToString(content: Content) {\n  const { body, ...frontmatter } = content;\n  const separator = '---';\n  const frontmatterYAML = yaml.stringify(frontmatter);\n  return `${separator}\\n${frontmatterYAML}\\n${separator}\\n${body}`;\n}\n\n/**\n * Converts a string with YAML frontmatter to a Content object\n *\n * @param data - String with YAML frontmatter and body content\n * @returns Object with parsed frontmatter and body content\n */\nexport function stringToContent(data: string) {\n  const separator = '---';\n  const frontmatterStart = data.indexOf(separator);\n\n  let frontmatter = {};\n  let body = data;\n\n  if (frontmatterStart !== -1) {\n    const frontmatterEnd = data.indexOf(\n      separator,\n      frontmatterStart + separator.length,\n    );\n\n    if (frontmatterEnd !== -1) {\n      const frontmatterYAML = data\n        .substring(frontmatterStart + separator.length, frontmatterEnd)\n        .trim();\n      frontmatter = yaml.parse(frontmatterYAML) || {}; // Handle potential YAML parsing errors\n      body = data.substring(frontmatterEnd + separator.length).trim();\n    }\n  }\n\n  return {\n    ...frontmatter,\n    body,\n  };\n}\n"],"names":["YAML"],"mappings":"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"}